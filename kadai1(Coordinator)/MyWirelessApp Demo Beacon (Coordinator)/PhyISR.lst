*** EVALUATION ***
ANSI-C/cC++ Compiler for HC08 V-5.0.41 Build 12319, Nov 15 2012

    1:  /************************************************************************************
    2:  * MC1323X: This module is the PHY layer MC1323X (interrupt) handlers
    3:  *
    4:  * (c) Copyright 2009, Freescale, Inc.  All rights reserved.
    5:  *
    6:  * No part of this document must be reproduced in any form - including copied,
    7:  * transcribed, printed or by any electronic means - without specific written
    8:  * permission from Freescale Semiconductor.
    9:  *
   10:  ************************************************************************************/
   11:  
   12:  
   13:  /************************************************************************************
   14:  *************************************************************************************
   15:  * Includes
   16:  *************************************************************************************
   17:  ************************************************************************************/
   18:  #include "EmbeddedTypes.h"
   19:  #include "IrqControlLib.h"
   20:  #include "IoConfig.h"
   21:  #include "Phy.h"
   22:  #include "PhyDebugMC1323X.h"
   23:  #include "PlatformInit.h"
   24:  #include "UART_Interface.h"
   25:  
   26:  
   27:  /************************************************************************************
   28:  *************************************************************************************
   29:  * Public memory declarations
   30:  *************************************************************************************
   31:  ************************************************************************************/
   32:  uint8_t mPhyLastRxLQI;
   33:  void (*pfPhyRxTxEndCallback)(void) = NULL;
   34:  extern void (*pfPhyRxTxStartCallback)(void);
   35:  
   36:  /************************************************************************************
   37:  *************************************************************************************
   38:  * Private constants
   39:  *************************************************************************************
   40:  ************************************************************************************/
   41:  
   42:  
   43:  /************************************************************************************
   44:  *************************************************************************************
   45:  * Private memory declarations
   46:  *************************************************************************************
   47:  ************************************************************************************/
   48:  
   49:  static phyRxParams_t * mpRxParams = NULL;
   50:  
   51:  
   52:  /************************************************************************************
   53:  *************************************************************************************
   54:  * Private prototypes
   55:  *************************************************************************************
   56:  ************************************************************************************/
   57:  
   58:  /* Place it in NON_BANKED memory */
   59:  #ifdef MEMORY_MODEL_BANKED
   60:  #pragma CODE_SEG __NEAR_SEG NON_BANKED
   61:  #else
   62:  #pragma CODE_SEG DEFAULT
   63:  #endif /* MEMORY_MODEL_BANKED */
   64:  
   65:  static void    PhyISR_SeqCleanup(void);
   66:  static void    PhyISR_TimeoutCleanup(void);
   67:  static uint8_t Phy_LqiConvert(void);
   68:  static uint8_t Phy_GetEnergyLevel(void);
   69:  
   70:  
   71:  /************************************************************************************
   72:  *************************************************************************************
   73:  * Public functions
   74:  *************************************************************************************
   75:  ************************************************************************************/
   76:  
   77:  uint8_t PhyGetLastRxLqiValue(void)
   78:  {
   79:    return mPhyLastRxLQI;
  0000 c60000   [4]             LDA   mPhyLastRxLQI
   80:  }
  0003 81       [6]             RTS   
   81:  
   82:  /************************************************************************************
   83:  *************************************************************************************
   84:  * Private functions
   85:  *************************************************************************************
   86:  ************************************************************************************/
   87:  // Needed to initialize Timer1 vector
   88:  void DummyIsr(void)
   89:  {
   90:    ;
   91:  }
  0000 81       [6]             RTS   
   92:  
   93:  void (*pTimer1Isr)(void) = DummyIsr; // Makes it possible to dynamically change interrupt vector for testing!
   94:  
   95:  /***********************************************************************************/
   96:  void PhyPassRxParams(phyRxParams_t * pRxParam)
   97:  {
   98:    mpRxParams = pRxParam;
  0000 960000   [5]             STHX  mpRxParams
   99:  }
  0003 81       [6]             RTS   
  100:  
  101:  /***********************************************************************************/
  102:  
  103:  static void PhyISR_SeqCleanup(void)
  104:  {
  105:    PP_PHY_STATUS1 =  PP_PHY_STATUS1_TMR3_IRQ | PP_PHY_STATUS1_TMR2_IRQ;
  0000 6e064d   [4]             MOV   #6,77
  106:    PP_PHY_STATUS2 =  PP_PHY_STATUS2_CCA_IRQ  | PP_PHY_STATUS2_RX_IRQ | PP_PHY_STATUS2_TX_IRQ | PP_PHY_STATUS2_SEQ_IRQ | PP_PHY_STATUS2_LO1UNLOCK_IRQ | PP_PHY_STATUS2_FLTR_FAIL_IRQ | PP_PHY_STATUS2_RX_WMRK_IRQ;
  0003 6e7f4e   [4]             MOV   #127,78
  107:    PP_PHY_CTL4   &= ~PP_PHY_CTL4_TMR3MSK_BIT; // unmask TMR3 interrupt
  0006 1d47     [5]             BCLR  6,71
  108:    PP_PHY_CTL3   |=  PP_PHY_CTL3_SEQ_MSK_BIT | PP_PHY_CTL3_TX_MSK_BIT | PP_PHY_CTL3_RX_MSK_BIT | PP_PHY_CTL3_CCA_MSK_BIT; // mask SEQ, RX, TX and CCA interrupts
  0008 b646     [3]             LDA   70
  000a aa0f     [2]             ORA   #15
  000c b746     [3]             STA   70
  109:  }
  000e 81       [6]             RTS   
  110:  
  111:  /***********************************************************************************/
  112:  
  113:  static void PhyISR_TimeoutCleanup(void)
  114:  {
  115:    PP_PHY_STATUS1 =  PP_PHY_STATUS1_TMR3_IRQ | PP_PHY_STATUS1_TMR2_IRQ;
  0000 6e064d   [4]             MOV   #6,77
  116:    PP_PHY_STATUS2 =  PP_PHY_STATUS2_CCA_IRQ  | PP_PHY_STATUS2_RX_IRQ | PP_PHY_STATUS2_TX_IRQ | PP_PHY_STATUS2_SEQ_IRQ | PP_PHY_STATUS2_LO1UNLOCK_IRQ | PP_PHY_STATUS2_FLTR_FAIL_IRQ | PP_PHY_STATUS2_RX_WMRK_IRQ;
  0003 6e7f4e   [4]             MOV   #127,78
  117:    PP_PHY_CTL3   |=  PP_PHY_CTL3_SEQ_MSK_BIT | PP_PHY_CTL3_TX_MSK_BIT | PP_PHY_CTL3_RX_MSK_BIT | PP_PHY_CTL3_CCA_MSK_BIT; // mask SEQ, RX, TX and CCA interrupts
  0006 b646     [3]             LDA   70
  0008 aa0f     [2]             ORA   #15
  000a b746     [3]             STA   70
  118:    PP_PHY_CTL2   &= ~PP_PHY_CTL2_TC3TMOUT_BIT;
  000c 1d45     [5]             BCLR  6,69
  119:    PP_PHY_CTL4   &= ~PP_PHY_CTL4_TMR3CMP_EN_BIT;
  000e 1547     [5]             BCLR  2,71
  120:    PP_PHY_CTL4   |=  PP_PHY_CTL4_TMR3MSK_BIT; // mask TMR3 interrupt
  0010 1c47     [5]             BSET  6,71
  121:  }
  0012 81       [6]             RTS   
  122:  
  123:  /***********************************************************************************/
  124:  
  125:  static uint8_t Phy_LqiConvert(void)
  126:  {
  127:    uint8_t     linkQuality = PP_PHY_CCAFNL;
  0000 be50     [3]             LDX   80
  128:    
  129:  #ifndef gLQIMappingForRF4CE_c
  130:    // Recalculate the link quality to conform with other link quality measures
  131:    // Make dynamics of the energy level vary from 0x00-0xff
  132:    if (linkQuality > 190) {
  0002 a3be     [2]             CPX   #-66
  0004 2302     [3]             BLS   L8 ;abs = 0008
  133:      linkQuality = 190; //190 = -95dBm as floor (translates to 0x00)
  134:    }
  0006 aebe     [2]             LDX   #-66
  0008          L8:     
  135:    if (linkQuality < 33) {
  0008 a321     [2]             CPX   #33
  000a 2402     [3]             BCC   LE ;abs = 000e
  136:      linkQuality = 33; //33 = -16.5 dBm as top (saturation)
  137:    }
  000c ae21     [2]             LDX   #33
  000e          LE:     
  138:    linkQuality = 190 - linkQuality;
  000e a6be     [2]             LDA   #-66
  0010 89       [2]             PSHX  
  0011 95       [2]             TSX   
  0012 f0       [3]             SUB   ,X
  139:    linkQuality = linkQuality + (linkQuality >> 1) + (linkQuality >> 3); // equivalent with multiply by 1.625
  0013 f7       [2]             STA   ,X
  0014 44       [1]             LSRA  
  0015 fb       [3]             ADD   ,X
  0016 fe       [3]             LDX   ,X
  0017 54       [1]             LSRX  
  0018 54       [1]             LSRX  
  0019 54       [1]             LSRX  
  001a 9ee701   [4]             STA   1,SP
  001d 9f       [1]             TXA   
  001e 95       [2]             TSX   
  001f fb       [3]             ADD   ,X
  140:  #else // gLQIMappingForRF4CE_c
  141:    linkQuality = 255 - linkQuality;
  142:  #endif // gLQIMappingForRF4CE_c
  143:    
  144:    /* Save LQI value for ZTC */
  145:    mPhyLastRxLQI = linkQuality;
  0020 c70000   [4]             STA   mPhyLastRxLQI
  146:    
  147:    return linkQuality;
  0023 8a       [3]             PULH  
  148:  }
  0024 81       [6]             RTS   
  149:  
  150:  /************************************************************************************
  151:  * Get and convert energyLevel
  152:  *
  153:  * ED returns values between -75 dBm to about -11.5 dBm which are represented by decimal
  154:  * values 150 and 23 respectively.
  155:  *
  156:  ************************************************************************************/
  157:  
  158:  static uint8_t Phy_GetEnergyLevel(void)
  159:  {
  160:    uint8_t   energyLevel = PP_PHY_CCAFNL;
  0000 be50     [3]             LDX   80
  161:  
  162:    // Make dynamics of the energy level vary from 0x00-0xff
  163:    if (energyLevel > 150)
  0002 a396     [2]             CPX   #-106
  0004 2302     [3]             BLS   L8 ;abs = 0008
  164:    {
  165:      energyLevel = 150; //150 = -75dBm as floor (translates to 0x00)
  166:    }
  0006 ae96     [2]             LDX   #-106
  0008          L8:     
  167:    if (energyLevel < 23)
  0008 a317     [2]             CPX   #23
  000a 2402     [3]             BCC   LE ;abs = 000e
  168:    {
  169:      energyLevel = 23; //23 = -11.5 dBm as top (saturation)
  170:    }
  000c ae17     [2]             LDX   #23
  000e          LE:     
  171:    energyLevel = 150 - energyLevel;  // 150 = -75dBm as floor (translates to 0xFF)
  000e a696     [2]             LDA   #-106
  0010 89       [2]             PSHX  
  0011 95       [2]             TSX   
  0012 f0       [3]             SUB   ,X
  172:    
  173:    // Now double the value to "stretch" the dynamics up to 255
  174:    energyLevel = energyLevel << 1;
  0013 48       [1]             LSLA  
  175:  
  176:    return energyLevel;
  0014 8a       [3]             PULH  
  177:  }
  0015 81       [6]             RTS   
  178:  
  179:  /***********************************************************************************/
  180:  
  181:  INTERRUPT_KEYWORD void PhyHandlerTx_ISR(void)
  182:  {
  0000 8b       [2]             PSHH  
  0001 a7fe     [2]             AIS   #-2
  183:    uint8_t xcvseqCopy, status2Copy;
  184:  #if gUart1_EnableHWFlowControl_d
  185:    uint8_t flowCtrState = (PTDD & 0x04);
  186:  #endif
  187:    
  188:  #if (gPpdMode_d != gPpdModeOFF_d) 
  189:    volatile uint8_t temp;
  190:  #endif //(gPpdMode_d != gPpdModeOFF_d  
  191:    PHY_DEBUG_LOG(PDBG_TX_VECT_INTERRUPT);
  192:  
  193:    status2Copy     =  PP_PHY_STATUS2 & (PP_PHY_STATUS2_SEQ_IRQ | PP_PHY_STATUS2_LO1UNLOCK_IRQ);
  0003 b64e     [3]             LDA   78
  0005 a441     [2]             AND   #65
  0007 95       [2]             TSX   
  0008 f7       [2]             STA   ,X
  194:    xcvseqCopy      =  PhyGetSeqState();        // read XCVSEQ
  0009 b644     [3]             LDA   68
  000b a407     [2]             AND   #7
  000d e701     [3]             STA   1,X
  195:    
  196:  #if gUart1_EnableHWFlowControl_d  
  197:    //disable uart flow control
  198:    PTDD |= 0x04;
  199:  #endif
  200:  
  201:    IrqControlLib_DisableMC1323xIrq();
  000f 1e45     [5]             BSET  7,69
  202:    IrqControlLib_EnableAllIrqs();
  0011 9a       [1]             CLI   
  203:  
  204:    if(status2Copy & PP_PHY_STATUS2_LO1UNLOCK_IRQ)
  0012 f6       [3]             LDA   ,X
  0013 a540     [2]             BIT   #64
  0015 270c     [3]             BEQ   L23 ;abs = 0023
  205:    {
  206:      #ifdef PHY_ISR_HOOKS
  207:      PhyPlmeUnlockTx();
  208:      #endif // PHY_ISR_HOOKS
  209:      PhyISR_SeqCleanup();
  0017 cd0000   [6]             JSR   PhyISR_SeqCleanup
  001a cd00b3   [6]             JSR   LB3 ;abs = 00b3
  210:  #if (gPpdMode_d != gPpdModeOFF_d)    
  211:      //PPD Mode is enabled
  212:      IoIndirectWrite(0x63, 10);        //forces cg_en low
  213:      temp = IoIndirectRead(0x63);      //this is a delay step
  214:      temp = IoIndirectRead(0x63);      //this is a delay step        
  215:      IoIndirectWrite(0x63, 0x00);      //releases cg_en
  216:  #endif //(gPpdMode_d != gPpdModeOFF_d)        
  217:      PHY_DEBUG_LOG(PDBG_SYNC_LOSS_INDICATION);
  218:      
  219:      PP_PHY_CTL1    &= ~PP_PHY_CTL1_XCVSEQ_MASK; // set the PHY sequencer back to IDLE
  220:      
  221:      PhyPlmeSyncLossIndication();
  001d cd0000   [6]             JSR   PhyPlmeSyncLossIndication
  222:      
  223:      IrqControlLib_DisableAllIrqs();
  0020 9b       [1]             SEI   
  224:      IrqControlLib_EnableMC1323xIrq();
  225:      
  226:  #if gUart1_EnableHWFlowControl_d    
  227:      //restore uart flow control state
  228:      if(flowCtrState)
  229:      {
  230:        PTDD |= 0x04;
  231:      }
  232:      else
  233:      {
  234:        PTDD &= ~0x04;
  235:      }
  236:  #endif
  237:      
  238:      return;
  0021 200d     [3]             BRA   L30 ;abs = 0030
  0023          L23:    
  239:    }
  240:    
  241:    if(PP_PHY_STATUS1 &  PP_PHY_STATUS1_TMR3_IRQ)  
  0023 054d0c   [5]             BRCLR 2,77,L32 ;abs = 0032
  242:    {
  243:     PhyISR_TimeoutCleanup();
  0026 cd0000   [6]             JSR   PhyISR_TimeoutCleanup
  0029 cd00b3   [6]             JSR   LB3 ;abs = 00b3
  244:     PHY_DEBUG_LOG(PDBG_TIMEOUT_INDICATION);
  245:     //PPD Mode is enabled
  246:  #if (gPpdMode_d != gPpdModeOFF_d)      
  247:      // set the HW sequencer to idle state
  248:      temp = IoIndirectRead(0x17);
  249:      IoIndirectWrite(0x17, 0x00);   //disable the PPD
  250:  #endif //(gPpdMode_d == gPpdModeOFF_d)            
  251:      PP_PHY_CTL1    &= ~PP_PHY_CTL1_XCVSEQ_MASK; // set the PHY sequencer back to IDLE    
  252:  #if (gPpdMode_d != gPpdModeOFF_d)        
  253:      IoIndirectWrite(0x17, temp); //restore the PPD mode
  254:  #endif //(gPpdMode_d != gPpdModeOFF_d) 
  255:  
  256:     PhyTimeRxTimeoutIndication();
  002c cd0000   [6]             JSR   PhyTimeRxTimeoutIndication
  257:     
  258:     IrqControlLib_DisableAllIrqs();
  002f 9b       [1]             SEI   
  0030          L30:    
  259:     IrqControlLib_EnableMC1323xIrq();
  260:  
  261:  #if gUart1_EnableHWFlowControl_d   
  262:     //restore uart flow control state
  263:     if(flowCtrState)
  264:     {
  265:       PTDD |= 0x04;
  266:     }
  267:     else
  268:     {
  269:       PTDD &= ~0x04;
  270:     }
  271:  #endif
  272:  
  273:     return;
  0030 207b     [3]             BRA   LAD ;abs = 00ad
  0032          L32:    
  0032 ad7f     [5]             BSR   LB3 ;abs = 00b3
  274:    }   
  275:  
  276:    //PPD Mode Abort
  277:     //PPD Mode is enabled
  278:  #if (gPpdMode_d != gPpdModeOFF_d)      
  279:      // set the HW sequencer to idle state
  280:      temp = IoIndirectRead(0x17);
  281:      IoIndirectWrite(0x17, 0x00);   //disable the PPD
  282:  #endif //(gPpdMode_d != gPpdModeOFF_d)            
  283:      PP_PHY_CTL1    &= ~PP_PHY_CTL1_XCVSEQ_MASK; // set the PHY sequencer back to IDLE    
  284:  #if (gPpdMode_d != gPpdModeOFF_d)        
  285:      IoIndirectWrite(0x17, temp); //restore the PPD mode
  286:  #endif //(gPpdMode_d != gPpdModeOFF_d) 
  287:    
  288:    PHY_DEBUG_LOG1(PDBG_SEQ_IRQ, xcvseqCopy);
  289:  
  290:    switch(xcvseqCopy)
  0034 95       [2]             TSX   
  0035 e601     [3]             LDA   1,X
  0037 410205   [4]             CBEQA #2,L3F ;abs = 003f
  003a 410422   [4]             CBEQA #4,L5F ;abs = 005f
  003d 2067     [3]             BRA   LA6 ;abs = 00a6
  003f          L3F:    
  291:    {
  292:      case gTX_c:   
  293:                    PhyISR_SeqCleanup();
  003f cd0000   [6]             JSR   PhyISR_SeqCleanup
  294:                      
  295:                    if(( PP_PHY_STATUS1 & PP_PHY_STATUS1_CCA_BIT ) && (PP_PHY_CTL1 & PP_PHY_CTL1_CCABFRTX_BIT))
  0042 0d4d0a   [5]             BRCLR 6,77,L4F ;abs = 004f
  0045 0b4407   [5]             BRCLR 5,68,L4F ;abs = 004f
  296:                    {
  297:                      PHY_DEBUG_LOG(PDBG_CCA_CONFIRM_BUSY);
  298:                      PhyPlmeCcaConfirm(gChannelBusy_c);
  0048 a601     [2]             LDA   #1
  004a cd0000   [6]             JSR   PhyPlmeCcaConfirm
  299:                    }
  004d 2003     [3]             BRA   L52 ;abs = 0052
  004f          L4F:    
  300:                    else
  301:                    {
  302:                      PHY_DEBUG_LOG(PDBG_DATA_CONFIRM);
  303:                      PhyPdDataConfirm();
  004f cd0000   [6]             JSR   PhyPdDataConfirm
  0052          L52:    
  304:                    }
  305:                    
  306:                    if (pfPhyRxTxEndCallback)
  0052 450000   [3]             LDHX  @pfPhyRxTxEndCallback
  0055 cd0000   [6]             JSR   _CMP24_RC
  0058 00               DC.B  0
  0059 0000             DC.W  0
  005b 263a     [3]             BNE   L97 ;abs = 0097
  005d 204d     [3]             BRA   LAC ;abs = 00ac
  005f          L5F:    
  307:                      pfPhyRxTxEndCallback();
  308:                    
  309:                    break;
  310:      
  311:      case gTR_c:   
  312:                    PhyISR_SeqCleanup();   
  005f cd0000   [6]             JSR   PhyISR_SeqCleanup
  313:                    
  314:                    if(( PP_PHY_STATUS1 & PP_PHY_STATUS1_CCA_BIT ) && (PP_PHY_CTL1 & PP_PHY_CTL1_CCABFRTX_BIT))
  0062 0d4d0a   [5]             BRCLR 6,77,L6F ;abs = 006f
  0065 0b4407   [5]             BRCLR 5,68,L6F ;abs = 006f
  315:                    {
  316:                        PHY_DEBUG_LOG(PDBG_CCA_CONFIRM_BUSY);
  317:                        PhyPlmeCcaConfirm(gChannelBusy_c);
  0068 a601     [2]             LDA   #1
  006a cd0000   [6]             JSR   PhyPlmeCcaConfirm
  318:                    }
  006d 201d     [3]             BRA   L8C ;abs = 008c
  006f          L6F:    
  319:                    else
  320:                    {
  321:                        if(NULL != mpRxParams)
  006f 320000   [5]             LDHX  mpRxParams
  0072 2715     [3]             BEQ   L89 ;abs = 0089
  322:                        {
  323:                           *((uint8_t*)&(mpRxParams->timeStamp)+3) = PP_PHY_TIMESTMP0;
  0074 b656     [3]             LDA   86
  0076 e703     [3]             STA   3,X
  324:                           *((uint8_t*)&(mpRxParams->timeStamp)+2) = PP_PHY_TIMESTMP8;
  0078 b655     [3]             LDA   85
  007a e702     [3]             STA   2,X
  325:                           *((uint8_t*)&(mpRxParams->timeStamp)+1) = PP_PHY_TIMESTMP16;
  007c b654     [3]             LDA   84
  007e e701     [3]             STA   1,X
  326:                           *((uint8_t*)&(mpRxParams->timeStamp)+0) = 0;
  0080 7f       [4]             CLR   ,X
  327:                           mpRxParams->linkQuality = Phy_LqiConvert();
  0081 cd0000   [6]             JSR   Phy_LqiConvert
  0084 320000   [5]             LDHX  mpRxParams
  0087 e704     [3]             STA   4,X
  0089          L89:    
  328:                        }
  329:                      
  330:                        PHY_DEBUG_LOG(PDBG_DATA_CONFIRM);
  331:                        PhyPdDataConfirm();
  0089 cd0000   [6]             JSR   PhyPdDataConfirm
  008c          L8C:    
  332:                    }                    
  333:  
  334:                    if (pfPhyRxTxEndCallback)
  008c 450000   [3]             LDHX  @pfPhyRxTxEndCallback
  008f cd0000   [6]             JSR   _CMP24_RC
  0092 00               DC.B  0
  0093 0000             DC.W  0
  0095 2715     [3]             BEQ   LAC ;abs = 00ac
  0097          L97:    
  335:                      pfPhyRxTxEndCallback();
  0097 320001   [5]             LDHX  pfPhyRxTxEndCallback:1
  009a c60000   [4]             LDA   pfPhyRxTxEndCallback
  009d 8b       [2]             PSHH  
  009e 8b       [2]             PSHH  
  009f 8b       [2]             PSHH  
  00a0 ac000000 [8]             CALL  _CALL_STAR08_FAR
  00a4 2006     [3]             BRA   LAC ;abs = 00ac
  00a6          LA6:    
  336:                    
  337:                    break;
  338:                    
  339:      default:      PhyISR_SeqCleanup();
  00a6 cd0000   [6]             JSR   PhyISR_SeqCleanup
  340:                    PHY_DEBUG_LOG(PDBG_SYNC_LOSS_INDICATION);
  341:                    PhyPlmeSyncLossIndication();
  00a9 cd0000   [6]             JSR   PhyPlmeSyncLossIndication
  00ac          LAC:    
  342:                    break;
  343:    }
  344:    
  345:    IrqControlLib_DisableAllIrqs();
  00ac 9b       [1]             SEI   
  00ad          LAD:    
  346:    IrqControlLib_EnableMC1323xIrq();
  00ad 1f45     [5]             BCLR  7,69
  347:    
  348:  #if gUart1_EnableHWFlowControl_d  
  349:    //restore uart flow control state
  350:    if(flowCtrState)
  351:    {
  352:      PTDD |= 0x04;
  353:    }
  354:    else
  355:    {
  356:      PTDD &= ~0x04;
  357:    }
  358:  #endif
  359:  
  360:  }
  00af a702     [2]             AIS   #2
  00b1 8a       [3]             PULH  
  00b2 80       [9]             RTI   
  00b3          LB3:    
  00b3 b644     [3]             LDA   68
  00b5 a4f8     [2]             AND   #-8
  00b7 b744     [3]             STA   68
  00b9 81       [6]             RTS   
  361:  
  362:  /***********************************************************************************/
  363:  
  364:  INTERRUPT_KEYWORD void PhyHandlerRx_ISR(void)
  365:  {
  0000 8b       [2]             PSHH  
  0001 a7fe     [2]             AIS   #-2
  366:    uint8_t xcvseqCopy, status2Copy;
  367:    
  368:  #if gUart1_EnableHWFlowControl_d
  369:    uint8_t flowCtrState = (PTDD & 0x04);
  370:  #endif
  371:  
  372:  #if (gPpdMode_d != gPpdModeOFF_d)  
  373:    volatile uint8_t temp;
  374:  #endif //(gPpdMode_d != gPpdModeOFF_d)
  375:    PHY_DEBUG_LOG(PDBG_RX_VECT_INTERRUPT);
  376:  
  377:    status2Copy     =  PP_PHY_STATUS2 & (PP_PHY_STATUS2_SEQ_IRQ | PP_PHY_STATUS2_LO1UNLOCK_IRQ);
  0003 b64e     [3]             LDA   78
  0005 a441     [2]             AND   #65
  0007 95       [2]             TSX   
  0008 f7       [2]             STA   ,X
  378:    xcvseqCopy      =  PhyGetSeqState();        // read XCVSEQ
  0009 b644     [3]             LDA   68
  000b a407     [2]             AND   #7
  000d e701     [3]             STA   1,X
  379:    
  380:  #if gUart1_EnableHWFlowControl_d  
  381:    //disable uart flow control
  382:    PTDD |= 0x04;
  383:  #endif
  384:    
  385:    IrqControlLib_DisableMC1323xIrq();
  000f 1e45     [5]             BSET  7,69
  386:    IrqControlLib_EnableAllIrqs();
  0011 9a       [1]             CLI   
  387:    
  388:    if(status2Copy & PP_PHY_STATUS2_LO1UNLOCK_IRQ)
  0012 f6       [3]             LDA   ,X
  0013 a540     [2]             BIT   #64
  0015 270c     [3]             BEQ   L23 ;abs = 0023
  389:    {
  390:      #ifdef PHY_ISR_HOOKS
  391:      PhyPlmeUnlockRx();
  392:      #endif // PHY_ISR_HOOKS
  393:      PhyISR_SeqCleanup();
  0017 cd0000   [6]             JSR   PhyISR_SeqCleanup
  001a cd00af   [6]             JSR   LAF ;abs = 00af
  394:      //PPD Mode is enabled
  395:  #if (gPpdMode_d != gPpdModeOFF_d)        
  396:      IoIndirectWrite(0x63, 10);        //forces cg_en low
  397:      temp = IoIndirectRead(0x63); //this is a delay step
  398:      temp = IoIndirectRead(0x63); //this is a delay step        
  399:      IoIndirectWrite(0x63, 0x00);      //releases cg_en
  400:  #endif //(gPpdMode_d != gPpdModeOFF_d)    
  401:      
  402:      PHY_DEBUG_LOG(PDBG_SYNC_LOSS_INDICATION);
  403:      PP_PHY_CTL1    &= ~PP_PHY_CTL1_XCVSEQ_MASK; // set the PHY sequencer back to IDLE        
  404:      PhyPlmeSyncLossIndication();
  001d cd0000   [6]             JSR   PhyPlmeSyncLossIndication
  405:      
  406:      IrqControlLib_DisableAllIrqs();
  0020 9b       [1]             SEI   
  407:      IrqControlLib_EnableMC1323xIrq();
  408:  
  409:  #if gUart1_EnableHWFlowControl_d   
  410:      //restore uart flow control state
  411:      if(flowCtrState)
  412:      {
  413:        PTDD |= 0x04;
  414:      }
  415:      else
  416:      {
  417:        PTDD &= ~0x04;
  418:      }
  419:  #endif
  420:  
  421:      return;
  0021 200d     [3]             BRA   L30 ;abs = 0030
  0023          L23:    
  422:    }
  423:    
  424:    if(PP_PHY_STATUS1 &  PP_PHY_STATUS1_TMR3_IRQ)
  0023 054d0c   [5]             BRCLR 2,77,L32 ;abs = 0032
  425:    {
  426:     PhyISR_TimeoutCleanup();  
  0026 cd0000   [6]             JSR   PhyISR_TimeoutCleanup
  0029 cd00af   [6]             JSR   LAF ;abs = 00af
  427:     PHY_DEBUG_LOG(PDBG_TIMEOUT_INDICATION);
  428:     //PPD Mode is enabled
  429:  #if (gPpdMode_d != gPpdModeOFF_d)      
  430:      // set the HW sequencer to idle state
  431:      temp = IoIndirectRead(0x17);
  432:      IoIndirectWrite(0x17, 0x00);   //disable the PPD
  433:  #endif //(gPpdMode_d != gPpdModeOFF_d)            
  434:      PP_PHY_CTL1    &= ~PP_PHY_CTL1_XCVSEQ_MASK; // set the PHY sequencer back to IDLE    
  435:  #if (gPpdMode_d != gPpdModeOFF_d)        
  436:      IoIndirectWrite(0x17, temp); //restore the PPD mode
  437:  #endif //(gPpdMode_d != gPpdModeOFF_d) 
  438:       
  439:     
  440:     PhyTimeRxTimeoutIndication();
  002c cd0000   [6]             JSR   PhyTimeRxTimeoutIndication
  441:  
  442:     IrqControlLib_DisableAllIrqs();
  002f 9b       [1]             SEI   
  0030          L30:    
  443:     IrqControlLib_EnableMC1323xIrq();
  444:  
  445:  #if gUart1_EnableHWFlowControl_d   
  446:     //restore uart flow control state
  447:     if(flowCtrState)
  448:     {
  449:       PTDD |= 0x04;
  450:     }
  451:     else
  452:     {
  453:       PTDD &= ~0x04;
  454:     }
  455:  #endif
  456:  
  457:     return;
  0030 2077     [3]             BRA   LA9 ;abs = 00a9
  0032          L32:    
  0032 ad7b     [5]             BSR   LAF ;abs = 00af
  458:    }  
  459:    
  460:     //PPD Mode is enabled
  461:  #if (gPpdMode_d != gPpdModeOFF_d)      
  462:      // set the HW sequencer to idle state
  463:      temp = IoIndirectRead(0x17);
  464:      IoIndirectWrite(0x17, 0x00);   //disable the PPD
  465:  #endif //(gPpdMode_d != gPpdModeOFF_d)            
  466:      PP_PHY_CTL1    &= ~PP_PHY_CTL1_XCVSEQ_MASK; // set the PHY sequencer back to IDLE    
  467:  #if (gPpdMode_d != gPpdModeOFF_d)        
  468:      IoIndirectWrite(0x17, temp); //restore the PPD mode
  469:  #endif //(gPpdMode_d != gPpdModeOFF_d) 
  470:    
  471:  
  472:    PHY_DEBUG_LOG1(PDBG_SEQ_IRQ, xcvseqCopy);
  473:  
  474:    switch(xcvseqCopy)
  0034 95       [2]             TSX   
  0035 e601     [3]             LDA   1,X
  0037 a105     [2]             CMP   #5
  0039 2267     [3]             BHI   LA2 ;abs = 00a2
  003b 41012a   [4]             CBEQA #1,L68 ;abs = 0068
  003e 410306   [4]             CBEQA #3,L47 ;abs = 0047
  0041 a105     [2]             CMP   #5
  0043 265d     [3]             BNE   LA2 ;abs = 00a2
  0045 2018     [3]             BRA   L5F ;abs = 005f
  0047          L47:    
  475:    {
  476:      case gCCA_c:  // verify the presence of irqs: CCA - yes, SEQ - yes, UNLOCK - no
  477:                    PhyISR_SeqCleanup();
  0047 cd0000   [6]             JSR   PhyISR_SeqCleanup
  478:                    if( (PP_PHY_CTL2 & PP_PHY_CTL2_CCA_TYPE_MASK) == (gCcaED_c << PP_PHY_CTL2_CCA_TYPE_POS) )
  004a b645     [3]             LDA   69
  004c a518     [2]             BIT   #24
  004e 2608     [3]             BNE   L58 ;abs = 0058
  479:                    {
  480:                     // Ed
  481:                     PhyPlmeEdConfirm(Phy_GetEnergyLevel());
  0050 cd0000   [6]             JSR   Phy_GetEnergyLevel
  0053 cd0000   [6]             JSR   PhyPlmeEdConfirm
  482:                    } 
  0056 2050     [3]             BRA   LA8 ;abs = 00a8
  0058          L58:    
  483:                    else
  484:                    {
  485:                     // CCA
  486:                     if( PP_PHY_STATUS1 & PP_PHY_STATUS1_CCA_BIT )
  0058 0d4d07   [5]             BRCLR 6,77,L62 ;abs = 0062
  487:                     {                      
  488:                         PHY_DEBUG_LOG(PDBG_CCA_CONFIRM_BUSY);
  489:                         PhyPlmeCcaConfirm(gChannelBusy_c);
  005b a601     [2]             LDA   #1
  490:                     }
  005d 2004     [3]             BRA   L63 ;abs = 0063
  005f          L5F:    
  491:                     else
  492:                     {
  493:                         PHY_DEBUG_LOG(PDBG_CCA_CONFIRM_IDLE);
  494:                         PhyPlmeCcaConfirm(gChannelIdle_c);
  495:                     }
  496:                    }                    
  497:                    break;
  498:      case gCCCA_c: 
  499:                    PhyISR_SeqCleanup();
  005f cd0000   [6]             JSR   PhyISR_SeqCleanup
  0062          L62:    
  500:                    PHY_DEBUG_LOG(PDBG_CCA_CONFIRM_IDLE);
  501:                    PhyPlmeCcaConfirm(gChannelIdle_c);
  0062 4f       [1]             CLRA  
  0063          L63:    
  0063 cd0000   [6]             JSR   PhyPlmeCcaConfirm
  0066 2040     [3]             BRA   LA8 ;abs = 00a8
  0068          L68:    
  502:                    
  503:                    break;
  504:      case gRX_c:   
  505:                    PhyISR_SeqCleanup();
  0068 cd0000   [6]             JSR   PhyISR_SeqCleanup
  506:  
  507:                    if(NULL != mpRxParams)
  006b 320000   [5]             LDHX  mpRxParams
  006e 2715     [3]             BEQ   L85 ;abs = 0085
  508:                    {
  509:                          *((uint8_t*)&(mpRxParams->timeStamp)+3) = PP_PHY_TIMESTMP0;
  0070 b656     [3]             LDA   86
  0072 e703     [3]             STA   3,X
  510:                          *((uint8_t*)&(mpRxParams->timeStamp)+2) = PP_PHY_TIMESTMP8;
  0074 b655     [3]             LDA   85
  0076 e702     [3]             STA   2,X
  511:                          *((uint8_t*)&(mpRxParams->timeStamp)+1) = PP_PHY_TIMESTMP16;
  0078 b654     [3]             LDA   84
  007a e701     [3]             STA   1,X
  512:                          *((uint8_t*)&(mpRxParams->timeStamp)+0) = 0;
  007c 7f       [4]             CLR   ,X
  513:                          mpRxParams->linkQuality = Phy_LqiConvert();
  007d cd0000   [6]             JSR   Phy_LqiConvert
  0080 320000   [5]             LDHX  mpRxParams
  0083 e704     [3]             STA   4,X
  0085          L85:    
  514:                    }
  515:                    
  516:                    PHY_DEBUG_LOG(PDBG_DATA_INDICATION);
  517:                    PhyPdDataIndication();
  0085 cd0000   [6]             JSR   PhyPdDataIndication
  518:                    
  519:                    if (pfPhyRxTxEndCallback)
  0088 450000   [3]             LDHX  @pfPhyRxTxEndCallback
  008b cd0000   [6]             JSR   _CMP24_RC
  008e 00               DC.B  0
  008f 0000             DC.W  0
  0091 2715     [3]             BEQ   LA8 ;abs = 00a8
  520:                      pfPhyRxTxEndCallback();
  0093 320001   [5]             LDHX  pfPhyRxTxEndCallback:1
  0096 c60000   [4]             LDA   pfPhyRxTxEndCallback
  0099 8b       [2]             PSHH  
  009a 8b       [2]             PSHH  
  009b 8b       [2]             PSHH  
  009c ac000000 [8]             CALL  _CALL_STAR08_FAR
  00a0 2006     [3]             BRA   LA8 ;abs = 00a8
  00a2          LA2:    
  521:                    
  522:                    break;
  523:                    
  524:      default:      PhyISR_SeqCleanup();
  00a2 cd0000   [6]             JSR   PhyISR_SeqCleanup
  525:                    PHY_DEBUG_LOG(PDBG_SYNC_LOSS_INDICATION);
  526:                    PhyPlmeSyncLossIndication();
  00a5 cd0000   [6]             JSR   PhyPlmeSyncLossIndication
  00a8          LA8:    
  527:                    break;
  528:    }
  529:  
  530:  #if gUart1_EnableHWFlowControl_d  
  531:    //restore uart flow control state
  532:    if(flowCtrState)
  533:    {
  534:      PTDD |= 0x04;
  535:    }
  536:    else
  537:    {
  538:      PTDD &= ~0x04;
  539:    }
  540:  #endif  
  541:      
  542:    IrqControlLib_DisableAllIrqs();
  00a8 9b       [1]             SEI   
  00a9          LA9:    
  543:    IrqControlLib_EnableMC1323xIrq();
  00a9 1f45     [5]             BCLR  7,69
  544:  }
  00ab a702     [2]             AIS   #2
  00ad 8a       [3]             PULH  
  00ae 80       [9]             RTI   
  00af          LAF:    
  00af b644     [3]             LDA   68
  00b1 a4f8     [2]             AND   #-8
  00b3 b744     [3]             STA   68
  00b5 81       [6]             RTS   
  545:  
  546:  /***********************************************************************************/
  547:  
  548:  INTERRUPT_KEYWORD void PhyHandlerTmr_ISR(void)
  549:  {
  0000 8b       [2]             PSHH  
  550:  #if gUart1_EnableHWFlowControl_d 
  551:    uint8_t flowCtrState = (PTDD & 0x04);
  552:  #endif
  553:  #if (gPpdMode_d != gPpdModeOFF_d)    
  554:    volatile uint8_t temp;
  555:  #endif //(gPpdMode_d != gPpdModeOFF_d)    
  556:  
  557:  #if gUart1_EnableHWFlowControl_d
  558:      //disable uart flow control
  559:    PTDD |= 0x04;
  560:  #endif
  561:    
  562:    IrqControlLib_DisableMC1323xIrq();
  0001 1e45     [5]             BSET  7,69
  563:    IrqControlLib_EnableAllIrqs();
  0003 9a       [1]             CLI   
  564:    
  565:   
  566:    PHY_DEBUG_LOG(PDBG_TIMERS_VECT_INTERRUPT);
  567:    
  568:    // TMR2 IRQ servicing - start event
  569:    if(PP_PHY_STATUS1 & PP_PHY_STATUS1_TMR2_IRQ)
  0004 034d0c   [5]             BRCLR 1,77,L13 ;abs = 0013
  570:    {
  571:      PP_PHY_CTL1    &= ~PP_PHY_CTL1_TMRTRIGEN_BIT;
  0007 1f44     [5]             BCLR  7,68
  572:      PP_PHY_CTL4    &= ~PP_PHY_CTL4_TMR2CMP_EN_BIT;
  0009 1347     [5]             BCLR  1,71
  573:      PP_PHY_CTL4    |=  PP_PHY_CTL4_TMR2MSK_BIT; // mask TMR2 interrupt
  000b 1a47     [5]             BSET  5,71
  574:      PP_PHY_STATUS1  =  PP_PHY_STATUS1_TMR2_IRQ;
  000d 6e024d   [4]             MOV   #2,77
  575:      PHY_DEBUG_LOG(PDBG_START_INDICATION);
  576:      PhyTimeStartEventIndication();
  0010 cd0000   [6]             JSR   PhyTimeStartEventIndication
  0013          L13:    
  577:    }
  578:  
  579:    // TMR3 IRQ servicing - timeout event
  580:    if(PP_PHY_STATUS1 & PP_PHY_STATUS1_TMR3_IRQ)
  0013 054d12   [5]             BRCLR 2,77,L28 ;abs = 0028
  581:    {
  582:      PP_PHY_CTL2    &= ~PP_PHY_CTL2_TC3TMOUT_BIT;
  0016 1d45     [5]             BCLR  6,69
  583:      PP_PHY_CTL4    &= ~PP_PHY_CTL4_TMR3CMP_EN_BIT;
  0018 1547     [5]             BCLR  2,71
  584:      PP_PHY_CTL4    |=  PP_PHY_CTL4_TMR3MSK_BIT; // mask TMR3 interrupt
  001a 1c47     [5]             BSET  6,71
  585:      PP_PHY_STATUS1  =  PP_PHY_STATUS1_TMR3_IRQ;
  001c 6e044d   [4]             MOV   #4,77
  586:      PHY_DEBUG_LOG(PDBG_TIMEOUT_INDICATION);
  587:  
  588:      //PPD Mode is enabled
  589:  #if (gPpdMode_d != gPpdModeOFF_d)        
  590:      IoIndirectWrite(0x63, 10);        //forces cg_en low
  591:      temp = IoIndirectRead(0x63); //this is a delay step
  592:      temp = IoIndirectRead(0x63); //this is a delay step        
  593:      IoIndirectWrite(0x63, 0x00);      //releases cg_en
  594:  #endif //(gPpdMode_d != gPpdModeOFF_d)    
  595:  
  596:      /* Ensure that we're not issuing TimeoutIndication while the Automated sequence is still in progress */
  597:      /* TMR3 can expire during R-T turnaround for example, case in which the sequence is not interrupted */
  598:      if(gIdle_c == PhyGetSeqState())
  001f b644     [3]             LDA   68
  0021 a507     [2]             BIT   #7
  0023 2603     [3]             BNE   L28 ;abs = 0028
  599:      {      
  600:       PhyTimeRxTimeoutIndication();
  0025 cd0000   [6]             JSR   PhyTimeRxTimeoutIndication
  0028          L28:    
  601:      }
  602:    }
  603:    
  604:      // TMR1 IRQ servicing
  605:    if(PP_PHY_STATUS1 & PP_PHY_STATUS1_TMR1_IRQ)
  0028 014d14   [5]             BRCLR 0,77,L3F ;abs = 003f
  606:    {
  607:      PP_PHY_CTL4    &= ~PP_PHY_CTL4_TMR1CMP_EN_BIT; 
  002b 1147     [5]             BCLR  0,71
  608:      PP_PHY_CTL4    |=  PP_PHY_CTL4_TMR1MSK_BIT; // mask TMR1 interrupt
  002d 1847     [5]             BSET  4,71
  609:      PP_PHY_STATUS1 = PP_PHY_STATUS1_TMR1_IRQ;
  002f 6e014d   [4]             MOV   #1,77
  610:       
  611:      pTimer1Isr();
  0032 320001   [5]             LDHX  pTimer1Isr:1
  0035 c60000   [4]             LDA   pTimer1Isr
  0038 8b       [2]             PSHH  
  0039 8b       [2]             PSHH  
  003a 8b       [2]             PSHH  
  003b ac000000 [8]             CALL  _CALL_STAR08_FAR
  003f          L3F:    
  612:    }
  613:    
  614:    // TMR4 IRQ servicing
  615:    if(PP_PHY_STATUS1 & PP_PHY_STATUS1_TMR4_IRQ)
  003f 074d03   [5]             BRCLR 3,77,L45 ;abs = 0045
  616:    {
  617:       PP_PHY_STATUS1 = PP_PHY_STATUS1_TMR4_IRQ;
  0042 6e084d   [4]             MOV   #8,77
  0045          L45:    
  618:    }
  619:    IrqControlLib_DisableAllIrqs();
  0045 9b       [1]             SEI   
  620:    IrqControlLib_EnableMC1323xIrq();
  0046 1f45     [5]             BCLR  7,69
  621:  
  622:  #if gUart1_EnableHWFlowControl_d  
  623:    //restore uart flow control state
  624:    if(flowCtrState)
  625:    {
  626:      PTDD |= 0x04;
  627:    }
  628:    else
  629:    {
  630:      PTDD &= ~0x04;
  631:    }
  632:  #endif
  633:  
  634:  }
  0048 8a       [3]             PULH  
  0049 80       [9]             RTI   
  635:  
  636:  /***********************************************************************************/
  637:  
  638:  INTERRUPT_KEYWORD void PhyHandlerRxWtrmrk_ISR(void)
  639:  {
  0000 8b       [2]             PSHH  
  640:    PHY_DEBUG_LOG(PDBG_WTRMRK_VECT_INTERRUPT);
  641:    if(PP_PHY_STATUS2 & PP_PHY_STATUS2_RX_WMRK_IRQ)
  0001 094e03   [5]             BRCLR 4,78,L7 ;abs = 0007
  642:    {
  643:      PP_PHY_STATUS2  =  PP_PHY_STATUS2_RX_WMRK_IRQ;  // clear RX_WMRK_IRQ bit
  0004 6e104e   [4]             MOV   #16,78
  0007          L7:     
  644:      #ifdef PHY_ISR_HOOKS
  645:      PhyPlmeRxSfdDetect();
  646:      #endif //  PHY_ISR_HOOKS
  647:    }
  648:  }
  0007 8a       [3]             PULH  
  0008 80       [9]             RTI   
  649:  
  650:  /***********************************************************************************/
  651:  
  652:  #pragma CODE_SEG DEFAULT
  653:  
  654:  
