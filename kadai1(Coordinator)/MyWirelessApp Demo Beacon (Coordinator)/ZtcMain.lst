*** EVALUATION ***
ANSI-C/cC++ Compiler for HC08 V-5.0.41 Build 12319, Nov 15 2012

    1:  /******************************************************************************
    2:  * Implementation of the ZigBee Test Client.
    3:  * ZTC task public functions, and various internals.
    4:  *
    5:  * Copyright (c) 2008, Freescale, Inc.  All rights reserved.
    6:  *
    7:  *
    8:  * No part of this document must be reproduced in any form - including copied,
    9:  * transcribed, printed or by any electronic means - without specific written
   10:  * permission from Freescale Semiconductor.
   11:  *
   12:  ******************************************************************************/
   13:  
   14:  #include "EmbeddedTypes.h"
   15:  
   16:  #include "MsgSystem.h"
   17:  #include "FunctionLib.h"
   18:  #include "PublicConst.h"
   19:  #include "TS_Interface.h"
   20:  #include "NVM_Interface.h"
   21:  #include "NV_Flash.h"
   22:  #include "NV_FlashHAL.h"
   23:  #include "NV_Data.h"
   24:  
   25:  #include "PWRLib.h"
   26:  #include "PublicConst.h"
   27:  
   28:  #include "Uart_Interface.h"
   29:  
   30:  #include "ZtcInterface.h"
   31:  #include "ZtcPrivate.h"
   32:  #include "ZtcClientCommunication.h"
   33:  #include "ZtcMsgTypeInfo.h"
   34:  #include "ZtcSAPHandlerInfo.h"
   35:  #include "ZtcCopyData.h"
   36:  
   37:  #include "SPI_Interface.h"
   38:  #include "IIC_Interface.h"
   39:  
   40:  #include "ApplicationConf.h"
   41:  
   42:  #ifdef gZtcOtapSupport_d
   43:    #include "OtapSupport.h"
   44:    #include "Bootloader.h"
   45:    #include "Eeprom.h"
   46:  #endif
   47:  
   48:  #if gMacStandAlone_d
   49:  #include "Mac_Globals.h"
   50:  #endif
   51:  
   52:  #if (gLpmIncluded_d == 1)
   53:    #include "PWR_Interface.h"
   54:  #endif
   55:  
   56:  #ifndef PROCESSOR_MC1323X
   57:    #include "Phy.h"
   58:  #endif
   59:  
   60:  /******************************************************************************
   61:  *******************************************************************************
   62:  * Private type definitions
   63:  *******************************************************************************
   64:  ******************************************************************************/
   65:  
   66:  /* Format of the messages echanged between Ztc and the SAP Handlers.
   67:   *
   68:   * *warning* All of the SAP Handlers receive a sapHandlerMsg_t, containing a
   69:   * msgType.
   70:   * The AFDE -> APP and APP -> AFDE SAP Handler send back only raw data,
   71:   * without a msgType, to ZTC_TaskEventMonitor().
   72:   * All other SAP Handlers send back a sapHandlerMsg_t *with* a msgType.
   73:   */
   74:   
   75:  typedef struct sapHandlerMsgHdr_tag {
   76:    ztcMsgType_t msgType;
   77:  } sapHandlerMsgHdr_t;
   78:  
   79:  #ifndef gMAC2006_d
   80:   #define mSapHandlerMsgTotalLen_c    144
   81:   #define mMaxPacketSize_c            144
   82:  #else
   83:   #define mSapHandlerMsgTotalLen_c    155  // Security material added (securityLevel, keyIdMode, keySource, keyIndex)
   84:   #define mMaxPacketSize_c            155
   85:  #endif //gMAC2006_d
   86:  
   87:  typedef union sapHandlerMsg_tag {
   88:    uint8_t raw[mSapHandlerMsgTotalLen_c];
   89:    struct {
   90:      sapHandlerMsgHdr_t header;
   91:      uint8_t payload[mSapHandlerMsgTotalLen_c - sizeof(sapHandlerMsgHdr_t)];
   92:    } structured;
   93:  } sapHandlerMsg_t;
   94:  
   95:  /* Permissions Configuration Table. */
   96:  #if (gZtcIncluded_d && (gStandardSecurity_d || gHighSecurity_d) && gApsMaxEntriesForPermissionsTable_c)
   97:  typedef struct ztcPermissionsTable_tag {
   98:    index_t count;                                /* Number of entries in table. */
   99:    permissionsTable_t table[(sizeof(clientPacket_t) - sizeof(clientPacketHdr_t))
  100:                      / sizeof(permissionsTable_t)];     /* First entry of variable-length table. */
  101:  } ztcPermissionsTable_t;
  102:  #endif  /* (gZtcIncluded_d && (gStandardSecurity_d || gHighSecurity_d) && gApsMaxEntriesForPermissionsTable_c) */
  103:  
  104:  #ifndef PROCESSOR_MC1323X
  105:  typedef struct ztcAbelWrite_tag {
  106:    uint8_t  abelReg;
  107:    uint16_t value;
  108:  } ztcAbelWrite_t;
  109:  #endif /* PROCESSOR_MC1323X */
  110:  
  111:  /* a single fragment as seen by ZTC */
  112:  typedef struct apsdeFragment_tag {
  113:    uint8_t iBlockNumber;
  114:    uint8_t iMoreBlocks;
  115:    uint8_t iLength;
  116:    uint8_t aData[1];
  117:  } apsdeFragment_t;
  118:  
  119:  typedef struct ztcWakeUpConfig_tag
  120:  {
  121:   uint8_t selectedKBPin; /* Mask for selecting the pin */
  122:   uint8_t detectionEdge; /* The selected edge when MCU should wake up; 
  123:                             0x00 - wake up MCU on falling edges;
  124:                             0x01 - wake up MCU on rising edges */
  125:   bool_t  signalWhenWakeUpFlag; /* Flag used to send or not a WakeUp.Ind message */
  126:   uint8_t prevPinLevel; /* Keep track of previous pin level */
  127:  }ztcWakeUpConfig_t;
  128:  
  129:  /* Only KB4-KB7 can wake up the MCU on both (rising or falling) edges.
  130:     KB3-KB0 can only wake up the MCU on falling edges. */
  131:  #define mRisingEdgesPinsMask_c  0xF0
  132:  /* detectionEdge == 0x01, MCU is waking up on rising edges
  133:     detectionEdge == 0x00, MCU is waking up on falling edges */
  134:  #define mFallingEdges_c  0x00
  135:  #define mRisingEdges_c   0x01 
  136:  
  137:  
  138:  /******************************************************************************
  139:  *******************************************************************************
  140:  * Private prototypes
  141:  *******************************************************************************
  142:  ******************************************************************************/
  143:  
  144:  static void pktFromMsgAsync(uint8_t const *pMsgFromSAPHandler,
  145:                              ztcSAPHandlerInfo_t const *pSrcSAPInfo,
  146:                              ztcMsgTypeInfo_t const *pSrcMsgTypeInfo);
  147:  
  148:  static void pktFromMsgSync(uint8_t const *pMsgFromSAPHandler,
  149:                             ztcSAPHandlerInfo_t const *pSrcSAPInfo,
  150:                             ztcMsgTypeInfo_t const *pSrcMsgTypeInfo,
  151:                             uint8_t const srcStatus);
  152:  
  153:  static void ZtcReq_Handler(void);
  154:  
  155:  static void CheckZtcBufferStatus(void); 
  156:  
  157:  static void ZtcApsde_Handler(void);
  158:  
  159:  #if (gLpmIncluded_d == 1)
  160:  static void ZtcMsgWakeUpInd(void);
  161:  #endif /* #if gLpmIncluded_d */ 
  162:  
  163:  /******************************************************************************
  164:  *******************************************************************************
  165:  * Private memory declarations
  166:  *******************************************************************************
  167:  ******************************************************************************/
  168:  
  169:  /* fragmentation fields */
  170:  extern uint8_t giFragmentedPreAcked;
  171:  /* Variable to store the BlackBox configuration parameters */
  172:  extern const blackBoxCommConfig_t blackBoxCommConfig;
  173:  /* Used to recognize monitor copies of messages that Ztc sent to other code. */
  174:  #if gZtcIncluded_d
  175:  static bool_t mMsgOriginIsZtc;
  176:  extern uint8_t gZDOJoinMode;
  177:  #endif
  178:  
  179:  #if gZtcErrorReporting_d
  180:  /* Set to TRUE when ZtcError() is called. */
  181:  static bool_t mZtcErrorReported;
  182:  #endif
  183:  
  184:  
  185:  /******************************************************************************
  186:  *******************************************************************************
  187:  * Public memory definitions
  188:  *******************************************************************************
  189:  ******************************************************************************/
  190:  
  191:  /* The rest of BeeStack can set this pointer to allow handling of messages
  192:   * from the external client that have opcode groups not normally
  193:   * recognized by Ztc.
  194:   */
  195:  #if gZtcIncluded_d
  196:  gpfTestClientToApplication_t gpfTestClientToApplicationFuncPtr = NULL;
  197:  #endif
  198:  
  199:  #if gZtcIncluded_d
  200:  tsTaskID_t gZTCTaskID;
  201:  #endif
  202:  
  203:  extern char __SEG_START_SSTACK[];
  204:  extern char __SEG_END_SSTACK[];
  205:  extern char __SEG_END_NV_CODE_BUFFER[];
  206:  
  207:  /******************************************************************************
  208:  *******************************************************************************
  209:  * Public functions
  210:  *******************************************************************************
  211:  ******************************************************************************/
  212:  
  213:  #ifdef PROCESSOR_MC1323X   
  214:    extern  void MacPhyInit_WriteExtAddress(uint8_t *pExtendedAddress);
  215:  #endif //PROCESSOR_MC1323X   
  216:  /* Main routine for the ZTC task.
  217:   *
  218:   * Ztc only understands one event, which signals that the UART/SPI ISR has received
  219:   * an octet from a local communication port (e.g. serial port or USB).
  220:   *
  221:   * Note that no messages are ever sent to the Ztc task.
  222:   *
  223:   * The event flags are cleared by the kernel.
  224:   *
  225:   * Note that the ISR declares an event for every octet, so this routine is
  226:   * often called before there is enough of a packet received from the external
  227:   * client to process.
  228:   *
  229:   * Once a complete and well formed packet has arrived, copy to a SAP Handler
  230:   * message, with whatever changes are needed to the format of the data, and
  231:   * forward it to the SAP Handler.
  232:   *
  233:   * The SAP Handler will eventually call ZTC_TaskEventMonitor() to record the
  234:   * SAP Handler's receipt of a message.
  235:   */
  236:  void Ztc_Task(event_t events) {
  237:  #if !gZtcIncluded_d
  238:    (void) events;
  239:  #else
  240:    sapHandlerMsg_t *pMsgToSAPHandler;
  241:    ztcMsgTypeInfo_t const *pMsgTypeInfo;
  242:    ztcOpcodeGroup_t opcodeGroup;
  243:    ztcSAPHandlerInfo_t const *pSAPInfo;
  244:    ztcFmtInfo_t const *pFmtInfo;
  245:    index_t dstDataLen;
  246:    pZtcMsgFromPkt_t pCopyFunc;
  247:    uint8_t status;
  248:  
  249:    (void) events;
  250:  
  251:    /* Do we have a complete packet? */
  252:    if (!ZtcReadPacketFromClient()) {
  253:      CheckZtcBufferStatus();
  254:      return;
  255:    }
  256:  
  257:  #if gZtcErrorReporting_d
  258:    mZtcErrorReported = FALSE;
  259:  #endif
  260:  
  261:    opcodeGroup = gZtcPacketFromClient.structured.header.opcodeGroup;
  262:  
  263:    /* *warning* ZtcReq_Handler() depends on it's input data being in the */
  264:    /* global gZtcPacketFromClient, and it modifies gZtcPacketToClient. */
  265:    if (opcodeGroup == gZtcReqOpcodeGroup_c) {
  266:      ZtcReq_Handler();
  267:      CheckZtcBufferStatus();
  268:      return;
  269:    }
  270:  
  271:    /* special fragmented APSDE commands */
  272:  #if (gFragmentationCapability_d)
  273:    if (opcodeGroup == gAfApsdeOpcodeGroup_c && 
  274:        gZtcPacketFromClient.structured.header.msgType != gApsdeDataReqMsgType_d)
  275:    {
  276:      ZtcApsde_Handler();
  277:      CheckZtcBufferStatus();
  278:      return;
  279:    }
  280:  #endif
  281:  
  282:    pSAPInfo = pZtcSAPInfoFromOpcodeGroup(opcodeGroup);
  283:  
  284:    /* If this is a recognized opcode group, but one which has been disabled */
  285:    /* by an option setting, let the user know. Otherwise, Test Tool users */
  286:    /* may wonder why they are not getting any responses to valid requests. */
  287:  #if gZtcErrorReporting_d
  288:    if (pSAPInfo == gZtcIsDisabledOpcodeGroup_c) {
  289:      ZtcError(gZtcOpcodeGroupIsDisabled_c);
  290:      CheckZtcBufferStatus();
  291:      return;
  292:    }
  293:  #endif
  294:  
  295:    /* If the opcode group is not familiar, call a general purpose hook. */
  296:    if (!pSAPInfo) {
  297:      if (gpfTestClientToApplicationFuncPtr) {
  298:        (*gpfTestClientToApplicationFuncPtr)((void *) gZtcPacketFromClient.raw);
  299:      } else {
  300:        ZtcError(gZtcUnknownOpcodeGroup_c);
  301:      }
  302:      CheckZtcBufferStatus();
  303:      return;
  304:    }
  305:  
  306:    /* The client has sent a well formed packet, with a known opcode group. */
  307:    pMsgTypeInfo = pZtcMsgTypeInfoFromMsgType(pSAPInfo->pMsgTypeTable,
  308:                                              *(pSAPInfo->pMsgTypeTableLen),
  309:                                              gZtcPacketFromClient.structured.header.msgType);
  310:    if (!pMsgTypeInfo) {
  311:      ZtcError(gZtcUnknownOpcode_c);
  312:      CheckZtcBufferStatus();
  313:      return;
  314:    }
  315:  
  316:    /* The size of the destination message isn't known yet, so allocate */
  317:    /* a large message. */
  318:    pMsgToSAPHandler = (sapHandlerMsg_t *) MSG_Alloc(sizeof(sapHandlerMsg_t));
  319:  
  320:    if (!pMsgToSAPHandler) {
  321:      ZtcError(gZtcOutOfMessages_c);
  322:      CheckZtcBufferStatus();
  323:      return;
  324:    }
  325:  
  326:    /* Copy the content of the packet to the SAP Handler message, changing */
  327:    /* formats as necessary. */
  328:    pFmtInfo = &(maZtcFmtInfoTable[ZtcMsgGetFmt(pMsgTypeInfo->flagAndFormat)]);
  329:    pCopyFunc = maMsgFromPktFunctionTable[ZtcGetMsgFromPktFuncIndex(pFmtInfo->copyFunctionIndexes)];
  330:  
  331:    dstDataLen = (*pCopyFunc)(pMsgToSAPHandler->structured.payload,
  332:                              sizeof(pMsgToSAPHandler->structured.payload),
  333:                              gZtcPacketFromClient.structured.payload,
  334:                              gZtcPacketFromClient.structured.header.len,
  335:                              pFmtInfo->msgFromPktParametersIndex);
  336:  
  337:    if (dstDataLen == gTooBig_c) {
  338:      MSG_Free(pMsgToSAPHandler);
  339:      ZtcError(gZtcTooBig_c);
  340:      CheckZtcBufferStatus();
  341:      return;
  342:    }
  343:  
  344:    /* mMsgOriginIsZtc lets ZTC_TaskEventMonitor() know that this message */
  345:    /* originated with Ztc. */
  346:    pMsgToSAPHandler->structured.header.msgType = gZtcPacketFromClient.structured.header.msgType;
  347:    mMsgOriginIsZtc = TRUE;
  348:    status = (pSAPInfo->pSAPHandler)(pMsgToSAPHandler);
  349:    mMsgOriginIsZtc = FALSE;
  350:  
  351:    /* SAP Handlers don't free buffers that contain synchronous messages. */
  352:    if (ZtcMsgGetFlg(pMsgTypeInfo->flagAndFormat) == gZtcMsgFlagSync_c) {
  353:      #if gSAPMessagesEnableMlme_d
  354:        /* For a MLME.Reset request synchronous message, the memory pool is re-initiated and
  355:           all allocated messages are deallocated. Because of this, we don't need 
  356:           to free the allocated message. */
  357:        if ((opcodeGroup != gNwkMlmeOpcodeGroup_c)||(pMsgTypeInfo->msgType != gMlmeResetReq_c)) {
  358:      #endif
  359:          MSG_Free(pMsgToSAPHandler);
  360:      #if gSAPMessagesEnableMlme_d
  361:        }
  362:      #endif
  363:    } else if (status != gZbSuccess_c) {
  364:      /* This is an async message, and the SAP Handler is unhappy. Synthesize */
  365:      /* a confirmation message containing the status, and send it back to the */
  366:      /* external client. This is the SAP Handler's issue, not a ZtcError(). */
  367:      
  368:      ZTCQueue_QueueToTestClient(&status, pSAPInfo->converseOpcodeGroup, pMsgTypeInfo->cnfType, sizeof(status));
  369:    }
  370:    CheckZtcBufferStatus();
  371:  #endif                                  /* #if !gZtcIncluded_d #else */
  372:  }                                       /* Ztc_Task() */
  0000 8d       [7]             RTC   
  373:  
  374:  /****************************************************************************/
  375:  
  376:  /* Initialization routine for the ZTC task. Called once by the kernel at */
  377:  /* startup. */
  378:  #if gZtcIncluded_d
  379:  void ZtcRxCallBack(void) {
  380:    SendEventToZTC();
  381:  }
  382:  #endif
  383:  
  384:  void Ztc_TaskInit(void) {
  385:  #if gZtcIncluded_d
  386:    
  387:    #if defined(gSPIInterface_d)
  388:    
  389:      spiConfig_t mSpiConfig;
  390:         
  391:      /* Initialize the SPI module */
  392:      SPI_Init();
  393:      
  394:      /* Prepare the SPI module in slave mode */
  395:  	  /* SPI_SCI bridge has the same configuration in master mode*/
  396:      mSpiConfig.devMode      = gSPI_SlaveMode_c;
  397:      mSpiConfig.baudRate     = blackBoxCommConfig.spiBaudRate;
  398:      mSpiConfig.clockPol     = gSPI_ActiveHighPolarity_c;
  399:      mSpiConfig.clockPhase   = gSPI_EvenEdgeShifting_c;
  400:      mSpiConfig.bitwiseShift = gSPI_MsbFirst_c;
  401:      mSpiConfig.s3Wire       = gSPI_FullDuplex_c;
  402:      
  403:      /* Apply configuration to the SPI module */
  404:      SPI_SetConfig(mSpiConfig);
  405:  	
  406:  	  /* Set call back */  
  407:      SPI_SetSlaveRxCallBack(ZtcRxCallBack);
  408:           
  409:    #elif defined(gIICInterface_d)
  410:    
  411:      IIC_ModuleInit();
  412:      
  413:      (void)IIC_SetBaudRate(blackBoxCommConfig.iicBaudRate);
  414:      
  415:      (void)IIC_SetSlaveAddress(blackBoxCommConfig.iicSlaveAddress);
  416:      
  417:      IIC_SetSlaveRxCallBack(ZtcRxCallBack);
  418:     
  419:    #else
  420:    
  421:      UartX_SetBaud(blackBoxCommConfig.uartBaudRate);
  422:      
  423:      UartX_SetRxCallBack(ZtcRxCallBack);
  424:      
  425:    #endif
  426:  
  427:    gZTCTaskID = TS_CreateTask(gTsZTCTaskPriority_c, Ztc_Task);
  428:  #endif
  429:  }                                       /* Ztc_TaskInit() */
  0000 8d       [7]             RTC   
  430:  
  431:  /****************************************************************************/
  432:  
  433:  /* Send an arbitrary event from an application to the external client. The
  434:   * data, opcode group and message type can be anything.
  435:   */
  436:  void ZTCQueue_QueueToTestClient
  437:    (
  438:    uint8_t const *const pData,
  439:    uint8_t const opcodeGroup,
  440:    uint8_t const msgType,
  441:    uint8_t const dataLen
  442:    )
  443:  {
  444:  #if !gZtcIncluded_d
  445:    (void) pData;
  446:    (void) opcodeGroup;
  447:    (void) msgType;
  448:    (void) dataLen;
  449:  #else
  450:  
  451:  #if gZtcErrorReporting_d
  452:    mZtcErrorReported = FALSE;
  453:  #endif
  454:  
  455:    if (dataLen > sizeof(gZtcPacketToClient.structured.payload)) {
  456:      ZtcError(gZtcAppMsgTooBig_c);
  457:      return;
  458:    }
  459:  
  460:    if (mZtcPacketToClientIsBusy) {
  461:      return;
  462:    }
  463:  
  464:    gZtcPacketToClient.structured.header.opcodeGroup = opcodeGroup;
  465:    gZtcPacketToClient.structured.header.msgType = msgType;
  466:    gZtcPacketToClient.structured.header.len = dataLen;
  467:  
  468:    FLib_MemCpy(gZtcPacketToClient.structured.payload, (void *) pData, dataLen);
  469:    ZtcWritePacketToClient(sizeof(gZtcPacketToClient.structured.header) + dataLen);
  470:  #endif                                  /* #if !gZtcIncluded_d #else */
  471:  }                                       /* ZTCQueue_QueueToTestClient() */
  0000 8d       [7]             RTC   
  472:  
  473:  /****************************************************************************/
  474:  
  475:  /* Called by other functions in BeeStack, generally SAP Handlers.
  476:   * A message is passing through the SAP Handler, and it is letting us know.
  477:   * A SAP Handler can receive a message from a BeeStack layer, or from Ztc.
  478:   * The SAP Handler doesn't know the origin, and calls this function
  479:   * regardless.
  480:   *
  481:   * If the message is async and it was sent to the SAP Handler by Ztc,
  482:   * ignore it.
  483:   *
  484:   * If the message is async and it was not sent to the SAP Handler by Ztc,
  485:   * forward a copy to the external client.
  486:   *
  487:   * Sync messages are always responses to requests. The origin of the request
  488:   * (Ztc or other BeeStack code) does not matter; this routine will only see
  489:   * the response, not the request.
  490:   * Alter the opcode group to make the message look like it is coming from
  491:   * the converse of the SAP Handler that actually sent it here, and change
  492:   * the message type to the type of the corresponding response. Forward the
  493:   * edited message to the external client.
  494:   *
  495:   * Note that the message from the SAP Handler is sent to the external client
  496:   * directly from here, eliminating the need for logic to queue more than
  497:   * one packet.
  498:   */
  499:  void ZTC_TaskEventMonitor
  500:    (
  501:    ztcIntSAPId_t const srcIntSAPId,
  502:    uint8_t *pMsgFromSAPHandler,
  503:    clientPacketStatus_t const srcStatus
  504:    )
  505:  {
  506:  #if (!gZtcIncluded_d || defined(gZtcOtapSupport_d))
  507:    (void) srcIntSAPId;
  508:    (void) pMsgFromSAPHandler;
  509:    (void) srcStatus;
  510:  #else
  511:    ztcMsgTypeInfo_t const *pSrcMsgTypeInfo;
  512:    ztcSAPHandlerInfo_t const *pSrcSAPInfo;
  513:  
  514:  #if gZtcErrorReporting_d
  515:    /* Sync messages might be originated by Ztc_Task(), which already set this */
  516:    /* once. Setting it again here could lead to reporting two errors. Since */
  517:    /* are likely to be errors in different contexts, this isn't generally a */
  518:    /* problem. */
  519:    mZtcErrorReported = FALSE;
  520:  #endif
  521:  
  522:    pSrcSAPInfo = pZtcSAPInfoFromIntSAPId(srcIntSAPId);
  523:    if (!pSrcSAPInfo) {
  524:      /* Calling ZtcError() here might just annoy the user, repeatedly */
  525:      /* sending an error message about something they already know. */
  526:      return;
  527:    }
  528:  
  529:    ZtcPrint(FALSE, &srcStatus, sizeof(srcStatus));
  530:    ZtcPrint(FALSE, &pMsgFromSAPHandler, sizeof(pMsgFromSAPHandler));
  531:    ZtcPrint(FALSE, &pSrcSAPInfo->opcodeGroup, sizeof(pSrcSAPInfo->opcodeGroup));
  532:    ZtcPrint(TRUE,  pMsgFromSAPHandler, 32);
  533:  
  534:    if (maZtcSAPModeTable[pSrcSAPInfo->modeIndex] == gZtcSAPModeDisable_c) {
  535:      return;
  536:    }
  537:  
  538:    pSrcMsgTypeInfo = pZtcMsgTypeInfoFromMsgType(pSrcSAPInfo->pMsgTypeTable,
  539:                                                 *pSrcSAPInfo->pMsgTypeTableLen,
  540:                                                 ((sapHandlerMsg_t *) pMsgFromSAPHandler)->structured.header.msgType);
  541:    if (!pSrcMsgTypeInfo) {
  542:      /* Calling ZtcError() here might just annoy the user, repeatedly */
  543:      /* sending an error message about something they already know. */
  544:      return;
  545:    }
  546:  
  547:    if (mZtcPacketToClientIsBusy) {
  548:      return;
  549:    }
  550:  
  551:    if (ZtcMsgGetFlg(pSrcMsgTypeInfo->flagAndFormat) == gZtcMsgFlagAsync_c) {
  552:      pktFromMsgAsync(pMsgFromSAPHandler, pSrcSAPInfo, pSrcMsgTypeInfo);
  553:    } else {
  554:      pktFromMsgSync(pMsgFromSAPHandler, pSrcSAPInfo, pSrcMsgTypeInfo, srcStatus);
  555:    }
  556:  #endif  /* #if !gZtcIncluded_d #else */
  557:  }  /* ZTC_TaskEventMonitor() */
  0000 8d       [7]             RTC   
  558:  
  559:  /****************************************************************************/
  560:  
  561:  #if gZtcIncluded_d
  562:  void pktFromMsgAsync
  563:  (
  564:  	uint8_t const *pMsgFromSAPHandler,
  565:  	ztcSAPHandlerInfo_t const *pSrcSAPInfo,
  566:  	ztcMsgTypeInfo_t const *pSrcMsgTypeInfo
  567:  )
  568:  {
  569:  	index_t dstDataLen;
  570:  	pZtcPktFromMsg_t pCopyFunc;
  571:  	ztcFmtInfo_t const *pFmtInfo;
  572:  	nwkMessage_t *pMsg=NULL; /* MAC Confirm/Indication data type */
  573:  
  574:  	/* If this message is originated in Ztc, ignore it. */
  575:  	if (mMsgOriginIsZtc)
  576:  		return;
  577:  
  578:   	(void)pMsg; /* Set stub the pointer used for the Queue */
  579:    	pFmtInfo = &(maZtcFmtInfoTable[ZtcMsgGetFmt(pSrcMsgTypeInfo->flagAndFormat)]);
  580:  	  pCopyFunc = maPktFromMsgFunctionTable[ZtcGetPktFromMsgFuncIndex(pFmtInfo->copyFunctionIndexes)];
  581:  
  582:  	  /* Copy the payload from the message to the client packet. */
  583:  	  dstDataLen = (*pCopyFunc)(gZtcPacketToClient.structured.payload,
  584:  		  												sizeof(gZtcPacketToClient.structured.payload),
  585:  			  											((sapHandlerMsg_t *) pMsgFromSAPHandler)->structured.payload,
  586:  				  										pSrcMsgTypeInfo->len,
  587:  					  									pFmtInfo->pktFromMsgParametersIndex);  
  588:  
  589:  	/* If the SAP Handler that sent the message here is in hook mode, dequeue */
  590:  	/* the message and clear the event to prevent the message from reaching the */
  591:  	/* destination SAP Handler. */
  592:  	if (maZtcSAPModeTable[pSrcSAPInfo->modeIndex] == gZtcSAPModeHook_c)
  593:  	{
  594:  		if (pSrcSAPInfo->pMsgQueue)
  595:  		{
  596:  			/* If there is a Message in the Queue, then pint to it */
  597:  			pMsg = MSG_DeQueue(pSrcSAPInfo->pMsgQueue);
  598:   
  599:  			/* The MAC Layer has some exceptions in some message that need to free some internal memory */
  600:  			if (pSrcSAPInfo->opcodeGroup == gMlmeNwkOpcodeGroup_c) /* If the message came from MAC layer */
  601:  			{
  602:  				if (pSrcMsgTypeInfo->msgType == gNwkScanCnf_c) /* If the messaage is a ScanRequest */
  603:  				{
  604:  					if (pMsg->msgData.scanCnf.resList.pPanDescriptorBlocks->descriptorList) /* If the internal list of the scan has somem data or point to some place */
  605:  						/* Free the internal list comming in the the Scan from the MAC (second block) */
  606:  						if(pMsg->msgData.scanCnf.resList.pPanDescriptorBlocks->pNext)
  607:  						  MSG_Free(pMsg->msgData.scanCnf.resList.pPanDescriptorBlocks->pNext);
  608:  						/* Free the internal list comming in the the Scan from the MAC (first block) */
  609:  						MSG_Free(pMsg->msgData.scanCnf.resList.pPanDescriptorBlocks);
  610:  				}
  611:  				if (pSrcMsgTypeInfo->msgType == gNwkBeaconNotifyInd_c) /* If The messge is a Beacon Notify Indiction it has  messge allocated inside the message already allocted */
  612:  				{
  613:  					if (pMsg->msgData.beaconNotifyInd.pBufferRoot)
  614:  						MSG_Free(pMsg->msgData.beaconNotifyInd.pBufferRoot);
  615:  				}
  616:  			}
  617:  		}
  618:  
  619:  		if (pSrcSAPInfo->pTaskID[0]) /* Take the message out of the Queue for no further processing */
  620:  		{
  621:  			TS_ClearEvent(pSrcSAPInfo->pTaskID[0], pSrcSAPInfo->msgEvent);
  622:  		}
  623:  	}
  624:  
  625:  	if (dstDataLen == gTooBig_c)
  626:  	{
  627:  		ZtcError(gZtcTooBig_c);
  628:  		return;
  629:  	}
  630:  
  631:  	gZtcPacketToClient.structured.header.opcodeGroup = pSrcSAPInfo->opcodeGroup;
  632:  	gZtcPacketToClient.structured.header.msgType = ((sapHandlerMsg_t *) pMsgFromSAPHandler)->structured.header.msgType;
  633:  	gZtcPacketToClient.structured.header.len = dstDataLen;
  634:  
  635:  	ZtcWritePacketToClient(sizeof(gZtcPacketToClient.structured.header) + dstDataLen);
  636:  	if (pMsg && (maZtcSAPModeTable[pSrcSAPInfo->modeIndex] == gZtcSAPModeHook_c))
  637:  		MSG_Free(pMsg); /* Free the whole message comming from the Queue */
  638:  }  /* pktFromMsgAsync() */
  639:  #endif
  640:  
  641:  /****************************************************************************/
  642:  
  643:  /* Handle a synchronous message from a SAP Handler.
  644:   * Sync messages are always requests. Translate this message into the
  645:   * corresponding response.
  646:   *
  647:   * By convention, the request message type info contains the format
  648:   * information.
  649:   */
  650:  #if gZtcIncluded_d
  651:  void pktFromMsgSync
  652:  (
  653:  	uint8_t const *pMsgFromSAPHandler,
  654:  	ztcSAPHandlerInfo_t const *pSrcSAPInfo,
  655:  	ztcMsgTypeInfo_t const *pSrcMsgTypeInfo,
  656:  	uint8_t const srcStatus
  657:  )
  658:  {
  659:  	index_t dstDataLen;
  660:  	pZtcPktFromMsg_t pCopyFunc;
  661:  	ztcFmtInfo_t const *pFmtInfo;
  662:  	uint8_t *pSrcData;
  663:  
  664:  	/* For sync messages, a status code was passed here as a parameter, */
  665:  	/* and must be stored in the first byte of the packet payload. */
  666:  	gZtcPacketToClient.structured.payload[0] = srcStatus;
  667:  	pSrcData = ((sapHandlerMsg_t *) pMsgFromSAPHandler)->structured.payload;
  668:  
  669:  	pFmtInfo = &(maZtcFmtInfoTable[ZtcMsgGetFmt(pSrcMsgTypeInfo->flagAndFormat)]);
  670:  	pCopyFunc = maPktFromMsgFunctionTable[ZtcGetPktFromMsgFuncIndex(pFmtInfo->copyFunctionIndexes)];
  671:  
  672:  	/* Copy the payload from the message to the client packet. */
  673:  	dstDataLen = (*pCopyFunc)(&gZtcPacketToClient.structured.payload[sizeof(clientPacketStatus_t)],
  674:  														sizeof(gZtcPacketToClient.structured.payload) - sizeof(clientPacketStatus_t),
  675:  														pSrcData,
  676:  														pSrcMsgTypeInfo->len,
  677:  														pFmtInfo->pktFromMsgParametersIndex);
  678:  
  679:  	if (dstDataLen == gTooBig_c)
  680:  	{
  681:  		ZtcError(gZtcTooBig_c);
  682:  		return;
  683:  	}
  684:  
  685:  	gZtcPacketToClient.structured.header.opcodeGroup = pSrcSAPInfo->converseOpcodeGroup;
  686:  	gZtcPacketToClient.structured.header.msgType = pSrcMsgTypeInfo->cnfType;
  687:  	gZtcPacketToClient.structured.header.len = dstDataLen + sizeof(clientPacketStatus_t);
  688:  
  689:  	ZtcWritePacketToClient(dstDataLen
  690:  												+ sizeof(gZtcPacketToClient.structured.header)
  691:  												+ sizeof(clientPacketStatus_t));
  692:  }  /* pktFromMsgSync() */
  693:  #endif
  694:  
  695:  /******************************************************************************
  696:  *******************************************************************************
  697:  * Private functions
  698:  *******************************************************************************
  699:  ******************************************************************************/
  700:  /****************************************************************************
  701:  This function checks if there is any bytes in the uart/spi buffer, and 
  702:  if there is any left, the ZTC task is signaled.
  703:  ****************************************************************************/
  704:  #if gZtcIncluded_d
  705:  static void CheckZtcBufferStatus(void) {
  706:    
  707:    #if defined(gSPIInterface_d)
  708:      if (mSpiRxBufferByteCount != 0)
  709:    #elif defined(gIICInterface_d)
  710:      if (mIIcRxBufferByteCount != 0)
  711:    #else
  712:      if (UartX_RxBufferByteCount != 0)
  713:    #endif
  714:    
  715:    {  
  716:      SendEventToZTC();    
  717:    }
  718:  }
  719:  #endif 
  720:  
  721:  /* Send an error message back to the external client. */
  722:  #if gZtcErrorReporting_d
  723:  void ZtcError(uint8_t errorCode)
  724:  {
  725:    uint8_t buf[MbrSizeof(clientPacket_t, headerAndStatus)];
  726:  
  727:    if (mZtcErrorReported)
  728:      return;                             /* Don't cascade error messages. */
  729:  
  730:  
  731:    ((clientPacket_t *) buf)->headerAndStatus.header.opcodeGroup = gZtcCnfOpcodeGroup_c;
  732:    ((clientPacket_t *) buf)->headerAndStatus.header.msgType = mZtcMsgError_c;
  733:    ((clientPacket_t *) buf)->headerAndStatus.header.len = sizeof(((clientPacket_t *) buf)->headerAndStatus.status);
  734:    ((clientPacket_t *) buf)->headerAndStatus.status = errorCode;
  735:  
  736:    ZtcTransmitBufferBlock(buf, sizeof(buf));
  737:    mZtcErrorReported = TRUE;
  738:  }
  739:  #endif                                  /* #if gZtcErrorReporting_d */
  740:  
  741:  /****************************************************************************/
  742:  
  743:  /* Ztc's version of printf() debugging.
  744:   *
  745:   * To save RAM, use a dynamically allocated message buffer to construct
  746:   * the message. If no buffer is available, send an error buffer and give up.
  747:   *
  748:   * Write as much of the requested data as possible to the buffer, but there
  749:   * is no guarantee there the buffer will be big enough.
  750:   *
  751:   * Concatenate the source data to the print buffer, then
  752:   *  If readyToSend is false, do nothing.
  753:   *  If readyToSend is true,  send the buffer to the external client.
  754:   */
  755:  #if gZtcDebug_d
  756:  void ZtcPrint
  757:    (
  758:    bool_t readyToSend,
  759:    void const *pSrc,
  760:    index_t len
  761:    )
  762:  {
  763:    static index_t bufLen = 0;
  764:    static index_t dataInBuf = 0;
  765:    static uint8_t *pBuf = NULL;
  766:  
  767:    /* Search for a valid and available message buffer size, instead of */
  768:    /* depending on knowing the possible buffer sizes. */
  769:  #define ztcPrintDecrement       8       /* Ensure decrementing to zero. */
  770:  #define ztcPrintNumberOfTries   8
  771:    if (!bufLen) {
  772:      for (pBuf = 0, bufLen = ztcPrintDecrement * ztcPrintNumberOfTries;
  773:           !pBuf && bufLen;
  774:           bufLen -= ztcPrintDecrement) {
  775:        pBuf = MSG_Alloc(bufLen);
  776:        dataInBuf = sizeof(clientPacketHdr_t);
  777:      }
  778:  
  779:      if (!bufLen) {
  780:        ZtcError(gZtcDebugPrintFailed_c);
  781:        return;
  782:      }
  783:    }
  784:  
  785:    /* Concatenate the source data to the print buffer, if there's room. */
  786:    if (dataInBuf + len < bufLen) {
  787:      FLib_MemCpy(pBuf + dataInBuf, pSrc, len);
  788:      dataInBuf += len;
  789:    }
  790:  
  791:    if (readyToSend) {
  792:      ((clientPacketHdr_t *) pBuf)->opcodeGroup = gZtcCnfOpcodeGroup_c;
  793:      ((clientPacketHdr_t *) pBuf)->msgType = mZtcMsgDebugPrint_c;
  794:      ((clientPacketHdr_t *) pBuf)->len = dataInBuf - sizeof(clientPacketHdr_t);
  795:      ZtcTransmitBufferBlock(pBuf, dataInBuf);
  796:      MSG_Free(pBuf);
  797:      bufLen = 0;
  798:    }
  799:  }
  800:  #endif                                  /* #if gZtcDebug_d */
  801:  
  802:  
  803:  /*
  804:    Called from both AF_APSDE_SapHandler() and APSDE_AF_SapHandler(), this function will 
  805:    display all fragmented blocks to ZTC if both fragmentation and ZTC are enabled. 
  806:  */
  807:  void ZTC_FragEventMonitor
  808:    (
  809:    ztcIntSAPId_t const srcIntSAPId,
  810:    uint8_t *pMsgFromSAPHandler
  811:    )
  812:  {
  813:  #if (!gZtcIncluded_d)
  814:    /* avoid compiler warning on unused parameters */
  815:    (void)srcIntSAPId;
  816:    (void)pMsgFromSAPHandler;
  817:  
  818:  /* ZTC is included */
  819:  #else
  820:  
  821:   #if (gFragmentationCapability_d)
  822:    zbTxFragmentedHdr_t *pFragHdr;
  823:    apsdeFragment_t sZtcFragment;
  824:    uint8_t *pData;
  825:    uint8_t msgType;
  826:    uint8_t dataSize;
  827:    uint8_t opCodeGroup;
  828:    uint8_t iBlockNumber;
  829:   #endif
  830:  
  831:    /* first, send the main message to ZTC */
  832:    ZTC_TaskEventMonitor(srcIntSAPId, (uint8_t *) pMsgFromSAPHandler, gZbSuccess_c);
  833:  
  834:   #if (gFragmentationCapability_d)
  835:  
  836:    /* find fragHdr for this message */
  837:    /* the message will either come from the gAF_APSDE_SAPHandlerId_c or the gAPSDE_AF_SAPHandlerId_c */
  838:    /* note: this code assumes both zbTxFragmentedHdr_t and zbRxFragmentedHdr_t begin with same 2 fields */
  839:    msgType = *pMsgFromSAPHandler;
  840:    if(srcIntSAPId == gAF_APSDE_SAPHandlerId_c)
  841:    {
  842:      /* make sure message is a data request */
  843:      if(msgType != gApsdeDataReqMsgType_d)
  844:        return;
  845:  
  846:      /* find first fragment header */
  847:      pFragHdr = &(((afToApsdeMessage_t *)pMsgFromSAPHandler)->msgData.dataReq.fragmentHdr);
  848:      opCodeGroup = 0x9c;
  849:    }
  850:  
  851:    /* assumes srcIntSAPId == gAPSDE_AF_SAPHandlerId_c */
  852:    else
  853:    {
  854:      /* make sure message is a data indication */
  855:      if(msgType != gApsdeDataIndMsgType_d)
  856:        return;
  857:  
  858:      /* find first fragment header */
  859:      pFragHdr = (zbTxFragmentedHdr_t *)(&(((apsdeToAfMessage_t *)pMsgFromSAPHandler)->msgData.dataIndication.fragmentHdr));
  860:      opCodeGroup = 0x9d;
  861:    }
  862:  
  863:    /* skip first block (with dataReq or dataInd), as that's already been sent to ZTC */
  864:    pFragHdr = pFragHdr->pNextDataBlock;
  865:  
  866:    /* send all subsequent blocks to ZTC */
  867:    iBlockNumber = 1;
  868:    while(pFragHdr)
  869:    {
  870:      /* copy data into ZTC Tx buffer */
  871:      dataSize = pFragHdr->iDataSize;
  872:      gZtcPacketToClient.structured.header.opcodeGroup = opCodeGroup;
  873:      gZtcPacketToClient.structured.header.msgType = pFragHdr->iMsgType;
  874:      gZtcPacketToClient.structured.header.len = (sizeof(apsdeFragment_t) - 1) + dataSize;
  875:      sZtcFragment.iLength = dataSize;
  876:      sZtcFragment.iBlockNumber = iBlockNumber++;
  877:      sZtcFragment.iMoreBlocks = pFragHdr->pNextDataBlock ? TRUE : FALSE;
  878:      gZtcPacketToClient.structured.payload[0] = dataSize;
  879:      if(srcIntSAPId == gAF_APSDE_SAPHandlerId_c)
  880:        pData = (uint8_t *)(pFragHdr + 1);    /* on Tx, data immediately follows TxFragHdr */
  881:      else
  882:        pData = ((zbRxFragmentedHdr_t *)pFragHdr)->pData; /* on Rx, it's pointed to by RxFragHdr */
  883:      FLib_MemCpy(gZtcPacketToClient.structured.payload, &sZtcFragment, sizeof(apsdeFragment_t) - 1);
  884:      FLib_MemCpy(&gZtcPacketToClient.structured.payload[sizeof(apsdeFragment_t) - 1], pData, dataSize);
  885:  
  886:      /* send through ZTC */
  887:  	  ZtcWritePacketToClient(sizeof(gZtcPacketToClient.structured.header) + 
  888:  	    (sizeof(apsdeFragment_t) - 1) + dataSize);
  889:  
  890:      /* go on to next block */
  891:      pFragHdr = pFragHdr->pNextDataBlock;
  892:    }
  893:   #endif /* gFragmentationCapability_d */
  894:  #endif  /* gZtcIncluded_d */
  895:  }
  0000 8d       [7]             RTC   
  896:  
  897:  #if (gZtcIncluded_d && gFragmentationCapability_d)
  898:  
  899:  /* for loading fragments prior to a data request */
  900:  static zbTxFragmentedHdr_t *mpFragHead;  /* if NULL, then no fragments loaded */
  901:  
  902:  /*
  903:    For handling the "special" APSDE commands for fragmentation. These do not go to the SAP 
  904:    handler.
  905:  
  906:    ResetFragments   Free any memory allocated by LoadFragment. Only required if aborting a
  907:                     Data request, or if
  908:    LoadFragment     Load a fragment into memory through the ZTC interface.
  909:    SetFragAckMask   Used for passing ZCP tests. Pretend a packet has already been ACKed so
  910:                     it's not sent first time.
  911:      
  912:    Normal sequence for initiating an APSDE-DATA.request over ZTC is:
  913:    1. Call LoadFragment (for all fragments but the first one. These fragments may be any length, 
  914:       but should be the max size that will fit in a message (128 bytes) 
  915:    2. Call APSDE-DATA.request for the first fragment. AsduLen should be the length of the first
  916:       fragment only. ZTC will add the total size of all fragments.
  917:  
  918:    Note: the above sequence is different than from an application. The AF_DataRequestFragmented()
  919:    and AF_DataRequestFragmentedNoCopy() should be called instead.
  920:  
  921:    Note: ZtcApsde_Handler() receives data in the global gZtcPacketFromClient, and modifies 
  922:    gZtcPacketToClient.
  923:  */
  924:  static void ZtcApsde_Handler(void)
  925:  {
  926:  
  927:    /* these commands do not actually go through the SAP, but are valid only in ZTC */
  928:    #define gZtcMsgTypeResetFragments_c       0x10
  929:    #define gZtcMsgTypeLoadFragment_c         0x11
  930:    #define gZtcMsgTypeSetFragAckMask_c       0x12
  931:    #define gZtcMsgTypeSetMaxFragmentLength_c 0x13
  932:    #define gZtcMsgTypeSetWindowSize_c        0x14
  933:    #define gZtcMsgTypeSetInterframeDelay_c   0x15
  934:  
  935:    zbTxFragmentedHdr_t *pFragBlock;    /* allocated message */
  936:    zbTxFragmentedHdr_t *pFragNext;     /* next fragmented buffer */
  937:    uint8_t fragLen;
  938:    ztcMsgType_t msgType;
  939:    clientPacketStatus_t ztcError = gZtcSuccess_c;
  940:  
  941:    msgType = gZtcPacketFromClient.structured.header.msgType;
  942:    switch(msgType)
  943:    {
  944:      /* ResetFragments command. Will free any memory allocated with LoadFragment command. */
  945:      case gZtcMsgTypeResetFragments_c:
  946:  
  947:        /* free every buffer in the linked list */
  948:        while(mpFragHead)
  949:        {
  950:          pFragNext = mpFragHead->pNextDataBlock;
  951:          MSG_Free(mpFragHead);
  952:          mpFragHead = pFragNext;
  953:        }
  954:        /* note: mpFragHead will end up NULL */
  955:      break;
  956:  
  957:      /* LoadFragment command */
  958:      case gZtcMsgTypeLoadFragment_c:
  959:  
  960:        /* allocate a message buffer for the fragment */
  961:        fragLen = gZtcPacketFromClient.structured.header.len - 1;
  962:        pFragBlock = MSG_Alloc(sizeof(zbTxFragmentedHdr_t) + fragLen);
  963:        if(!pFragBlock)
  964:        {
  965:          ztcError = gZtcOutOfMessages_c;
  966:          break;
  967:        }
  968:  
  969:        /* find tail, and link in allocated buffer at end */
  970:        if(!mpFragHead)
  971:          mpFragHead = pFragBlock;
  972:        else
  973:        {
  974:          /* find tail */
  975:          pFragNext = mpFragHead;
  976:          while(pFragNext->pNextDataBlock)
  977:            pFragNext = pFragNext->pNextDataBlock;
  978:          pFragNext->pNextDataBlock = pFragBlock;
  979:        }
  980:  
  981:        /* set up allocated buffer */
  982:        pFragBlock->iDataSize = fragLen;
  983:        pFragBlock->iMsgType = gApsdeDataReqFragMsgType_d;
  984:        pFragBlock->pNextDataBlock = NULL;
  985:  
  986:        /* copy actual octets (they immediately follow the header) */
  987:        FLib_MemCpy((uint8_t *)pFragBlock + sizeof(zbTxFragmentedHdr_t), 
  988:            &(gZtcPacketFromClient.structured.payload[1]), fragLen);
  989:      break;
  990:  
  991:      /* set the fragmentation mask (for debugging and ZCP testing) */
  992:      case gZtcMsgTypeSetFragAckMask_c:
  993:        giFragmentedPreAcked = *gZtcPacketFromClient.structured.payload;
  994:      break;
  995:  
  996:      /* set the maximum OTA fragment length */
  997:      case gZtcMsgTypeSetMaxFragmentLength_c:
  998:        ApsmeSetRequest(gApsMaxFragmentLength_c, *gZtcPacketFromClient.structured.payload);
  999:      break;
 1000:  
 1001:      /* set the window size (1-8) */
 1002:      case gZtcMsgTypeSetWindowSize_c:
 1003:        ApsmeSetRequest(gApsMaxWindowSize_c, *gZtcPacketFromClient.structured.payload);
 1004:      break;
 1005:  
 1006:      /* set the interframe delay 1-255 milliseconds */
 1007:      case gZtcMsgTypeSetInterframeDelay_c:
 1008:        ApsmeSetRequest(gApsInterframeDelay_c, *gZtcPacketFromClient.structured.payload);
 1009:      break;
 1010:  
 1011:      /* unknown opcode (aka msgType) */
 1012:      default:
 1013:        ztcError = gZtcUnknownOpcode_c;
 1014:      break;
 1015:    }
 1016:  
 1017:    /* send response */
 1018:    gZtcPacketToClient.structured.header.opcodeGroup = gApsdeAfOpcodeGroup_c;
 1019:    gZtcPacketToClient.structured.header.msgType = msgType;
 1020:    gZtcPacketToClient.structured.header.len = sizeof(clientPacketStatus_t);
 1021:    gZtcPacketToClient.structured.payload[0] = ztcError;
 1022:    ZtcWritePacketToClient(sizeof(gZtcPacketToClient.structured.header)
 1023:                                 + gZtcPacketToClient.structured.header.len);
 1024:  
 1025:  }
 1026:  #endif // #if (gZtcIncluded_d && gFragmentationCapability_d)
 1027:  
 1028:  
 1029:  #if gZtcIncluded_d
 1030:  
 1031:  #if gBeeStackIncluded_d
 1032:  /*
 1033:    Called on inbound APSDE data requests
 1034:  
 1035:    This function both services APSDE-DATA.requests
 1036:  */
 1037:  index_t ZtcMsgFromPktApsde
 1038:    (
 1039:    uint8_t *pMsg,                        /* Pointer to message payload (just after msgType byte) */
 1040:    index_t msgLen,                       /* Length  of message payload */
 1041:    uint8_t *pPkt,                        /* Pointer to packet  payload */
 1042:    index_t pktLen,                       /* Length  of packet  payload */
 1043:    index_t fmtParametersIndex
 1044:    )
 1045:  {
 1046:    zbApsdeDataReq_t *pDataReq;
 1047:    uint8_t asduLen;
 1048:  
 1049:    /* unused parameters, mark so no compiler warnings */
 1050:    (void)msgLen;
 1051:    (void)fmtParametersIndex;
 1052:  
 1053:    /* copy in 1st part header (up to asdu) */
 1054:    pDataReq = (void *)pMsg;
 1055:    FLib_MemCpy(pDataReq, pPkt, MbrOfs(zbApsdeDataReq_t, pAsdu));
 1056:  
 1057:    /* asdu too large? we're done */
 1058:    asduLen = pktLen - (sizeof(zbApsdeDataReq_t) - sizeof(zbTxFragmentedHdr_t) - sizeof(uint8_t *));
 1059:    pDataReq->asduLength = asduLen;
 1060:  
 1061:    /* copy in 2nd part of header */
 1062:    FLib_MemCpy(&pDataReq->txOptions, pPkt + MbrOfs(zbApsdeDataReq_t, pAsdu) + asduLen, 
 1063:      MbrOfs(zbApsdeDataReq_t, fragmentHdr) - MbrOfs(zbApsdeDataReq_t, txOptions));
 1064:    BeeUtilZeroMemory(&pDataReq->fragmentHdr, sizeof(pDataReq->fragmentHdr));
 1065:  
 1066:    /* copy in ASDU */
 1067:    pDataReq->pAsdu = (void *)((pMsg - 1) + ApsmeGetAsduOffset());
 1068:    FLib_MemCpy(pDataReq->pAsdu, pPkt + MbrOfs(zbApsdeDataReq_t, pAsdu), asduLen);
 1069:  
 1070:    /* set up fragmented part */
 1071:  #if (gFragmentationCapability_d)
 1072:    pDataReq->fragmentHdr.pNextDataBlock = mpFragHead;
 1073:    pDataReq->fragmentHdr.iDataSize = asduLen;
 1074:    pDataReq->fragmentHdr.iMsgType = gApsdeDataReqMsgType_d;
 1075:  
 1076:    /* mark frag head as NULL for next data request */
 1077:    /* all buffers in linked list will be freed by APSDE-DATA.request itself */
 1078:    mpFragHead = NULL;
 1079:  #else
 1080:    pDataReq->fragmentHdr.pNextDataBlock = NULL;
 1081:    pDataReq->fragmentHdr.iDataSize = asduLen;
 1082:    pDataReq->fragmentHdr.iMsgType = gApsdeDataReqMsgType_d;
 1083:  #endif
 1084:  
 1085:    return 1; // everything is OK
 1086:  }
 1087:  #endif /* #if gBeeStackIncluded_d */
 1088:  #endif
 1089:  
 1090:  /****************************************************************************/
 1091:  
 1092:  /* Handle Ztc configuration commands/requests from the external client.
 1093:   * This code would be easier to read, but slower and larger, if each
 1094:   * case called a function instead of processing in-line.
 1095:   *
 1096:   * On arrival, the opcodeGroup in the pMsg has been changed to the opcode
 1097:   * group used for Ztc responses.
 1098:   *
 1099:   * The functions that actually handle the packets are responsible for the
 1100:   * contents of the return packet, except for the return packet's opcode
 1101:   * group. The message type of the return packet will be unchanged from the
 1102:   * request packet.
 1103:   *
 1104:   * *warning* ZtcReq_Handler() receives data in the global gZtcPacketFromClient,
 1105:   * and modifies gZtcPacketToClient.
 1106:   */
 1107:  #if gZtcIncluded_d
 1108:  void ZtcReq_Handler(void) {
 1109:    ztcMsgType_t msgType = gZtcPacketFromClient.structured.header.msgType;
 1110:    index_t i;
 1111:  
 1112:    if (mZtcPacketToClientIsBusy) {
 1113:      return;
 1114:    }
 1115:  
 1116:    for (i = 0; i < gZtcInternalMsgTypeInfoTableLen; ++i) {
 1117:      if (gaZtcInternalMsgTypeInfoTable[i].msgType == msgType) {
 1118:  
 1119:        /* Set default values. */
 1120:        gZtcPacketToClient.structured.header.opcodeGroup = gZtcCnfOpcodeGroup_c;
 1121:        gZtcPacketToClient.structured.header.msgType = msgType;
 1122:        gZtcPacketToClient.structured.header.len = sizeof(clientPacketStatus_t);
 1123:        gZtcPacketToClient.structured.payload[0] = gZtcSuccess_c;
 1124:  
 1125:        (*gaZtcInternalMsgTypeInfoTable[i].pConfigFunc)();
 1126:  
 1127:  #if gZtcErrorReporting_d
 1128:        if (!mZtcErrorReported)
 1129:  #endif
 1130:          ZtcWritePacketToClient(sizeof(gZtcPacketToClient.structured.header)
 1131:                                 + gZtcPacketToClient.structured.header.len);
 1132:  
 1133:        return;
 1134:      }
 1135:    }
 1136:  
 1137:    ZtcError(gZtcUnknownOpcode_c);
 1138:  }                                       /* ZtcReq_Handler() */
 1139:  #endif
 1140:  
 1141:  /****************************************************************************/
 1142:  
 1143:  #if gZtcIncluded_d
 1144:  void ZtcMsgGetModeReqFunc(void) {
 1145:    uint8_t i;
 1146:    index_t payloadIndex = sizeof(clientPacketStatus_t);
 1147:  
 1148:    gZtcPacketToClient.structured.payload[payloadIndex++] = (uint8_t) gZtcTxBlocking;
 1149:  
 1150:    for (i = 0; i < mZtcSAPModeTableLen; ++i) {
 1151:      gZtcPacketToClient.structured.payload[payloadIndex++] = (uint8_t) maZtcSAPModeTable[i];
 1152:    }
 1153:  
 1154:    gZtcPacketToClient.structured.header.len = payloadIndex;
 1155:  }                                       /* ZtcMsgGetModeReqFunc() */
 1156:  #endif
 1157:  
 1158:  
 1159:  /****************************************************************************/
 1160:  
 1161:  #if gZtcIncluded_d
 1162:  void ZtcMsgGetNVDataSetDescReqFunc(void) {
 1163:    index_t payloadIndex = sizeof(clientPacketStatus_t);
 1164:  #if !gNvStorageIncluded_d
 1165:    gZtcPacketToClient.structured.payload[payloadIndex++] = 0;
 1166:  #else
 1167:    index_t dataSetIndex;
 1168:    NvDataItemDescription_t const *pDesc;
 1169:    uint16_t size;
 1170:  
 1171:    gZtcPacketToClient.structured.payload[payloadIndex++] = NumberOfElements(NvDataSetTable);
 1172:  
 1173:    for (dataSetIndex = 0; dataSetIndex < NumberOfElements(NvDataSetTable); ++dataSetIndex) {
 1174:      gZtcPacketToClient.structured.payload[payloadIndex++] = NvDataSetTable[dataSetIndex].dataSetID;
 1175:  
 1176:      pDesc = NvDataSetTable[dataSetIndex].pItemDescriptions;
 1177:      size = 0;
 1178:      while (pDesc->length) {
 1179:        size += pDesc++->length;
 1180:      }
 1181:  
 1182:      gZtcPacketToClient.structured.payload[payloadIndex++] = (size & 0xFF);
 1183:      gZtcPacketToClient.structured.payload[payloadIndex++] = (size >> 8);
 1184:    }
 1185:  
 1186:  #endif
 1187:    gZtcPacketToClient.structured.header.len = payloadIndex;
 1188:  }                                       /* ZtcMsgGetNVDataSetDescReqFunc() */
 1189:  #endif
 1190:  
 1191:  /****************************************************************************/
 1192:  
 1193:  #if gZtcIncluded_d
 1194:  void ZtcMsgGetNVPageHdrReqFunc(void) {
 1195:    index_t payloadIndex = sizeof(clientPacketStatus_t);
 1196:  #if !gNvStorageIncluded_d
 1197:    gZtcPacketToClient.structured.payload[payloadIndex++] = 0;
 1198:  #else
 1199:    index_t pageIndex;
 1200:  
 1201:    gZtcPacketToClient.structured.payload[payloadIndex++] = NumberOfElements(maNvRawPageAddressTable);
 1202:  
 1203:    for (pageIndex = 0; pageIndex < NumberOfElements(maNvRawPageAddressTable); ++pageIndex) {
 1204:      FLib_MemCpy((void *) &gZtcPacketToClient.structured.payload[payloadIndex],
 1205:                  (void *) maNvRawPageAddressTable[pageIndex],
 1206:                  sizeof(NvStructuredPageHeader_t));
 1207:      payloadIndex += sizeof(NvStructuredPageHeader_t);
 1208:    }
 1209:  #endif
 1210:    gZtcPacketToClient.structured.header.len = payloadIndex;
 1211:  }                                       /* ZtcMsgGetNVPageHdrReqFunc() */
 1212:  #endif
 1213:  
 1214:  /****************************************************************************/
 1215:  
 1216:  /* Set various Ztc operating mode flags:
 1217:   *
 1218:   *  gZtcTxBlocking: if TRUE, the UART/SPI output routine will block until
 1219:   *  output is finished.
 1220:   *
 1221:   *  maZtcSAPModeTable[]: One byter per group of SAP Handlers, indicating
 1222:   *  what Ztc should do when a message from one of the given SAP Handlers
 1223:   *  arrives at ZTC_TaskEventMonitor():
 1224:   *      ignore messages from that SAP Handler, or
 1225:   *      forward monitor copies of messages from that SAP Handler to the
 1226:   *          external client, or
 1227:   *      intercept messages from that SAP Handle; forward them to the external
 1228:   *      client, and prevent them from being passed to their destination
 1229:   *      BeeStack layer.
 1230:   *  Note that these modes only affect messages that are sent from the SAP
 1231:   *  Handler to Ztc. These settings have no effect on packets sent from the
 1232:   *  external client to the SAP Handler.
 1233:   *
 1234:   * *warning* This is brittle. Ztc and the client must implicitly
 1235:   * agree on the order of the mode setting flags.
 1236:   */
 1237:  #if gZtcIncluded_d
 1238:  void ZtcMsgModeSelectReqFunc(void) {
 1239:    uint8_t byte;
 1240:    index_t count;
 1241:    index_t dataLen = gZtcPacketFromClient.structured.header.len;
 1242:    uint8_t i;
 1243:    index_t payloadIndex = 0;
 1244:  
 1245:    if (dataLen > 0) {
 1246:      gZtcTxBlocking = !!gZtcPacketFromClient.structured.payload[payloadIndex++];
 1247:    }
 1248:  
 1249:    dataLen -= sizeof(gZtcPacketFromClient.structured.payload[0]);
 1250:  
 1251:    count = (dataLen <= mZtcSAPModeTableLen ? dataLen : mZtcSAPModeTableLen);
 1252:  
 1253:    for (i = 0; i < count; ++i) {
 1254:      byte = gZtcPacketFromClient.structured.payload[payloadIndex + i];
 1255:      /* If support for these SAP Handlers hse by compiled out, ignore them. */
 1256:      if (maZtcSAPModeTable[i] != gZtcSAPModeInvalid_c) {
 1257:        maZtcSAPModeTable[i] = byte;
 1258:      }
 1259:    }
 1260:  }                                       /* ZtcMsgModeSelectReqFunc() */
 1261:  #endif
 1262:  
 1263:  /****************************************************************************/
 1264:  
 1265:  #if gZtcIncluded_d
 1266:  void ZtcMsgNVSaveReqFunc(void) {
 1267:  #if !gNvStorageIncluded_d
 1268:    ZtcError(gZtcRequestIsDisabled_c);
 1269:  #else
 1270:    uint8_t dataSetIndex;
 1271:  
 1272:    dataSetIndex = gZtcPacketFromClient.structured.payload[0];
 1273:    if (dataSetIndex > NumberOfElements(NvDataSetTable)) {
 1274:      ZtcError(gZtcTooBig_c);
 1275:      return;
 1276:    }
 1277:  
 1278:    NvSaveOnIdle(NvDataSetTable[dataSetIndex].dataSetID);
 1279:  #endif
 1280:  }                                       /* ZtcMsgNVSaveReqFunc() */
 1281:  #endif
 1282:  
 1283:  /****************************************************************************/
 1284:  #if gZtcIncluded_d
 1285:  #if (gMsgInfo_d)
 1286:  #include "msgsystem.h"
 1287:  extern pools_t maMmPools[];
 1288:  
 1289:  /******************************************************************************
 1290:  * MM_DebugNumFreeBigBuffers
 1291:  *
 1292:  ******************************************************************************/
 1293:  uint8_t ZTC_DebugNumFreeBigBuffers
 1294:    (
 1295:    void
 1296:    )
 1297:  {
 1298:    listHeader_t *pHead;
 1299:    uint8_t count = 0;
 1300:    pHead = maMmPools[1].anchor.pHead;
 1301:    while(pHead != NULL)   
 1302:    {
 1303:      pHead = pHead->pNext;
 1304:      count++;
 1305:    }
 1306:     
 1307:   return count;
 1308:  }
 1309:  
 1310:  /******************************************************************************
 1311:  * MM_DebugNumFreeSmallBuffers
 1312:  *
 1313:  ******************************************************************************/
 1314:  uint8_t ZTC_DebugNumFreeSmallBuffers
 1315:    (
 1316:    void
 1317:    )
 1318:  {
 1319:    listHeader_t *pHead;
 1320:    uint8_t count = 0;
 1321:    
 1322:    pHead = maMmPools[0].anchor.pHead;
 1323:    while(pHead != NULL)    
 1324:    {
 1325:      pHead = pHead->pNext;
 1326:      count++;
 1327:    }
 1328:    return count;
 1329:  }
 1330:  
 1331:  /******************************************************************************/
 1332:  void ZtcMsgGetNumOfMsgsReqFunc(void) {
 1333:    gZtcPacketToClient.structured.payload[0] = ZTC_DebugNumFreeSmallBuffers();
 1334:    gZtcPacketToClient.structured.payload[1] = ZTC_DebugNumFreeBigBuffers();
 1335:    gZtcPacketToClient.structured.header.len = (sizeof(uint8_t) *2);
 1336:  }
 1337:  #endif //gMsgInfo_d
 1338:  
 1339:  #endif
 1340:  /****************************************************************************/
 1341:  
 1342:  #if gZtcIncluded_d
 1343:  void ZtcMsgReadExtendedAdrReqFunc(void) {
 1344:    FLib_MemCpy( &gZtcPacketToClient.structured.payload[sizeof(clientPacketStatus_t)],
 1345:         aExtendedAddress, 8 );
 1346:   
 1347:    gZtcPacketToClient.structured.header.len = sizeof(clientPacketStatus_t) + 8;
 1348:  }                                         /* ZtcMsgReadExtendedAdrReqFunc() */
 1349:  
 1350:  #endif
 1351:  
 1352:  /****************************************************************************/
 1353:  
 1354:  /* eliminate compiler warnings */
 1355:  #if gZtcIncluded_d
 1356:  uint8_t AF_AppToAfdeDataReq(void) {
 1357:    return gZbSuccess_c;
 1358:  }
 1359:  
 1360:  #endif
 1361:  
 1362:  /****************************************************************************/
 1363:  
 1364:  #if gZtcIncluded_d
 1365:  void ZtcMsgResetCPUReqFunc(void) {
 1366:  
 1367:    /* We're about to reset the CPU. Turn off Uart/SPI */    
 1368:    Uart_ModuleUninit();
 1369:  #if defined(gSPIInterface_d)
 1370:  
 1371:    SPI_Uninit();
 1372:    
 1373:  #elif defined(gIICInterface_d)
 1374:  
 1375:    IIC_ModuleUninit();
 1376:    
 1377:  #endif
 1378:    PWRLib_Reset();
 1379:  }                                       /* ZtcMsgResetCPUReqFunc() */
 1380:  #endif
 1381:  
 1382:  /****************************************************************************/
 1383:  #if gZtcIncluded_d
 1384:  /* ZtcMsgWriteExtendedAdrReqFunc() */
 1385:  void ZtcMsgWriteExtendedAdrReqFunc(void)
 1386:  {
 1387:    FLib_MemCpy(aExtendedAddress, gZtcPacketFromClient.structured.payload,8);
 1388:  #ifdef PROCESSOR_MC1323X
 1389:    MacPhyInit_WriteExtAddress(aExtendedAddress);
 1390:  #endif //PROCESSOR_MC1323X   
 1391:  }
 1392:  
 1393:  #endif
 1394:  
 1395:  /****************************************************************************/
 1396:  #if (gSAPMessagesEnableNlme_d)
 1397:  #if gZtcIncluded_d
 1398:  void ZtcFreeDiscoveryTables(void) {
 1399:    NWK_FreeUpDiscoveryTables();
 1400:  }                          
 1401:  
 1402:  #endif
 1403:  /****************************************************************************/
 1404:  
 1405:  #if gZtcIncluded_d
 1406:  void ZtcSetJoinFilterFlag(void) {
 1407:    gZDOJoinMode = gZtcPacketFromClient.structured.payload[0];
 1408:  }                          
 1409:  #endif
 1410:  #endif
 1411:  /****************************************************************************/
 1412:  
 1413:  #if gUseHwValidation_c
 1414:  /* Function used for writing to RAM memory.
 1415:   * gZtcPacketFromClient.structured.payload contains the packet received from TestTool:
 1416:   * bytes 0 to 1 --> start address for writing
 1417:   * byte    2    --> number of bytes to be written
 1418:   * bytes 3 to (3+ (2nd byte) - 1) --> data to be written starting with start address.  
 1419:   */
 1420:  #if gZtcIncluded_d
 1421:  void ZtcWriteMemoryBlock(void) 
 1422:  {
 1423:    uint8_t *addr;
 1424:    uint8_t nBytes;
 1425:    uint8_t *pIn, *pOut;
 1426:    uint8_t nWritten, nRead;
 1427:    uint16_t auxAddr = 0;
 1428:    #define OffsetToSize   4  
 1429:  
 1430:    /* even if address is 4 bytes long, only the first 2 bytes received represent the effective address */
 1431:    FLib_MemCpy(&addr, gZtcPacketFromClient.structured.payload, sizeofPointer);
 1432:    
 1433:    #if gBigEndian_c
 1434:      auxAddr = Swap2Bytes((uint16_t)addr); 
 1435:      pOut = (uint8_t*)auxAddr;       
 1436:    #else
 1437:      pOut = addr; 
 1438:    #endif  
 1439:  
 1440:    /* number of bytes to write parameter is the 5th received byte */
 1441:    nBytes = gZtcPacketFromClient.structured.payload[OffsetToSize];
 1442:    /* data to write parameter starts with the 6th received byte */
 1443:    pIn = &gZtcPacketFromClient.structured.payload[OffsetToSize + 1];
 1444:    
 1445:    nRead = nWritten = 0;
 1446:    while (nRead++ < nBytes)
 1447:    {
 1448:    #ifndef PROCESSOR_QE128
 1449:    if (((uint16_t)pOut <= 0x107f)||(((uint16_t)pOut >= 0x1800)&&((uint16_t)pOut <= 0x182B)))/* Write to out of RAM range or I/O space attempted  */
 1450:    #else
 1451:    if ((uint16_t)pOut <= 0x207f)/* Write to out of RAM range or I/O space attempted  */ 
 1452:    #endif  
 1453:       {
 1454:          *pOut++ = *pIn++;
 1455:          nWritten++;
 1456:       }else{
 1457:          pOut++;
 1458:          pIn++;
 1459:       }
 1460:    }
 1461:    
 1462:    /* return the number of bytes written to RAM */
 1463:    gZtcPacketToClient.structured.payload[0] = nWritten;  
 1464:    
 1465:  }
 1466:  #endif
 1467:  /****************************************************************************/
 1468:  
 1469:  /* Function used for reading from memory.
 1470:   * gZtcPacketFromClient.structured.payload contains the packet received from TestTool:
 1471:   * bytes 0 to 1 --> start address for reading
 1472:   * byte    2    --> number of bytes to be read. 
 1473:   */
 1474:  #if gZtcIncluded_d
 1475:  void ZtcReadMemoryBlock(void) 
 1476:  {
 1477:    uint8_t *addr;
 1478:    uint8_t nBytes, lcount;
 1479:    uint8_t *pIn, *pOut;
 1480:    uint16_t auxAddr = 0;
 1481:    #define OffsetToSize   4
 1482:  
 1483:    /* even if address is 4 bytes long, only the first 2 bytes received represent the effective address */
 1484:    FLib_MemCpy(&addr, gZtcPacketFromClient.structured.payload, sizeofPointer);
 1485:    
 1486:    #if gBigEndian_c
 1487:      auxAddr = Swap2Bytes((uint16_t)addr);
 1488:      pOut = (uint8_t*)auxAddr;        
 1489:    #else
 1490:      pOut = addr; 
 1491:    #endif  
 1492:    /* number of bytes to read parameter is the 5th received byte */
 1493:    nBytes = gZtcPacketFromClient.structured.payload[OffsetToSize];
 1494:    lcount = nBytes;
 1495:    /* Construct and send response */
 1496:    
 1497:    pIn = &gZtcPacketToClient.structured.payload[0];
 1498:    for (;lcount != 0; lcount--)
 1499:    {
 1500:      *pIn++ = *pOut++;
 1501:    }
 1502:  
 1503:    gZtcPacketToClient.structured.header.len = nBytes;   
 1504:    
 1505:  }
 1506:  #endif
 1507:  /****************************************************************************/
 1508:  
 1509:  /* Function used for writing 16 bit data to ABEL registers. 
 1510:   * gZtcPacketFromClient.structured.payload contains the packet received from TestTool:
 1511:   * byte 0       --> The address to be written (0x00-0x3F)
 1512:   * bytes 1 to 2 --> 16 bits value to be written 
 1513:   */
 1514:  #if gZtcIncluded_d
 1515:  #ifndef PROCESSOR_MC1323X
 1516:  void ZtcAbelWrite(void) 
 1517:  {
 1518:    uint16_t auxValue; 
 1519:    ztcAbelWrite_t* pAbelWrite = (ztcAbelWrite_t*)gZtcPacketFromClient.structured.payload;
 1520:  
 1521:    #if gBigEndian_c
 1522:      auxValue = Swap2Bytes((uint16_t)pAbelWrite->value);        
 1523:    #else
 1524:      auxValue = (uint16_t)pAbelWrite->value; 
 1525:    #endif
 1526:    MC1319xDrv_WriteSpiAsync(gZtcPacketFromClient.structured.payload[0], auxValue);
 1527:  }
 1528:  #endif /* PROCESSOR_MC1323X */
 1529:  #endif
 1530:  /****************************************************************************/
 1531:  
 1532:  /* Function used for reading 16 bit data from ABEL registers. 
 1533:   * gZtcPacketFromClient.structured.payload contains the packet received from TestTool:
 1534:   * byte 0       --> The address to be read
 1535:   */
 1536:  #if gZtcIncluded_d
 1537:  #ifndef PROCESSOR_MC1323X
 1538:  void ZtcAbelRead(void) 
 1539:  {
 1540:    uint16_t auxValue, returnValue;
 1541:   
 1542:    MC1319xDrv_ReadSpiAsync(gZtcPacketFromClient.structured.payload[0], &auxValue);
 1543:    
 1544:    #if gBigEndian_c
 1545:      returnValue = Swap2Bytes(auxValue);        
 1546:    #else
 1547:      returnValue = auxValue; 
 1548:    #endif  
 1549:  
 1550:  	gZtcPacketToClient.structured.header.len = sizeof(returnValue);
 1551:  	/* return read value */
 1552:  	FLib_MemCpy(gZtcPacketToClient.structured.payload, &returnValue, sizeof(returnValue));  
 1553:  }
 1554:  #endif
 1555:  #endif
 1556:  /****************************************************************************/
 1557:  
 1558:  /*ZtcPing echoes back the payload*/
 1559:  #if gZtcIncluded_d
 1560:  void  ZtcPing(void)
 1561:  {
 1562:  
 1563:    gZtcPacketToClient.structured.header.len = gZtcPacketFromClient.structured.header.len;
 1564:    FLib_MemCpy(gZtcPacketToClient.structured.payload, gZtcPacketFromClient.structured.payload,
 1565:                gZtcPacketFromClient.structured.header.len );
 1566:  
 1567:  }
 1568:  #endif
 1569:  
 1570:  #endif /* gUseHwValidation_c */
 1571:  
 1572:  /* Permissions Configuration Table */
 1573:  #if (gZtcIncluded_d && (gStandardSecurity_d || gHighSecurity_d) && gApsMaxEntriesForPermissionsTable_c)
 1574:  
 1575:  extern index_t GetPermissionsTable(permissionsTable_t * pDstTable);
 1576:  extern void SetPermissionsTable(index_t entryCounter, uint8_t * payload);
 1577:  extern uint8_t RemoveDeviceFromPermissionsTable(zbIeeeAddr_t aDevAddr);
 1578:  extern void RemoveAllFromPermissionsTable(void);
 1579:  extern uint8_t AddDeviceToPermissionsTable(uint8_t * aDevAddr, permissionsFlags_t permissionsCategory);
 1580:  
 1581:  void ZtcMsgSetPermissionsTableFunc(void) {
 1582:    SetPermissionsTable(gZtcPacketFromClient.structured.payload[0], &(gZtcPacketFromClient.structured.payload[1]));
 1583:  }                                       /*  */
 1584:  
 1585:  void ZtcMsgGetPermissionsTableFunc(void) {
 1586:    ztcPermissionsTable_t *pTable = (ztcPermissionsTable_t *) &gZtcPacketToClient.structured.payload[sizeof(clientPacketStatus_t)];
 1587:    pTable->count = GetPermissionsTable(pTable->table);
 1588:    gZtcPacketToClient.structured.header.len = sizeof(clientPacketStatus_t)
 1589:                                             + sizeof(pTable->count)
 1590:                                             + (pTable->count * sizeof(permissionsTable_t));                                           
 1591:  }                                       /*  */
 1592:  
 1593:  void ZtcMsgRemoveFromPermissionsTableFunc(void)
 1594:  {
 1595:    if (gZtcPacketFromClient.structured.payload[0])
 1596:      RemoveAllFromPermissionsTable();
 1597:    else
 1598:      gZtcPacketToClient.structured.payload[0] = RemoveDeviceFromPermissionsTable(&gZtcPacketFromClient.structured.payload[1]);
 1599:    gZtcPacketToClient.structured.header.len = sizeof(clientPacketStatus_t); 
 1600:  }                                       /*  */
 1601:  
 1602:  void ZtcMsgAddDeviceToPermissionsTableFunc(void)
 1603:  {
 1604:    gZtcPacketToClient.structured.payload[0] = AddDeviceToPermissionsTable(&(gZtcPacketFromClient.structured.payload[0]), gZtcPacketFromClient.structured.payload[sizeof(zbIeeeAddr_t)]);
 1605:    gZtcPacketToClient.structured.header.len = sizeof(clientPacketStatus_t); 
 1606:  }                                       /*  */
 1607:  
 1608:  #endif /* (gZtcIncluded_d && (gStandardSecurity_d || gHighSecurity_d) && gApsMaxEntriesForPermissionsTable_c) */
 1609:  
 1610:  /****************************************************************************/
 1611:  
 1612:  #if (gZtcIncluded_d && defined(gZtcOtapSupport_d))
 1613:  
 1614:  void (*pfOtapCallback)(void) = NULL;
 1615:  void (*pfOtapCompute)(uint8_t*, uint8_t) = NULL;
 1616:  static   bool_t   mFirstChunk, mLoadInProgress = FALSE;
 1617:  static   uint32_t mRealImgSize, mRemainingSize, mEepromOffset;
 1618:  
 1619:  void ZtcOtapSupportStartImageReqFunc(void) {
 1620:    
 1621:    gZtcPacketToClient.structured.header.len = (sizeof(uint8_t));
 1622:    gZtcPacketToClient.structured.payload[0] = gOtapSucess_c;
 1623:    
 1624:    if (mLoadInProgress){    
 1625:       gZtcPacketToClient.structured.payload[0] = gOtapInvalidOperation_c;
 1626:       return;
 1627:    }
 1628:    
 1629:    //Get image size (including Header and SublementTag)
 1630:    FLib_MemCpyReverseOrder(&mRemainingSize, gZtcPacketFromClient.structured.payload, 4);
 1631:    mRealImgSize = mRemainingSize - sizeof(ImageHeader_t) - sizeof(SubElement_t);
 1632:        
 1633:    if ((mRealImgSize == 0) ||
 1634:        (mRealImgSize > (gEepromParams_TotalSize_c - gBootData_Image_Offset_c))) { 
 1635:       gZtcPacketToClient.structured.payload[0] = gOtapInvalidParam_c;
 1636:       return; 
 1637:     }
 1638:     
 1639:    if(EEPROM_Init() != ee_ok) {
 1640:      gZtcPacketToClient.structured.payload[0] = gOtapEepromError_c;
 1641:      return;
 1642:    }
 1643:    
 1644:    mEepromOffset = gBootData_Image_Offset_c;
 1645:    mLoadInProgress = TRUE;
 1646:    mFirstChunk = TRUE;
 1647:  }
 1648:  
 1649:  void ZtcOtapSupportSetInternalFlashReqFunc(void) {}
 1650:  
 1651:  /* Write data to eeprom*/
 1652:  void ZtcOtapSupportPushImageChunkReqFunc(void) {
 1653:    uint8_t len, status;
 1654:  
 1655:    if (!mLoadInProgress){    
 1656:      gZtcPacketToClient.structured.payload[0] = gOtapInvalidOperation_c;
 1657:      return;
 1658:    }
 1659:    
 1660:    len = gZtcPacketFromClient.structured.payload[0];  
 1661:    mRemainingSize -=len;
 1662:    
 1663:    gZtcPacketToClient.structured.header.len = (sizeof(uint8_t));
 1664:    if (len == 0) {
 1665:      gZtcPacketToClient.structured.payload[0] = gOtapInvalidParam_c;
 1666:      return;
 1667:    }
 1668:    
 1669:    if (mFirstChunk) 
 1670:      {
 1671:       mFirstChunk = FALSE;
 1672:       status = EEPROM_WriteData(gImageDataFirstBlockSize_c, gBootData_Image_Offset_c + mRealImgSize, &gZtcPacketFromClient.structured.payload[1]);
 1673:       if (status == ee_ok)
 1674:         status = EEPROM_WriteData(len-gImageDataFirstBlockSize_c, mEepromOffset, &gZtcPacketFromClient.structured.payload[gImageDataFirstBlockSize_c +1]);
 1675:       mEepromOffset += len-gImageDataFirstBlockSize_c;
 1676:      } 
 1677:    else 
 1678:      {
 1679:        status = EEPROM_WriteData(len, mEepromOffset, &gZtcPacketFromClient.structured.payload[1]);
 1680:        mEepromOffset += len;
 1681:      }
 1682:    // Do other computing on the received buffer
 1683:    if (pfOtapCompute != NULL)
 1684:      pfOtapCompute(&gZtcPacketFromClient.structured.payload[1], len);
 1685:  
 1686:    gZtcPacketToClient.structured.payload[0] = status;    
 1687:  }
 1688:  
 1689:  void ZtcOtapSupportCommitImageReqFunc(void) {
 1690:    uint8_t status;
 1691:  
 1692:    gZtcPacketToClient.structured.header.len = (sizeof(uint8_t));
 1693:    if (!mLoadInProgress){    
 1694:      gZtcPacketToClient.structured.payload[0] = gOtapInvalidOperation_c;
 1695:      return;
 1696:    }
 1697:    
 1698:    mLoadInProgress = FALSE;
 1699:    if (mRemainingSize > 0) {
 1700:      gZtcPacketToClient.structured.payload[0] = gOtapInvalidOperation_c;
 1701:      return;
 1702:    }
 1703:    
 1704:    status = EEPROM_WriteData(gBootData_SectorsBitmap_Size_c, gBootData_SectorsBitmap_Offset_c, &gZtcPacketFromClient.structured.payload[2]);
 1705:    if (status == ee_ok)
 1706:      status = EEPROM_WriteData(gBootData_ImageLength_Size_c, gBootData_ImageLength_Offset_c, (uint8_t*)&mRealImgSize);  
 1707:    
 1708:    if (status == ee_ok) {
 1709:      gZtcPacketToClient.structured.payload[0] = gOtapSucess_c;
 1710:  	if (pfOtapCallback!=NULL)
 1711:        pfOtapCallback(); // Inform AppTask
 1712:    }
 1713:    else
 1714:      gZtcPacketToClient.structured.payload[0] = gOtapEepromError_c;
 1715:  }
 1716:  
 1717:  void ZtcOtapSupportCancelImageReqFunc(void) {
 1718:    mLoadInProgress = FALSE;
 1719:  }
 1720:  
 1721:  #endif
 1722:  
 1723:  #if gZtcIncluded_d
 1724:  void ZtcGetLastReceivedPacketLqiValue(void)
 1725:  {
 1726:    gZtcPacketToClient.structured.payload[0] = PhyGetLastRxLqiValue();
 1727:    gZtcPacketToClient.structured.header.len = 1;
 1728:  }
 1729:  #endif
 1730:  
 1731:  #if gZtcIncluded_d
 1732:  void ZtcMsgGetMaxProgramStackUsage(void)
 1733:  {
 1734:    uint8_t *pStack;
 1735:    uint16_t stackSize =(uint16_t)__SEG_END_SSTACK , stackUsage = 0;
 1736:    stackSize -=  (uint16_t)__SEG_START_SSTACK;
 1737:  #if (STACK_FILL)
 1738:    
 1739:    #if gNvStorageIncluded_d
 1740:      pStack = __SEG_END_NV_CODE_BUFFER;
 1741:    #else//gNvStorageIncluded_d
 1742:      pStack = __SEG_START_SSTACK;
 1743:    #endif//gNvStorageIncluded_d
 1744:    
 1745:    while ( pStack < __SEG_END_SSTACK )
 1746:    {
 1747:      if(*pStack != STACK_INIT_VALUE)
 1748:      {
 1749:        break;
 1750:      }
 1751:      else
 1752:      {
 1753:        stackUsage++;
 1754:      }
 1755:      pStack++;
 1756:    }
 1757:    #if gNvStorageIncluded_d
 1758:      stackUsage = (stackSize - stackUsage);
 1759:      stackUsage -= (uint16_t)((uint16_t) __SEG_END_NV_CODE_BUFFER - (uint16_t) __SEG_START_SSTACK);
 1760:      gZtcPacketToClient.structured.payload[0] = 2;//Err NvStorageIncluded_d=1 in file NVM_Interface
 1761:    #else//gNvStorageIncluded_d
 1762:      stackUsage = (stackSize - stackUsage);
 1763:      gZtcPacketToClient.structured.payload[0] = 0;//Success
 1764:    #endif//gNvStorageIncluded_d
 1765:    
 1766:    #if gBigEndian_c
 1767:      *((uint16_t *)&gZtcPacketToClient.structured.payload[1]) = Swap2Bytes(stackSize);
 1768:      *((uint16_t *)&gZtcPacketToClient.structured.payload[3]) = Swap2Bytes(stackUsage);
 1769:    #else//gBigEndian_c
 1770:      *((uint16_t *)&gZtcPacketToClient.structured.payload[1]) = (stackSize);
 1771:      *((uint16_t *)&gZtcPacketToClient.structured.payload[3]) = (stackUsage);
 1772:    #endif//gBigEndian_c
 1773:      gZtcPacketToClient.structured.header.len = 2 * sizeof(uint16_t) + 1;
 1774:  #else// STACK_FILL
 1775:    gZtcPacketToClient.structured.payload[0] = 1;//Err STACK_FILL=0 in file crt0.h
 1776:    #if gBigEndian_c
 1777:      *((uint16_t *)&gZtcPacketToClient.structured.payload[1]) = Swap2Bytes(stackSize);
 1778:    #else//gBigEndian_c
 1779:      *((uint16_t *)&gZtcPacketToClient.structured.payload[1]) = (stackSize);
 1780:    #endif//gBigEndian_c
 1781:    *((uint16_t *)&gZtcPacketToClient.structured.payload[3]) = (0);
 1782:    gZtcPacketToClient.structured.header.len = 2 * sizeof(uint16_t) + 1;
 1783:  #endif//STACK_FILL
 1784:  }
 1785:  #endif
 1786:  
 1787:  #if (gLpmIncluded_d == 1)
 1788:  /****************************************************************************/
 1789:  #if gZtcIncluded_d
 1790:  static void ZtcMsgWakeUpInd(void) 
 1791:  {
 1792:    /* Set default values. */
 1793:    gZtcPacketToClient.structured.header.opcodeGroup = gZtcCnfOpcodeGroup_c;
 1794:    gZtcPacketToClient.structured.header.msgType = mZtcMsgWakeUpIndication_c;
 1795:    gZtcPacketToClient.structured.header.len = 0x00;
 1796:    ZtcWritePacketToClient(sizeof(gZtcPacketToClient.structured.header) + gZtcPacketToClient.structured.header.len);
 1797:  }
 1798:  #endif
 1799:  /****************************************************************************/
 1800:  /* This function selects and configures the PIN (KB0-KB7)
 1801:   * through which the MCU enters or not in sleep mode.
 1802:   */
 1803:  #if gZtcIncluded_d 
 1804:  void ZtcMsgSelectWakeUpPINReqFunc(void) 
 1805:  {  
 1806:    /* Check if any pin is selected */
 1807:    if(gZtcPacketFromClient.structured.payload[0])
 1808:    {
 1809:    
 1810:  #ifndef PROCESSOR_MC1323X  
 1811:    /* On S08GT60, if rising edges detection was selected, check if a right pin was chosen */
 1812:     if ((gZtcPacketFromClient.structured.payload[1] == 0x01) &&
 1813:        !(gZtcPacketFromClient.structured.payload[0] & mRisingEdgesPinsMask_c ))
 1814:     {
 1815:        /* The parameters are not correctly set */
 1816:        gZtcPacketToClient.structured.payload[0] = gZtcError_c; 
 1817:        return;
 1818:     }
 1819:  #endif   
 1820:     /* Set the new configuration */   
 1821:     FLib_MemCpy(&ztcWakeUpConfig, &gZtcPacketFromClient.structured.payload[0], sizeof(ztcWakeUpConfig)-sizeof(ztcWakeUpConfig.prevPinLevel)); 
 1822:     KBISC |= 0x02; /* KBI status and control register initialized*/   
 1823:     if(ztcWakeUpConfig.detectionEdge == mRisingEdges_c) 
 1824:     {
 1825:  #ifndef PROCESSOR_MC1323X   
 1826:       KBISC |= (ztcWakeUpConfig.selectedKBPin & mRisingEdgesPinsMask_c); /* Select to wake up on rising edges */
 1827:  #else  
 1828:       KBIES |= ztcWakeUpConfig.selectedKBPin;
 1829:  #endif 
 1830:     }
 1831:     else
 1832:     {
 1833:  #ifndef PROCESSOR_MC1323X   
 1834:       KBISC &= ~(ztcWakeUpConfig.selectedKBPin & mRisingEdgesPinsMask_c);/* Select to wake up on falling edges */
 1835:  #else
 1836:       KBIES &= ~ztcWakeUpConfig.selectedKBPin;
 1837:  #endif   
 1838:     }
 1839:     KBIPE |= ztcWakeUpConfig.selectedKBPin; /* KBI pin enable controls initialized */  
 1840:     /* If prevPinLevel is 0xff, it's mean that we don't have any pin level previously detected */
 1841:     ztcWakeUpConfig.prevPinLevel = 0xff;
 1842:    }
 1843:    else
 1844:    {
 1845:      FLib_MemSet(&ztcWakeUpConfig, 0x00, sizeof(ztcWakeUpConfig)-sizeof(ztcWakeUpConfig.prevPinLevel));
 1846:      ztcWakeUpConfig.prevPinLevel = 0xff;
 1847:    }
 1848:    /* Get the level of the pin */
 1849:    Ztc_CheckWakeUpPIN();
 1850:  }
 1851:  #endif
 1852:  /****************************************************************************/
 1853:  
 1854:  /* Read the pin level to detect the level changes;
 1855:     Allow or not to enter in sleep mode (depend on wakeup pin configuration) */
 1856:  void Ztc_CheckWakeUpPIN(void) 
 1857:  {
 1858:   uint8_t currentPinLevel;
 1859:   /* By default, the Application allows device to sleep */
 1860:   static bool_t ztcDevCanGoToSleep_Flag = TRUE; 
 1861:  
 1862:   if(!ztcWakeUpConfig.selectedKBPin)
 1863:   {
 1864:   /* If the wake up pin is not configured, disallow device to sleep */ 
 1865:    if(ztcDevCanGoToSleep_Flag)
 1866:    {
 1867:      PWR_DisallowDeviceToSleep();  /* Disallow device to sleep */
 1868:      ztcDevCanGoToSleep_Flag = FALSE; 
 1869:    }    
 1870:    return;
 1871:   }
 1872:  
 1873:   /* Read the pin */
 1874:   currentPinLevel = SWITCH_PORT & ztcWakeUpConfig.selectedKBPin;
 1875:   /* Check if the level was changed since the previous read or this is the 
 1876:      first time we read it */
 1877:   if((currentPinLevel^ztcWakeUpConfig.prevPinLevel) || (ztcWakeUpConfig.prevPinLevel == 0xff))
 1878:   {
 1879:      /* If the MCU is waking up on rising edges and the level is low(or MCU is waking up on falling edges 
 1880:      and the level is high), allow device to sleep; else disallow to sleep;
 1881:      Send a Wakeup.Ind message if needed.
 1882:      */
 1883:      if( (!currentPinLevel && (ztcWakeUpConfig.detectionEdge == mRisingEdges_c)) ||
 1884:         (currentPinLevel && (ztcWakeUpConfig.detectionEdge == mFallingEdges_c)) )
 1885:      { /* Allow to sleep only if the device can NOT go to sleep */
 1886:       if(!ztcDevCanGoToSleep_Flag)
 1887:       {
 1888:         PWR_AllowDeviceToSleep(); /* Allow device to sleep */
 1889:         ztcDevCanGoToSleep_Flag = TRUE;
 1890:       }
 1891:      }
 1892:      else
 1893:      { /* Disallow to sleep only if the device can go to sleep */
 1894:       if(ztcDevCanGoToSleep_Flag)
 1895:       {
 1896:         PWR_DisallowDeviceToSleep();  /* Disallow device to sleep */
 1897:         ztcDevCanGoToSleep_Flag = FALSE;
 1898:         if(ztcWakeUpConfig.signalWhenWakeUpFlag && (ztcWakeUpConfig.prevPinLevel != 0xff))
 1899:            ZtcMsgWakeUpInd();
 1900:       }
 1901:      }
 1902:   }
 1903:   
 1904:    /* Update the previous pin level with the current one */
 1905:    ztcWakeUpConfig.prevPinLevel = currentPinLevel;
 1906:  }
 1907:  
 1908:  #else /*  else #if gLpmIncluded_d */
 1909:  #if gZtcIncluded_d
 1910:  void ZtcMsgSelectWakeUpPINReqFunc(void) 
 1911:  { 
 1912:  }
 1913:  #endif
 1914:  #endif /* #if gLpmIncluded_d */ 
 1915:  
 1916:  
 1917:  
 1918:  /****************************************************************************/
