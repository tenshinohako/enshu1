*** EVALUATION ***
ANSI-C/cC++ Compiler for HC08 V-5.0.41 Build 12319, Nov 15 2012

    1:  /******************************************************************************
    2:  * Source file for LCD driver
    3:  *
    4:  *
    5:  * Copyright (c) 2010, Freescale Inc. All right reserved.
    6:  *
    7:  * 
    8:  * No part of this document must be reproduced in any form - including copied,
    9:  * transcribed, printed or by any electronic means - without specific written 
   10:  * permission from Freescale Semiconductor.
   11:  *
   12:  ******************************************************************************/
   13:  
   14:  #include "EmbeddedTypes.h"
   15:  #include "IrqControlLib.h"
   16:  #include "FunctionLib.h"
   17:  #include "TS_Interface.h"
   18:  #include "SPI_Interface.h"
   19:  #include "Display_MC1323x_RCM.h"
   20:  
   21:  
   22:  #ifndef gMacStandAlone_d
   23:  #define gMacStandAlone_d 0    
   24:  #endif
   25:  
   26:  #if gMacStandAlone_d
   27:    #include "Mac_Globals.h"
   28:  #endif
   29:  
   30:  /******************************************************************************
   31:  *******************************************************************************
   32:  * Private macros
   33:  *******************************************************************************
   34:  ******************************************************************************/
   35:  
   36:  
   37:  /******************************************************************************
   38:  *******************************************************************************
   39:  * Private type definitions
   40:  *******************************************************************************
   41:  ******************************************************************************/
   42:  typedef enum
   43:  {
   44:    mLcd_State_Idle_c,
   45:    mLcd_State_Init_c,
   46:    mLcd_State_Display_c,
   47:    mLcd_State_Control_c,  
   48:  } lcdState_t;
   49:  
   50:  typedef enum
   51:  {
   52:    mLcd_LineProcess_OnGoing_c,
   53:    mLcd_LineProcess_Finished_c
   54:  } lcdLineProcessStatus_t;
   55:  
   56:  typedef struct lcdOperType_tag
   57:  {
   58:    lcdState_t      mLcdState;
   59:    uint8_t         mLcdCtrlCmd;
   60:    void            (*pfLcdInitCallback)(bool_t status);
   61:    void            (*pfLcdCtrlCallback)(bool_t status);
   62:  } lcdOperType_t;
   63:  
   64:  typedef struct lcdBuffTableRef_tag
   65:  {  
   66:    uint8_t         mLcdBuffCmd;
   67:    uint8_t         lcdPos;  
   68:    uint8_t         buffLen;  
   69:    void            (*pfBuffCallback)(bool_t status);
   70:  } lcdBuffTableRef_t;
   71:  
   72:  typedef struct lcdInstrCode_tag
   73:  {
   74:    uint8_t         mLcdUpperNibble; 
   75:    uint8_t         mLcdLowerNibble;
   76:    index_t         lcdWriteCmdStep;
   77:  } lcdInstrCode_t;
   78:  
   79:  /******************************************************************************
   80:  *******************************************************************************
   81:  * Public memory definitions  
   82:  *******************************************************************************
   83:  ******************************************************************************/
   84:  #if(TRUE == gLCDSupported_d)
   85:    /* Id for LCD Task */
   86:    tsTaskID_t      gLcdTaskId;
   87:  #endif /* gLCDSupported_d */
   88:  
   89:  /******************************************************************************
   90:  *******************************************************************************
   91:  * Private memory definitions
   92:  *******************************************************************************
   93:  ******************************************************************************/
   94:  #if(TRUE == gLCDSupported_d)
   95:    static lcdOperType_t      lcdOperType;  
   96:    static lcdInstrCode_t     lcdInstrCode;
   97:    static index_t            initStep;
   98:    
   99:    /* SPI configuration parameters */
  100:    static spiConfig_t        mSpiConfig;
  101:    
  102:    /* Buffer table reference structure */
  103:    static lcdBuffTableRef_t  mLcdBuffTableRef[gLCD_MaxLcdLines_c];   
  104:    
  105:    /* LCD line buffers */
  106:    static uint8_t            maLcdBuffTable[gLCD_MaxLcdLines_c][gMAX_LCD_CHARS_c];
  107:  
  108:    /* List of initialization commands */
  109:    const uint8_t initCmdList[gLCD_MaxInitSteps_c] = 
  110:    {         
  111:      gLCD_FunctionSetCtrl_c,
  112:      gLCD_FunctionSetCtrl_c,
  113:      gLCD_DisplayCtrl_c   | gLCD_DisplayOnBit_c,
  114:      gLCD_ClearCtrl_c,
  115:      gLCD_EntryModeCtrl_c | gLCD_CursorMoveRight_c,
  116:      /* Second init step operations */
  117:      gLCD_FunctionSetCtrl_c,
  118:      gLCD_FunctionSetCtrl_c,
  119:      gLCD_DisplayCtrl_c   | gLCD_DisplayOnBit_c,
  120:      gLCD_ClearCtrl_c,
  121:      gLCD_EntryModeCtrl_c | gLCD_CursorMoveRight_c    
  122:    };
  123:    /* List of waiting time between initialization's commands */
  124:    const uint8_t initWaitTime[gLCD_MaxInitSteps_c] =
  125:    {         
  126:      gLCD_Wait100mSec_c,
  127:      gLCD_Wait150uSec_c,
  128:      gLCD_Wait150uSec_c,
  129:      gLCD_Wait150uSec_c,       
  130:      gLCD_Wait15mSec_c,
  131:      /* Second init step timings */
  132:      gLCD_Wait100mSec_c,
  133:      gLCD_Wait150uSec_c,
  134:      gLCD_Wait150uSec_c,
  135:      gLCD_Wait150uSec_c,       
  136:      gLCD_Wait15mSec_c             
  137:    };
  138:  
  139:    /* Included only for legacy compatibility with old LCd driver */
  140:    const uint8_t gaHexValue[] = "0123456789ABCDEF";
  141:  #endif /* gLCDSupported_d */
  142:  
  143:  
  144:  /******************************************************************************
  145:  *******************************************************************************
  146:  * Private function prototypes 
  147:  *******************************************************************************
  148:  ******************************************************************************/
  149:  #if(TRUE == gLCDSupported_d)
  150:    static void     LCD_WaitMilliSec(uint8_t timeInMilliSeconds);
  151:    static void     LCD_WaitMicroSec(uint8_t timeInMicroSeconds);
  152:    static void     LCD_Task(event_t events);
  153:    static bool_t   LCD_WriteCmd(bool_t mRegisterSelect, uint8_t dataByte);
  154:    static bool_t   LCD_Write4Bits(uint8_t mData);
  155:    static void     SPI_MasterTxCallback(bool_t status);
  156:    static uint8_t  LCD_GetStrLen(const uint8_t* pString);
  157:    static uint8_t  LCD_LaunchNewCommand(uint8_t eventsPend);
  158:    static lcdLineProcessStatus_t LCD_DisplayTheCurrentLine(uint8_t currLine);
  159:  #endif
  160:  
  161:  
  162:  /******************************************************************************
  163:  *******************************************************************************
  164:  * Public functions 
  165:  *******************************************************************************
  166:  ******************************************************************************/
  167:  
  168:  /*****************************************************************************
  169:  * Function name:          MC1323xRCM_LCD_Init
  170:  *
  171:  * Parameters passed in:   pfLcdCallBack - callback function for notification 
  172:  *                                         when operation has been finished
  173:  * Returned value:         boolean indicating the function status
  174:  *
  175:  * Description:            Function to initalize both the LCD driver and device 
  176:  *****************************************************************************/
  177:  bool_t MC1323xRCM_LCD_Init(void (*pfLcdInitCallBack)(bool_t status))
  178:  {
  179:    #if(TRUE == gLCDSupported_d)
  180:      bool_t retStatus = FALSE;
  181:               
  182:      /* Create the LCD Task */
  183:      gLcdTaskId = TS_CreateTask(gTsLcdTaskPriority_c, LCD_Task);    
  0000 a611     [2]             LDA   #17
  0002 87       [2]             PSHA  
  0003 450000   [3]             LDHX  @LCD_Task
  0006 89       [2]             PSHX  
  0007 8b       [2]             PSHH  
  0008 a600     [2]             LDA   @LCD_Task:PAGE
  000a 87       [2]             PSHA  
  000b ac000000 [8]             CALL  TS_CreateTask
  000f a704     [2]             AIS   #4
  0011 450000   [3]             LDHX  @gLcdTaskId
  0014 f7       [2]             STA   ,X
  184:      
  185:      if(gTsInvalidTaskID_c != gLcdTaskId)
  0015 4f       [1]             CLRA  
  0016 fe       [3]             LDX   ,X
  0017 51ff47   [4]             CBEQX #-1,L61 ;abs = 0061
  186:      {
  187:        /* Prepare the SPI module in master mode */
  188:        mSpiConfig.devMode      = gSPI_MasterMode_c;
  001a 4c       [1]             INCA  
  001b c70000   [4]             STA   mSpiConfig
  189:        mSpiConfig.baudRate     = gSPI_BaudRate_1000000_c;
  001e ae12     [2]             LDX   #18
  0020 cf0001   [4]             STX   mSpiConfig:1
  190:        mSpiConfig.clockPol     = gSPI_ActiveHighPolarity_c;
  0023 5f       [1]             CLRX  
  0024 cf0002   [4]             STX   mSpiConfig:2
  191:        mSpiConfig.clockPhase   = gSPI_EvenEdgeShifting_c;
  0027 cf0003   [4]             STX   mSpiConfig:3
  192:        mSpiConfig.bitwiseShift = gSPI_MsbFirst_c;
  002a cf0004   [4]             STX   mSpiConfig:4
  193:        mSpiConfig.s3Wire       = gSPI_FullDuplex_c;  
  002d c70005   [4]             STA   mSpiConfig:5
  194:                              
  195:        /* Restart the initialization step counter */
  196:        initStep = 0;
  0030 cf0000   [4]             STX   initStep
  197:            
  198:        /* Prepare the E pin to handle the LCD device */
  199:        LCD_DefineEnablePin();  
  0033 1401     [5]             BSET  2,1
  200:        
  201:        /* Keep the E pin as low */
  202:        LCD_Disable();
  0035 1500     [5]             BCLR  2,0
  203:  
  204:        /* First initialization delay (see the ST7920 datasheet) */
  205:        LCD_WaitMilliSec(initWaitTime[initStep]); 
  0037 c60000   [4]             LDA   initWaitTime
  003a ac000000 [8]             CALL  LCD_WaitMilliSec
  206:            
  207:        /* Start the LCD initialization */    
  208:        lcdOperType.mLcdState         = mLcd_State_Init_c;
  003e a601     [2]             LDA   #1
  0040 c70000   [4]             STA   lcdOperType
  209:        lcdOperType.pfLcdInitCallback = pfLcdInitCallBack;
  0043 9efe05   [5]             LDHX  5,SP
  0046 960003   [5]             STHX  lcdOperType:3
  0049 95       [2]             TSX   
  004a e603     [3]             LDA   3,X
  004c c70002   [4]             STA   lcdOperType:2
  210:        lcdOperType.pfLcdCtrlCallback = NULL;
  004f 5f       [1]             CLRX  
  0050 8c       [1]             CLRH  
  0051 960006   [5]             STHX  lcdOperType:6
  0054 cf0005   [4]             STX   lcdOperType:5
  211:                   
  212:        /* Add a new event for the LCD task */
  213:        TS_SendEvent(gLcdTaskId, gLCD_Event_Init_Start_c);  
  0057 c60000   [4]             LDA   gLcdTaskId
  005a 5c       [1]             INCX  
  005b ac000000 [8]             CALL  TS_SendEvent
  214:        
  215:        retStatus = TRUE;      
  216:      }               
  005f a601     [2]             LDA   #1
  0061          L61:    
  217:      
  218:      return retStatus;    
  219:    #else
  220:      (void) pfLcdInitCallBack;
  221:      return FALSE;        
  222:    #endif     
  223:  }
  0061 8d       [7]             RTC   
  224:  
  225:  
  226:  /*****************************************************************************
  227:  * Function name:          MC1323xRCM_LCD_WriteChar
  228:  *
  229:  * Parameters passed in:   chrLine - Display line
  230:  *                         chrPos  - Character position
  231:                            pfCharCallBack - callback function to indicate the  
  232:                                             end of the current character writting  
  233:  * Returned value:         boolean representing the function status
  234:  *
  235:  * Description:            Function to display a char to the LCD
  236:  *****************************************************************************/
  237:  bool_t MC1323xRCM_LCD_WriteChar(uint8_t chrLine, uint8_t chrPos, uint8_t* pChr, void (*pfCharCallBack)(bool_t status))
  238:  {
  0000 8b       [2]             PSHH  
  239:    #if(TRUE == gLCDSupported_d)
  240:      bool_t  retStatus = TRUE;
  0001 a601     [2]             LDA   #1
  0003 95       [2]             TSX   
  0004 f7       [2]             STA   ,X
  241:      uint8_t mLcdNewCmd;
  242:                 
  243:      if((!chrLine) || (chrLine > gLCD_MaxLcdLines_c) || (chrPos > gMAX_LCD_CHARS_c)) 
  0005 6d0a     [4]             TST   10,X
  0007 270c     [3]             BEQ   L15 ;abs = 0015
  0009 e60a     [3]             LDA   10,X
  000b a102     [2]             CMP   #2
  000d 2206     [3]             BHI   L15 ;abs = 0015
  000f e609     [3]             LDA   9,X
  0011 a110     [2]             CMP   #16
  0013 2303     [3]             BLS   L18 ;abs = 0018
  0015          L15:    
  244:      {
  245:        retStatus = FALSE;  
  0015 7f       [4]             CLR   ,X
  246:      }
  0016 2061     [3]             BRA   L79 ;abs = 0079
  0018          L18:    
  247:      else
  248:      {         
  249:        /* Adjust the 'chrLine' to be used as table index */
  250:        chrLine--;      
  0018 6a0a     [5]             DEC   10,X
  251:        
  252:        /* Store the character to display */
  253:        maLcdBuffTable[chrLine][chrPos] = *pChr;
  001a e60a     [3]             LDA   10,X
  001c 62       [1]             NSA   
  001d a4f0     [2]             AND   #-16
  001f eb09     [3]             ADD   9,X
  0021 87       [2]             PSHA  
  0022 4f       [1]             CLRA  
  0023 a900     [2]             ADC   #0
  0025 9efe09   [5]             LDHX  9,SP
  0028 87       [2]             PSHA  
  0029 f6       [3]             LDA   ,X
  002a 8a       [3]             PULH  
  002b 88       [3]             PULX  
  002c d70000   [4]             STA   @maLcdBuffTable,X
  254:                    
  255:        /* Set DDRAM address into the next pending command */
  256:        mLcdNewCmd = gLCD_Set_DDRAM_Addr_c; 
  002f a680     [2]             LDA   #-128
  257:        /* Select the line */
  258:        if(gLCD_SecondLine_c == chrLine)
  0031 95       [2]             TSX   
  0032 ee0a     [3]             LDX   10,X
  0034 a301     [2]             CPX   #1
  0036 2602     [3]             BNE   L3A ;abs = 003a
  259:        {
  260:          mLcdNewCmd |= gLCD_SecondLineAC_c;
  0038 aa10     [2]             ORA   #16
  003a          L3A:    
  261:        }
  262:        /* Select the position */
  263:        mLcdNewCmd |= chrPos;          
  003a 9eea0a   [4]             ORA   10,SP
  264:                
  265:        /* Update the LCD buffer table reference */
  266:        mLcdBuffTableRef[chrLine].mLcdBuffCmd     = mLcdNewCmd; 
  003d 87       [2]             PSHA  
  003e a606     [2]             LDA   #6
  0040 42       [5]             MUL   
  0041 8c       [1]             CLRH  
  0042 97       [1]             TAX   
  0043 86       [3]             PULA  
  0044 d70000   [4]             STA   @mLcdBuffTableRef,X
  267:        mLcdBuffTableRef[chrLine].lcdPos          = chrPos;
  0047 9ee60a   [4]             LDA   10,SP
  004a d70001   [4]             STA   @mLcdBuffTableRef:1,X
  268:        mLcdBuffTableRef[chrLine].buffLen         = gLCD_CharSize_c;
  004d a601     [2]             LDA   #1
  004f d70002   [4]             STA   @mLcdBuffTableRef:2,X
  269:        mLcdBuffTableRef[chrLine].pfBuffCallback  = pfCharCallBack;
  0052 9ee607   [4]             LDA   7,SP
  0055 d70005   [4]             STA   @mLcdBuffTableRef:5,X
  0058 9ee606   [4]             LDA   6,SP
  005b d70004   [4]             STA   @mLcdBuffTableRef:4,X
  005e 9ee605   [4]             LDA   5,SP
  0061 d70003   [4]             STA   @mLcdBuffTableRef:3,X
  270:                            
  271:        /* Update the LCD state and callback */
  272:        lcdOperType.mLcdState         = mLcd_State_Display_c;
  0064 a602     [2]             LDA   #2
  0066 c70000   [4]             STA   lcdOperType
  273:        lcdOperType.pfLcdCtrlCallback = NULL;
  0069 5f       [1]             CLRX  
  006a 960006   [5]             STHX  lcdOperType:6
  006d cf0005   [4]             STX   lcdOperType:5
  274:        
  275:        /* Add the new event for the LCD task */
  276:        TS_SendEvent(gLcdTaskId, gLCD_Event_Display_Start_c);       
  0070 c60000   [4]             LDA   gLcdTaskId
  0073 ae04     [2]             LDX   #4
  0075 ac000000 [8]             CALL  TS_SendEvent
  0079          L79:    
  277:      }      
  278:           
  279:      return retStatus;
  0079 95       [2]             TSX   
  007a f6       [3]             LDA   ,X
  280:    #else
  281:      (void) chrLine;
  282:      (void) chrPos;
  283:      (void) pChr;
  284:      (void) pfCharCallBack;
  285:      
  286:      return TRUE;
  287:    #endif    
  288:  }
  007b 8a       [3]             PULH  
  007c 8d       [7]             RTC   
  289:  
  290:  /*****************************************************************************
  291:  * Function name:          MC1323xRCM_LCD_WriteString
  292:  *
  293:  * Parameters passed in:   lcdLine - Display line
  294:  *                         pStr    - pointer to the first character of the string 
  295:  *                         
  296:  * Returned value:         boolean indicating the status of the function 
  297:  *
  298:  * Description:            This function display a string to the LCD
  299:  *****************************************************************************/
  300:  bool_t MC1323xRCM_LCD_WriteString(uint8_t lcdLine, uint8_t* pStr, void (*pfBuffCallBack)(bool_t status))
  301:  {  
  0000 a7fc     [2]             AIS   #-4
  302:    #if(TRUE == gLCDSupported_d)  
  303:      bool_t             retStatus = TRUE; 
  0002 a601     [2]             LDA   #1
  0004 95       [2]             TSX   
  0005 e703     [3]             STA   3,X
  304:      uint8_t            mLcdNewCmd;  
  305:      lcdBuffTableRef_t* pLcdBuffTableRef; 
  306:           
  307:      if((NULL == pStr) || (!lcdLine) || (lcdLine > gLCD_MaxLcdLines_c))
  0007 9efe0b   [5]             LDHX  11,SP
  000a 270b     [3]             BEQ   L17 ;abs = 0017
  000c 95       [2]             TSX   
  000d 6d0c     [4]             TST   12,X
  000f 2706     [3]             BEQ   L17 ;abs = 0017
  0011 e60c     [3]             LDA   12,X
  0013 a102     [2]             CMP   #2
  0015 2306     [3]             BLS   L1D ;abs = 001d
  0017          L17:    
  308:      {
  309:        retStatus = FALSE;  
  0017 95       [2]             TSX   
  0018 6f03     [5]             CLR   3,X
  310:      }
  001a cc00a5   [4]             JMP   LA5 ;abs = 00a5
  001d          L1D:    
  311:      else
  312:      {                    
  313:        /* Adjust the 'lcdLine' to be used as table index */
  314:        lcdLine--;
  001d 6a0c     [5]             DEC   12,X
  315:              
  316:        /* Clear the current LCD buffer */
  317:        FLib_MemSet(maLcdBuffTable + lcdLine, 0x20, gMAX_LCD_CHARS_c);
  001f e60c     [3]             LDA   12,X
  0021 62       [1]             NSA   
  0022 a4f0     [2]             AND   #-16
  0024 ab00     [2]             ADD   @maLcdBuffTable
  0026 87       [2]             PSHA  
  0027 4f       [1]             CLRA  
  0028 a900     [2]             ADC   @maLcdBuffTable:MSB
  002a 87       [2]             PSHA  
  002b ae20     [2]             LDX   #32
  002d a610     [2]             LDA   #16
  002f ac000000 [8]             CALL  FLib_MemSet
  0033 a702     [2]             AIS   #2
  318:        /* Update the current LCD buffer */
  319:        FLib_MemCpy(maLcdBuffTable + lcdLine, pStr, LCD_GetStrLen(pStr));
  0035 95       [2]             TSX   
  0036 e60c     [3]             LDA   12,X
  0038 62       [1]             NSA   
  0039 a4f0     [2]             AND   #-16
  003b ab00     [2]             ADD   @maLcdBuffTable
  003d f7       [2]             STA   ,X
  003e 4f       [1]             CLRA  
  003f a900     [2]             ADC   @maLcdBuffTable:MSB
  0041 9efe0b   [5]             LDHX  11,SP
  0044 9ee702   [4]             STA   2,SP
  0047 ac000000 [8]             CALL  LCD_GetStrLen
  004b 95       [2]             TSX   
  004c fe       [3]             LDX   ,X
  004d 89       [2]             PSHX  
  004e 95       [2]             TSX   
  004f ee02     [3]             LDX   2,X
  0051 89       [2]             PSHX  
  0052 9efe0d   [5]             LDHX  13,SP
  0055 ac000000 [8]             CALL  FLib_MemCpy
  0059 a702     [2]             AIS   #2
  320:                              
  321:        /* Set DDRAM address into the next pending command */
  322:        mLcdNewCmd = gLCD_Set_DDRAM_Addr_c; 
  005b a680     [2]             LDA   #-128
  005d 95       [2]             TSX   
  005e e702     [3]             STA   2,X
  323:        /* Select the line */
  324:        if(gLCD_SecondLine_c == lcdLine)
  0060 e60c     [3]             LDA   12,X
  0062 4b04     [4]             DBNZA L68 ;abs = 0068
  325:        {
  326:          mLcdNewCmd |= gLCD_SecondLineAC_c;
  0064 a690     [2]             LDA   #-112
  0066 e702     [3]             STA   2,X
  0068          L68:    
  327:        }              
  328:        
  329:        /* Update the information for buffer display operation */     
  330:        pLcdBuffTableRef = mLcdBuffTableRef + lcdLine;
  0068 e60c     [3]             LDA   12,X
  006a ae06     [2]             LDX   #6
  006c 42       [5]             MUL   
  006d ab00     [2]             ADD   @mLcdBuffTableRef
  006f 87       [2]             PSHA  
  0070 4f       [1]             CLRA  
  0071 a900     [2]             ADC   @mLcdBuffTableRef:MSB
  331:        pLcdBuffTableRef->mLcdBuffCmd     = mLcdNewCmd; 
  0073 87       [2]             PSHA  
  0074 95       [2]             TSX   
  0075 e604     [3]             LDA   4,X
  0077 8a       [3]             PULH  
  0078 88       [3]             PULX  
  0079 f7       [2]             STA   ,X
  332:        pLcdBuffTableRef->lcdPos          = 0;     
  007a 6f01     [5]             CLR   1,X
  333:        pLcdBuffTableRef->buffLen         = gMAX_LCD_CHARS_c;
  007c a610     [2]             LDA   #16
  007e e702     [3]             STA   2,X
  334:        pLcdBuffTableRef->pfBuffCallback  = pfBuffCallBack;
  0080 9ee608   [4]             LDA   8,SP
  0083 e703     [3]             STA   3,X
  0085 9ee609   [4]             LDA   9,SP
  0088 e704     [3]             STA   4,X
  008a 9ee60a   [4]             LDA   10,SP
  008d e705     [3]             STA   5,X
  335:                       
  336:        /* Update the LCD state and callback */
  337:        lcdOperType.mLcdState         = mLcd_State_Display_c;
  008f a602     [2]             LDA   #2
  0091 c70000   [4]             STA   lcdOperType
  338:        lcdOperType.pfLcdCtrlCallback = NULL;
  0094 5f       [1]             CLRX  
  0095 8c       [1]             CLRH  
  0096 960006   [5]             STHX  lcdOperType:6
  0099 cf0005   [4]             STX   lcdOperType:5
  339:        
  340:        /* Add a new event for the LCD task */
  341:        TS_SendEvent(gLcdTaskId, gLCD_Event_Display_Start_c);                                       
  009c c60000   [4]             LDA   gLcdTaskId
  009f ae04     [2]             LDX   #4
  00a1 ac000000 [8]             CALL  TS_SendEvent
  00a5          LA5:    
  342:      }    
  343:          
  344:      return retStatus;  
  00a5 95       [2]             TSX   
  00a6 e603     [3]             LDA   3,X
  345:    #else
  346:      (void) lcdLine;
  347:      (void) pStr;
  348:      (void) pfBuffCallBack;
  349:      
  350:      return TRUE;
  351:    #endif    
  352:  }
  00a8 a704     [2]             AIS   #4
  00aa 8d       [7]             RTC   
  353:  
  354:  /*****************************************************************************
  355:  * Function name:          MC1323xRCM_LCD_ClearDisplay
  356:  *
  357:  * Parameters passed in:   pfCallBack - callback function for notification 
  358:  *                                      when operation has been finished
  359:  * Returned value:         None
  360:  *
  361:  * Description:            Function to clear the display
  362:  *****************************************************************************/
  363:  void MC1323xRCM_LCD_ClearDisplay(void (*pfLcdCtrlCallBack)(bool_t status))
  364:  {
  365:    #if(TRUE == gLCDSupported_d)  
  366:      
  367:      /* Update the LCD operation structure */     
  368:      lcdOperType.mLcdState         = mLcd_State_Control_c;
  0000 a603     [2]             LDA   #3
  0002 c70000   [4]             STA   lcdOperType
  369:      lcdOperType.mLcdCtrlCmd       = gLCD_ClearCtrl_c;
  0005 44       [1]             LSRA  
  0006 c70001   [4]             STA   lcdOperType:1
  370:      lcdOperType.pfLcdCtrlCallback = pfLcdCtrlCallBack;
  0009 9efe05   [5]             LDHX  5,SP
  000c 960006   [5]             STHX  lcdOperType:6
  000f 95       [2]             TSX   
  0010 e603     [3]             LDA   3,X
  0012 c70005   [4]             STA   lcdOperType:5
  371:                 
  372:      /* Record the new event for the LCD task */
  373:      TS_SendEvent(gLcdTaskId, gLCD_Event_Control_Start_c);    
  0015 c60000   [4]             LDA   gLcdTaskId
  0018 ae02     [2]             LDX   #2
  001a 8c       [1]             CLRH  
  001b ac000000 [8]             CALL  TS_SendEvent
  374:      
  375:    #else
  376:      (void) pfLcdCtrlCallBack;        
  377:    #endif    
  378:  }
  001f 8d       [7]             RTC   
  379:  
  380:  /*****************************************************************************
  381:  * Function name:          MC1323xRCM_LCD_DisplayOn
  382:  *
  383:  * Parameters passed in:   cursorOn - cursor is On/Off
  384:  *                         chaBlink - character is blinking or not
  385:  *                         pfLcdCtrlCallBack - pointer to the function to indicate
  386:  *                         the end of the clear operation 
  387:  * Returned value:         None
  388:  *
  389:  * Description:            Function to put the display on
  390:  *****************************************************************************/
  391:  void MC1323xRCM_LCD_DisplayOn(bool_t cursorOn, bool_t charBlink, void (*pfLcdCtrlCallBack)(bool_t status))
  392:  {
  393:    #if(TRUE == gLCDSupported_d)
  394:      uint8_t mLcdNewCmd;
  395:         
  396:      /* Prepare the next pending command */         
  397:      mLcdNewCmd = (gLCD_DisplayCtrl_c | gLCD_DisplayOnBit_c);
  398:      if(gLCD_CursorOn_c == cursorOn)
  0000 a60c     [2]             LDA   #12
  0002 95       [2]             TSX   
  0003 ee07     [3]             LDX   7,X
  0005 5b02     [4]             DBNZX L9 ;abs = 0009
  399:      {
  400:        mLcdNewCmd |= gLCD_CursorOnBit_c;
  0007 aa02     [2]             ORA   #2
  0009          L9:     
  401:      }
  402:      
  403:      if(gLCD_CharBlinkOn_c == charBlink) 
  0009 95       [2]             TSX   
  000a ee06     [3]             LDX   6,X
  000c 5b02     [4]             DBNZX L10 ;abs = 0010
  404:      {
  405:        mLcdNewCmd |= gLCD_CharBlinkBit_c;
  000e aa01     [2]             ORA   #1
  0010          L10:    
  406:      }
  407:          
  408:      /* Update the LCD operation structure */      
  409:      lcdOperType.mLcdState         = mLcd_State_Control_c;
  0010 ae03     [2]             LDX   #3
  0012 cf0000   [4]             STX   lcdOperType
  410:      lcdOperType.mLcdCtrlCmd       = mLcdNewCmd;
  0015 c70001   [4]             STA   lcdOperType:1
  411:      lcdOperType.pfLcdCtrlCallback = pfLcdCtrlCallBack;
  0018 9efe05   [5]             LDHX  5,SP
  001b 960006   [5]             STHX  lcdOperType:6
  001e 95       [2]             TSX   
  001f e603     [3]             LDA   3,X
  0021 c70005   [4]             STA   lcdOperType:5
  412:                
  413:      /* Add the new event for the LCD task */
  414:      TS_SendEvent(gLcdTaskId, gLCD_Event_Control_Start_c);       
  0024 c60000   [4]             LDA   gLcdTaskId
  0027 ae02     [2]             LDX   #2
  0029 8c       [1]             CLRH  
  002a ac000000 [8]             CALL  TS_SendEvent
  415:  
  416:    #else
  417:      (void) cursorOn;
  418:      (void) charBlink;
  419:      (void) pfLcdCtrlCallBack;        
  420:    #endif    
  421:  }
  002e 8d       [7]             RTC   
  422:  
  423:  /*****************************************************************************
  424:  * Function name:          MC1323xRCM_LCD_DisplayOff
  425:  *
  426:  * Parameters passed in:   pfLcdCtrlCallBack - callback function for notification 
  427:  *                                      when operation has been finished
  428:  * 
  429:  * Returned value:         None
  430:  *
  431:  * Description:            Function puts the display off; the content of lines are
  432:  *                         kept  
  433:  *****************************************************************************/
  434:  void MC1323xRCM_LCD_DisplayOff(void (*pfLcdCtrlCallBack)(bool_t status))
  435:  {
  436:    #if(TRUE == gLCDSupported_d)        
  437:    
  438:      /* Update the LCD operation structure */     
  439:      lcdOperType.mLcdState         = mLcd_State_Control_c;
  0000 a603     [2]             LDA   #3
  0002 c70000   [4]             STA   lcdOperType
  440:      lcdOperType.mLcdCtrlCmd       = gLCD_DisplayCtrl_c;    
  0005 a608     [2]             LDA   #8
  0007 c70001   [4]             STA   lcdOperType:1
  441:      lcdOperType.pfLcdCtrlCallback = pfLcdCtrlCallBack;
  000a 9efe05   [5]             LDHX  5,SP
  000d 960006   [5]             STHX  lcdOperType:6
  0010 95       [2]             TSX   
  0011 e603     [3]             LDA   3,X
  0013 c70005   [4]             STA   lcdOperType:5
  442:               
  443:      /* Send event to the LCD Task */
  444:      TS_SendEvent(gLcdTaskId, gLCD_Event_Control_Start_c);        
  0016 c60000   [4]             LDA   gLcdTaskId
  0019 ae02     [2]             LDX   #2
  001b 8c       [1]             CLRH  
  001c ac000000 [8]             CALL  TS_SendEvent
  445:      
  446:    #else
  447:      (void) pfLcdCtrlCallBack;        
  448:    #endif    
  449:  }
  0020 8d       [7]             RTC   
  450:  
  451:  
  452:  /*****************************************************************************
  453:  * Function name:          MC1323xRCM_LCD_ReturnHome
  454:  *
  455:  * Parameters passed in:   pfLcdCtrlCallBack - callback function for notification 
  456:  *                                      when operation has been finished
  457:  * Returned value:         None
  458:  *
  459:  * Description:            This function will move the cursor to the first 
  460:  *                         position of the display
  461:  *****************************************************************************/
  462:  void MC1323xRCM_LCD_ReturnHome(void (*pfLcdCtrlCallBack)(bool_t status))
  463:  {
  464:    #if(TRUE == gLCDSupported_d)
  465:  
  466:      /* Update the LCD operation structure */      
  467:      lcdOperType.mLcdState         = mLcd_State_Control_c;
  0000 a603     [2]             LDA   #3
  0002 c70000   [4]             STA   lcdOperType
  468:      lcdOperType.mLcdCtrlCmd       = gLCD_HomeCtrl_C;
  0005 4a       [1]             DECA  
  0006 c70001   [4]             STA   lcdOperType:1
  469:      lcdOperType.pfLcdCtrlCallback = pfLcdCtrlCallBack;
  0009 9efe05   [5]             LDHX  5,SP
  000c 960006   [5]             STHX  lcdOperType:6
  000f 95       [2]             TSX   
  0010 e603     [3]             LDA   3,X
  0012 c70005   [4]             STA   lcdOperType:5
  470:               
  471:      /* Send event to the LCD Task */
  472:      TS_SendEvent(gLcdTaskId, gLCD_Event_Control_Start_c);  
  0015 c60000   [4]             LDA   gLcdTaskId
  0018 ae02     [2]             LDX   #2
  001a 8c       [1]             CLRH  
  001b ac000000 [8]             CALL  TS_SendEvent
  473:  
  474:    #else
  475:      (void) pfLcdCtrlCallBack;          
  476:    #endif     
  477:  }
  001f 8d       [7]             RTC   
  478:  
  479:  #if(TRUE == gLCDSupported_d)
  480:    /*****************************************************************************
  481:    * Function name:          LCD_WaitMilliSec
  482:    *
  483:    * Parameters pasqed in:   timeInMilliSec - time duration in milliseconds
  484:    * Returned value:         None
  485:    *
  486:    * Description:            Function used to wait a number of miliseconds
  487:    *****************************************************************************/
  488:    static void LCD_WaitMilliSec(uint8_t timeInMilliSeconds)
  489:    {   
  0000 87       [2]             PSHA  
  0001 8b       [2]             PSHH  
  490:      uint8_t dec;
  491:      uint8_t dec1;
  492:     
  493:      while(timeInMilliSeconds--)
  0002 2017     [3]             BRA   L1B ;abs = 001b
  0004          L4:     
  494:      {
  495:        dec1 = 100;
  0004 a664     [2]             LDA   #100
  0006 95       [2]             TSX   
  0007 f7       [2]             STA   ,X
  496:        while(dec1--)
  0008 2007     [3]             BRA   L11 ;abs = 0011
  000a          LA:     
  497:        {
  498:          dec = gSystemClock_d*10;
  000a a6a0     [2]             LDA   #-96
  000c          LC:     
  499:          while(dec--);
  000c 97       [1]             TAX   
  000d 4a       [1]             DECA  
  000e 5d       [1]             TSTX  
  000f 26fb     [3]             BNE   LC ;abs = 000c
  0011          L11:    
  0011 95       [2]             TSX   
  0012 f6       [3]             LDA   ,X
  0013 97       [1]             TAX   
  0014 4a       [1]             DECA  
  0015 9ee701   [4]             STA   1,SP
  0018 5d       [1]             TSTX  
  0019 26ef     [3]             BNE   LA ;abs = 000a
  001b          L1B:    
  001b 95       [2]             TSX   
  001c e601     [3]             LDA   1,X
  001e 97       [1]             TAX   
  001f 4a       [1]             DECA  
  0020 9ee702   [4]             STA   2,SP
  0023 5d       [1]             TSTX  
  0024 26de     [3]             BNE   L4 ;abs = 0004
  500:        }  
  501:      }  
  502:    }
  0026 a702     [2]             AIS   #2
  0028 8d       [7]             RTC   
  503:  
  504:  
  505:    /*****************************************************************************
  506:    * Function name:          LCD_WaitMicroSec
  507:    *
  508:    * Parameters passed in:   timeInMicroSec - time duration in microseconds
  509:    * Returned value:         None
  510:    *
  511:    * Description:            Function used to wait a number of microseconds
  512:    ****************************************************************************/
  513:    static void LCD_WaitMicroSec(uint8_t timeInMicroSeconds)
  514:    {   
  0000 87       [2]             PSHA  
  515:      uint8_t dec;
  516:         
  517:      while(timeInMicroSeconds--)
  0001 2007     [3]             BRA   LA ;abs = 000a
  0003          L3:     
  518:      {
  519:        dec = gSystemClock_d;
  0003 a610     [2]             LDA   #16
  0005          L5:     
  520:        while(dec--);
  0005 97       [1]             TAX   
  0006 4a       [1]             DECA  
  0007 5d       [1]             TSTX  
  0008 26fb     [3]             BNE   L5 ;abs = 0005
  000a          LA:     
  000a 95       [2]             TSX   
  000b f6       [3]             LDA   ,X
  000c 97       [1]             TAX   
  000d 4a       [1]             DECA  
  000e 9ee701   [4]             STA   1,SP
  0011 5d       [1]             TSTX  
  0012 26ef     [3]             BNE   L3 ;abs = 0003
  521:      }  
  522:    }
  0014 8a       [3]             PULH  
  0015 8d       [7]             RTC   
  523:  
  524:  
  525:    /*****************************************************************************
  526:    * Function name:          LCD_GetStrLen
  527:    *
  528:    * Parameters passed in:   pString - pointer to the start of the string
  529:    * Returned value:         lenght of the string
  530:    *
  531:    * Description:            This function gets the length of a string and return it 
  532:    *****************************************************************************/
  533:    static uint8_t LCD_GetStrLen(const uint8_t* pString)
  534:    {  
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  535:      uint8_t length = 0; 
  536:      
  537:      while((*pString != '\0') && (length < gMAX_LCD_CHARS_c))
  0002 4f       [1]             CLRA  
  0003 2007     [3]             BRA   LC ;abs = 000c
  0005          L5:     
  538:      {
  539:        length++;
  0005 4c       [1]             INCA  
  540:        pString++;
  0006 95       [2]             TSX   
  0007 6c01     [5]             INC   1,X
  0009 2601     [3]             BNE   LC ;abs = 000c
  000b 7c       [4]             INC   ,X
  000c          LC:     
  000c 9efe01   [5]             LDHX  1,SP
  000f 7d       [3]             TST   ,X
  0010 2706     [3]             BEQ   L18 ;abs = 0018
  0012 a110     [2]             CMP   #16
  0014 2402     [3]             BCC   L18 ;abs = 0018
  0016 20ed     [3]             BRA   L5 ;abs = 0005
  0018          L18:    
  541:      }
  542:      
  543:      return length;  
  544:    }
  0018 a702     [2]             AIS   #2
  001a 8d       [7]             RTC   
  545:  
  546:  
  547:    /*****************************************************************************
  548:    * Function name:          LCD_WriteCmd
  549:    *
  550:    * Parameters passed in:   mRegisterSelect - instruction/data selection operation
  551:    *                         dataByte - byte to be send
  552:    * Returned value:         boolean indicating the function status
  553:    *
  554:    * Description:            Function write a command via the SPI to the LCD 
  555:    *****************************************************************************/
  556:    static bool_t LCD_WriteCmd(bool_t mRegisterSelect, uint8_t dataByte)
  557:    {      
  0000 87       [2]             PSHA  
  558:      bool_t retStatus = TRUE;
  559:         
  560:      /* Prepare the upper 4-bits and lower 4-bits */
  561:      lcdInstrCode.mLcdUpperNibble = gLCD_GetUpperNibble(dataByte); 
  0001 a4f0     [2]             AND   #-16
  0003 62       [1]             NSA   
  0004 a40f     [2]             AND   #15
  0006 c70000   [4]             STA   lcdInstrCode
  562:      lcdInstrCode.mLcdLowerNibble = gLCD_GetLowerNibble(dataByte);
  0009 9ee601   [4]             LDA   1,SP
  000c a40f     [2]             AND   #15
  000e c70001   [4]             STA   lcdInstrCode:1
  563:      
  564:      if(gLCD_CmdRsWrite_c == mRegisterSelect)
  0011 5b0d     [4]             DBNZX L20 ;abs = 0020
  565:      {
  566:        lcdInstrCode.mLcdUpperNibble |= (1<<4);
  0013 450000   [3]             LDHX  @lcdInstrCode
  0016 f6       [3]             LDA   ,X
  0017 aa10     [2]             ORA   #16
  0019 f7       [2]             STA   ,X
  567:        lcdInstrCode.mLcdLowerNibble |= (1<<4); 
  001a e601     [3]             LDA   1,X
  001c aa10     [2]             ORA   #16
  001e e701     [3]             STA   1,X
  0020          L20:    
  568:      }
  569:      lcdInstrCode.lcdWriteCmdStep = 0;
  0020 4f       [1]             CLRA  
  0021 c70002   [4]             STA   lcdInstrCode:2
  570:      
  571:      /* Initiate the upper 4-bits transmission */
  572:      retStatus = LCD_Write4Bits(lcdInstrCode.mLcdUpperNibble);
  0024 c60000   [4]             LDA   lcdInstrCode
  0027 ac000000 [8]             CALL  LCD_Write4Bits
  573:        
  574:      return retStatus; 
  575:    }
  002b 8a       [3]             PULH  
  002c 8d       [7]             RTC   
  576:  
  577:  
  578:  
  579:    /*****************************************************************************
  580:    * Function name:          LCD_Write4Bits
  581:    *
  582:    * Parameters passed in:   mData - data to be sent via SPI
  583:    * Returned value:         boolean indicating the status of the SPI operation
  584:    *
  585:    * Description:            Function to send the the half byte form the command
  586:    *****************************************************************************/
  587:    static bool_t LCD_Write4Bits(uint8_t mData)
  588:    {    
  0000 87       [2]             PSHA  
  589:      bool_t retStatus;
  590:      static uint8_t spiData;
  591:      
  592:      /* Apply the specific configuration to the SPI module */
  593:      /* The configuration is done here in order to be sure that no other 
  594:         application routine affect the SPI communication */
  595:      SPI_SetConfig(mSpiConfig);
  0001 a7fa     [2]             AIS   #-6
  0003 95       [2]             TSX   
  0004 89       [2]             PSHX  
  0005 8b       [2]             PSHH  
  0006 450000   [3]             LDHX  @mSpiConfig
  0009 a606     [2]             LDA   #6
  000b cd0000   [6]             JSR   _COPY
  000e ac000000 [8]             CALL  SPI1_SetConfig
  0012 a706     [2]             AIS   #6
  596:      
  597:      spiData = mData;
  0014 95       [2]             TSX   
  0015 f6       [3]             LDA   ,X
  0016 c70000   [4]             STA   spiData
  598:      retStatus = SPI_MasterTransmit(&spiData, gLCD_CharSize_c, SPI_MasterTxCallback);
  0019 450000   [3]             LDHX  @spiData
  001c 89       [2]             PSHX  
  001d 8b       [2]             PSHH  
  001e a601     [2]             LDA   #1
  0020 87       [2]             PSHA  
  0021 450000   [3]             LDHX  @SPI_MasterTxCallback
  0024 89       [2]             PSHX  
  0025 8b       [2]             PSHH  
  0026 a600     [2]             LDA   @SPI_MasterTxCallback:PAGE
  0028 87       [2]             PSHA  
  0029 ac000000 [8]             CALL  SPI1_MasterTransmit
  002d a706     [2]             AIS   #6
  599:      
  600:      return retStatus; 
  601:    }
  002f 8a       [3]             PULH  
  0030 8d       [7]             RTC   
  602:     
  603:  
  604:    /******************************************************************************
  605:    * Function name:          SPI_MasterTxCallback
  606:    *
  607:    * Parameters passed in:   boolean indicating the status of the SPI operation
  608:    * Returned value:         None 
  609:    *
  610:    * Description:            SPI Master Transmit callback function, indicating the 
  611:    *                         end of the SPI operation      
  612:    ******************************************************************************/
  613:    static void SPI_MasterTxCallback(bool_t status)
  614:    {     
  0000 87       [2]             PSHA  
  615:      uint8_t dummyEvent; 
  616:              
  617:      /* Prepare the event to the LCD_Task */
  618:      if(TRUE == status)
  0001 4b08     [4]             DBNZA LB ;abs = 000b
  619:      {
  620:        /* LCD pin E asserted */
  621:        LCD_Enable();
  0003 1400     [5]             BSET  2,0
  622:        
  623:        /* Store the event */
  624:        dummyEvent = gLCD_Event_Wr4bits_Success_c;
  0005 ae10     [2]             LDX   #16
  625:                                 
  626:        /* LCD pin E deasserted */
  627:        LCD_Disable();
  0007 1500     [5]             BCLR  2,0
  628:      }
  0009 2007     [3]             BRA   L12 ;abs = 0012
  000b          LB:     
  629:      else
  630:      {
  631:        if(FALSE == status)
  000b 9e6d01   [5]             TST   1,SP
  000e 2602     [3]             BNE   L12 ;abs = 0012
  632:        {
  633:          dummyEvent = gLCD_Event_Wr4bits_Fail_c; 
  634:        }
  635:      }
  0010 ae08     [2]             LDX   #8
  0012          L12:    
  636:      
  637:      /* Send event to the LCD Task */
  638:      TS_SendEvent(gLcdTaskId, dummyEvent);    
  0012 c60000   [4]             LDA   gLcdTaskId
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
  639:    }
  001a 8a       [3]             PULH  
  001b 8d       [7]             RTC   
  640:  
  641:    /*****************************************************************************
  642:    * Function name:          LCD_Task
  643:    *
  644:    * Parameters passed in:   events - LCD task's event
  645:    * Returned value:         None
  646:    *
  647:    * Description:            LCD task function
  648:    *****************************************************************************/
  649:    static void LCD_Task(event_t events)
  650:    {           
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  651:      static uint8_t eventsPending, eventCleared; 
  652:      uint8_t timeWait;
  653:          
  654:      /* Store the current events into the pending list */
  655:      eventsPending |= events;         
  0002 450000   [3]             LDHX  @eventsPending
  0005 f6       [3]             LDA   ,X
  0006 9eea02   [4]             ORA   2,SP
  0009 f7       [2]             STA   ,X
  656:                                   
  657:      if(eventsPending & gLCD_Event_Wr4bits_Fail_c)
  000a a508     [2]             BIT   #8
  000c 275c     [3]             BEQ   L6A ;abs = 006a
  658:      {
  659:        /* Clear the current processing event */
  660:        eventsPending &= ~gLCD_Event_Wr4bits_Fail_c; 
  000e a4f7     [2]             AND   #-9
  0010 c70000   [4]             STA   eventsPending
  661:        
  662:        /* The initialization step is most prioritar; any fail on this, should be 
  663:           signaled to the application and further initiative should be invalidated */
  664:        if(initStep < gLCD_MaxInitSteps_c)
  0013 c60000   [4]             LDA   initStep
  0016 a10a     [2]             CMP   #10
  0018 2428     [3]             BCC   L42 ;abs = 0042
  665:        {
  666:          if(lcdOperType.pfLcdInitCallback)
  001a 450002   [3]             LDHX  @lcdOperType:2
  001d cd0000   [6]             JSR   _CMP24_RC
  0020 00               DC.B  0
  0021 0000             DC.W  0
  0023 2716     [3]             BEQ   L3B ;abs = 003b
  0025          L25:    
  667:          {
  668:            (*(lcdOperType.pfLcdInitCallback))(FALSE); 
  0025 320003   [5]             LDHX  lcdOperType:3
  0028 4f       [1]             CLRA  
  0029 8b       [2]             PSHH  
  002a 8b       [2]             PSHH  
  002b 87       [2]             PSHA  
  002c c60002   [4]             LDA   lcdOperType:2
  002f ac000000 [8]             CALL  _CALL_STAR08_FAR
  669:            lcdOperType.pfLcdInitCallback = NULL;          
  0033 5f       [1]             CLRX  
  0034 8c       [1]             CLRH  
  0035 960003   [5]             STHX  lcdOperType:3
  0038 cf0002   [4]             STX   lcdOperType:2
  003b          L3B:    
  670:          }
  671:            
  672:          /* New LCD status: IDLE */
  673:          lcdOperType.mLcdState = mLcd_State_Idle_c;          
  674:        }
  675:        else
  676:        { /* Initialization already done */        
  677:          /* Check if there is any pending command */
  678:          if(eventsPending & gLCD_Event_WrCmd_Start_c)
  679:          {
  680:            /* Initiate the new command */
  681:            eventCleared = LCD_LaunchNewCommand(eventsPending);          
  682:            
  683:            /* Clear the current processing event */
  684:            eventsPending &= ~eventCleared;                                                  
  685:          }
  686:          else
  687:          { /* No pending command */
  688:            /* Call the callback function with status false */
  689:            if(lcdOperType.pfLcdCtrlCallback)
  690:            {
  691:              (*(lcdOperType.pfLcdCtrlCallback))(FALSE); 
  692:              /* Invalidate the callback */
  693:              lcdOperType.pfLcdCtrlCallback = NULL;             
  694:            }
  695:              
  696:            /* New LCD status: IDLE */
  697:            lcdOperType.mLcdState = mLcd_State_Idle_c;          
  698:          }        
  699:        } /* End if(initStep < gLCD_MaxInitSteps_c) */     
  700:      }
  701:      else
  702:      { 
  703:        /* Check if the previous SPI has been successfully done */
  704:        if(eventsPending & gLCD_Event_Wr4bits_Success_c)
  705:        {
  706:          /* Clear the current procesing event */
  707:          eventsPending &= ~gLCD_Event_Wr4bits_Success_c;
  708:          
  709:          /* Upper 4-bit nibble sent successfully */
  710:          if(++(lcdInstrCode.lcdWriteCmdStep) == gLCD_InstrExec_Partially_c)
  711:          {                            
  712:            /* Initiate the lower 4 bits transmission */
  713:            if(FALSE == LCD_Write4Bits(lcdInstrCode.mLcdLowerNibble))
  714:            {
  715:              /* Second lower 4 bits SPI operation: FAILED */
  716:              /* If the Init has failed then signals this to the 
  717:                 application and invalidates any further initatives */
  718:              if(initStep < gLCD_MaxInitSteps_c)
  719:              {                
  720:                if(lcdOperType.pfLcdInitCallback)
  721:                {
  722:                  (*(lcdOperType.pfLcdInitCallback))(FALSE);     
  723:                  /* Invalidate the callback */
  724:                  lcdOperType.pfLcdInitCallback = NULL;             
  725:                }
  726:                  
  727:                /* New LCD status: IDLE */
  728:                lcdOperType.mLcdState = mLcd_State_Idle_c;                        
  729:              }
  730:              else
  731:              {
  732:                /* Check for the new pending command */
  733:                if(eventsPending & gLCD_Event_WrCmd_Start_c)
  734:                {
  735:                  /* Initiate the new command */
  736:                  eventCleared = LCD_LaunchNewCommand(eventsPending);                
  737:                  
  738:                  /* Clear the current procesing event */
  739:                  eventsPending &= ~eventCleared;                                
  740:                }
  741:                else
  742:                { /* No pending command */
  743:                  /* Call the control callback function with status false */
  744:                  if(lcdOperType.pfLcdCtrlCallback)
  745:                  {
  746:                    (*(lcdOperType.pfLcdCtrlCallback))(FALSE);
  747:                    /* Invalidate the callback */
  748:                    lcdOperType.pfLcdCtrlCallback = NULL;                   
  749:                  }
  750:                    
  751:                  /* New LCD status: IDLE */
  752:                  lcdOperType.mLcdState = mLcd_State_Idle_c;                   
  753:                }              
  754:              } /* End: if(initStep < gLCD_MaxInitSteps_c) */                        
  755:            }
  756:          }
  757:          else
  758:          {
  759:            if(lcdInstrCode.lcdWriteCmdStep == gLCD_InstrExec_Complete_c)
  760:            { /* A 10 bit complete instruction has been sent */
  761:              /* The init operation is most prioritar and any further commands 
  762:                 should still pending until the init is finished */
  763:              if(initStep < gLCD_MaxInitSteps_c)
  764:              {                                       
  765:                /* Still process the initialization step */               
  766:                if(++initStep < gLCD_MaxInitSteps_c)
  767:                {                                
  768:                  timeWait = initWaitTime[initStep];
  769:                  if((initStep == (gLCD_MaxInitSteps_c - 1)) || (initStep == (gLCD_MaxInitSteps_c >> 1)))                   
  770:                  {
  771:                    LCD_WaitMilliSec(timeWait); 
  772:                  }
  773:                  else
  774:                  {
  775:                    LCD_WaitMicroSec(timeWait);                  
  776:                  }
  777:                                  
  778:                  if(FALSE == LCD_WriteCmd(gLCD_CmdRsRead_c, initCmdList[initStep]))
  779:                  {
  780:                    if(lcdOperType.pfLcdInitCallback)
  781:                    {
  782:                      /* Call the init callback function with status FALSE */
  783:                      (*(lcdOperType.pfLcdInitCallback))(FALSE);
  784:                      /* Invalidates the callback pointer */
  785:                      lcdOperType.pfLcdInitCallback = NULL;
  786:                    }
  787:                  
  788:                    lcdOperType.mLcdState = mLcd_State_Idle_c;
  789:                  }                              
  790:                }
  791:                else
  792:                {
  793:                  /* Initialization end */
  794:                  /* Wait for the last instruction */
  795:                  LCD_WaitMicroSec(gLCD_Wait150uSec_c);
  796:  
  797:                  /* Call the init callback */
  798:                  if(lcdOperType.pfLcdInitCallback)
  799:                  {
  800:                    /* Call the init callback function with status TRUE */
  801:                    (*(lcdOperType.pfLcdInitCallback))(TRUE);
  802:                    /* Invalidate the callback pointer */ 
  803:                    lcdOperType.pfLcdInitCallback = NULL;                              
  804:                  }                                               
  805:                                  
  806:                  if(lcdOperType.mLcdState == mLcd_State_Init_c)
  807:                  {
  808:                    lcdOperType.mLcdState = mLcd_State_Idle_c;   
  809:                  }
  810:                  else
  811:                  {
  812:                    /* It's possible that during initialization, a new command may occur */ 
  813:                    /* Check if there is a new pending command in order to don't lose it */
  814:                    if(eventsPending & gLCD_Event_WrCmd_Start_c)
  815:                    {
  816:                      /* Initiate the new command */
  817:                      eventCleared = LCD_LaunchNewCommand(eventsPending);
  818:                      
  819:                      /* Clear the current procesing event */
  820:                      eventsPending &= ~eventCleared;                                                   
  821:                    }
  822:                  }                
  823:                }
  824:              }
  825:              else
  826:              { /* Initialization has done */                            
  827:                /* Check if there is a new pending command */              
  828:                if(eventsPending & gLCD_Event_WrCmd_Start_c)
  829:                {
  830:                  /* A new command has been required; if the command is from init or from control, then launch the pending command */
  831:                  /* If the command is a display requirement, then check if there is any line display in progress; if there is one  
  832:                     and the display command is for this line, then restart displaying by launching that command pending, otherwise 
  833:                     continue with the current display operation */
  834:                               
  835:                  /* The LCD device (CFAG12832AYGHN) requires 1 msec. between consecutive commands */
  836:                  LCD_WaitMilliSec(1);
  837:                  
  838:                  /* Either the initialization has been restarted or a new control command is required */                               
  839:                  if((!initStep) || lcdOperType.mLcdCtrlCmd)
  840:                  {
  841:                    /* Initiate the new command */
  842:                    eventCleared = LCD_LaunchNewCommand(eventsPending);                 
  843:                    
  844:                    /* Clear the current procesing event */
  845:                    eventsPending &= ~eventCleared;                  
  846:                  }
  847:                  else
  848:                  {
  849:                    if(!(mLcdBuffTableRef[gLCD_FirstLine_c].mLcdBuffCmd) && mLcdBuffTableRef[gLCD_FirstLine_c].buffLen) 
  850:                    {
  851:                      (void)LCD_DisplayTheCurrentLine(gLCD_FirstLine_c); 
  852:                    }
  853:                    else
  854:                    {
  855:                      if(!(mLcdBuffTableRef[gLCD_SecondLine_c].mLcdBuffCmd) && mLcdBuffTableRef[gLCD_SecondLine_c].buffLen)
  856:                      {
  857:                        (void)LCD_DisplayTheCurrentLine(gLCD_SecondLine_c);
  858:                      }
  859:                      else
  860:                      {
  861:                        /* Initiate the new command */
  862:                        eventCleared = LCD_LaunchNewCommand(gLCD_Event_Display_Start_c);                 
  863:                  
  864:                        /* Clear the current procesing event */
  865:                        eventsPending &= ~eventCleared;                         
  866:                      }
  867:                    }                  
  868:                  }                                                           
  869:                }
  870:                else
  871:                { /* No command pending */
  872:                  /* Work in the current LCD operation state */
  873:                  if(lcdOperType.mLcdState == mLcd_State_Control_c)
  874:                  {
  875:                    /* The control operation */
  876:                    if(lcdOperType.pfLcdCtrlCallback)
  877:                    {
  878:                      (*(lcdOperType.pfLcdCtrlCallback))(TRUE);
  879:                      lcdOperType.pfLcdCtrlCallback = NULL;                    
  880:                    }
  881:                    
  882:                    /* New LCD status: IDLE */
  883:                    lcdOperType.mLcdState = mLcd_State_Idle_c;                          
  884:                  }
  885:                  else
  886:                  {
  887:                    if(lcdOperType.mLcdState == mLcd_State_Display_c)
  888:                    {
  889:                      /* The display operation */
  890:                      /* Process the lcd strings to display */
  891:                      /* Process first line buffer string */                    
  892:                      
  893:                      
  894:                      if(!(mLcdBuffTableRef[gLCD_FirstLine_c].mLcdBuffCmd)) 
  895:                      { 
  896:                        /* Check if the first line buffer processing has finished */
  897:                        if(mLcd_LineProcess_Finished_c ==  LCD_DisplayTheCurrentLine(gLCD_FirstLine_c))
  898:                        {                                             
  899:                          /* The first line buffer display process has finished, consequently check the status 
  900:                             of the second line buffer display operation; if there is a start to display then 
  901:                             launch the display command otherwise continue with processing the string  */
  902:                          if(mLcdBuffTableRef[gLCD_SecondLine_c].mLcdBuffCmd)
  903:                          {
  904:                            /* Start to process the second line buffer string */ 
  905:                            (void)LCD_LaunchNewCommand(gLCD_Event_Display_Start_c);                                                  
  906:                          } 
  907:                          else
  908:                          {
  909:                            /* Continue tranmsitting buffer string on the second line */
  910:                            /* If there is nothing to display, the function will return a status to notify this case */
  911:                            if(mLcd_LineProcess_Finished_c == LCD_DisplayTheCurrentLine(gLCD_SecondLine_c))
  912:                            {
  913:                              /* Check if there is any pending command */
  914:                              if(eventsPending & gLCD_Event_WrCmd_Start_c)
  915:                              {
  916:                                /* Initiate the new command */
  917:                                eventCleared = LCD_LaunchNewCommand(eventsPending);                                  
  918:                              
  919:                                /* Clear the current processing event */
  920:                                eventsPending &= ~eventCleared;                                                                          
  921:                              }
  922:                              else
  923:                              {
  924:                                /* No request pending; switch the LCD status to IDLE */
  925:                                /* New LCD status: IDLE */
  926:                                lcdOperType.mLcdState = mLcd_State_Idle_c;                         
  003b 4f       [1]             CLRA  
  003c c70000   [4]             STA   lcdOperType
  003f cc014d   [4]             JMP   L14D ;abs = 014d
  0042          L42:    
  0042 c60000   [4]             LDA   eventsPending
  0045 a507     [2]             BIT   #7
  0047 2702     [3]             BEQ   L4B ;abs = 004b
  0049 205b     [3]             BRA   LA6 ;abs = 00a6
  004b          L4B:    
  004b 450005   [3]             LDHX  @lcdOperType:5
  004e cd0000   [6]             JSR   _CMP24_RC
  0051 00               DC.B  0
  0052 0000             DC.W  0
  0054          L54:    
  0054 27e5     [3]             BEQ   L3B ;abs = 003b
  0056 320006   [5]             LDHX  lcdOperType:6
  0059 4f       [1]             CLRA  
  005a 8b       [2]             PSHH  
  005b 8b       [2]             PSHH  
  005c 87       [2]             PSHA  
  005d c60005   [4]             LDA   lcdOperType:5
  0060 ac000000 [8]             CALL  _CALL_STAR08_FAR
  0064 ac000212 [8]             CALL  LCD_Task:530
  0068          L68:    
  0068 20d1     [3]             BRA   L3B ;abs = 003b
  006a          L6A:    
  006a a510     [2]             BIT   #16
  006c 2603     [3]             BNE   L71 ;abs = 0071
  006e cc01fe   [4]             JMP   L1FE ;abs = 01fe
  0071          L71:    
  0071 a4ef     [2]             AND   #-17
  0073 c70000   [4]             STA   eventsPending
  0076 450002   [3]             LDHX  @lcdInstrCode:2
  0079 7c       [4]             INC   ,X
  007a c60002   [4]             LDA   lcdInstrCode:2
  007d 4b49     [4]             DBNZA LC8 ;abs = 00c8
  007f c60001   [4]             LDA   lcdInstrCode:1
  0082 ac000000 [8]             CALL  LCD_Write4Bits
  0086 4d       [1]             TSTA  
  0087 267e     [3]             BNE   L107 ;abs = 0107
  0089 c60000   [4]             LDA   initStep
  008c a10a     [2]             CMP   #10
  008e 240f     [3]             BCC   L9F ;abs = 009f
  0090 450002   [3]             LDHX  @lcdOperType:2
  0093 cd0000   [6]             JSR   _CMP24_RC
  0096 00               DC.B  0
  0097 0000             DC.W  0
  0099 268a     [3]             BNE   L25 ;abs = 0025
  009b 209e     [3]             BRA   L3B ;abs = 003b
  009d          L9D:    
  009d 2086     [3]             BRA   L25 ;abs = 0025
  009f          L9F:    
  009f c60000   [4]             LDA   eventsPending
  00a2 a507     [2]             BIT   #7
  00a4 2703     [3]             BEQ   LA9 ;abs = 00a9
  00a6          LA6:    
  00a6 cc014f   [4]             JMP   L14F ;abs = 014f
  00a9          LA9:    
  00a9 450005   [3]             LDHX  @lcdOperType:5
  00ac cd0000   [6]             JSR   _CMP24_RC
  00af 00               DC.B  0
  00b0 0000             DC.W  0
  00b2 2787     [3]             BEQ   L3B ;abs = 003b
  00b4 320006   [5]             LDHX  lcdOperType:6
  00b7 4f       [1]             CLRA  
  00b8 8b       [2]             PSHH  
  00b9 8b       [2]             PSHH  
  00ba 87       [2]             PSHA  
  00bb c60005   [4]             LDA   lcdOperType:5
  00be ac000000 [8]             CALL  _CALL_STAR08_FAR
  00c2 ac000212 [8]             CALL  LCD_Task:530
  00c6          LC6:    
  00c6 20a0     [3]             BRA   L68 ;abs = 0068
  00c8          LC8:    
  00c8 c60002   [4]             LDA   lcdInstrCode:2
  00cb a102     [2]             CMP   #2
  00cd 2638     [3]             BNE   L107 ;abs = 0107
  00cf c60000   [4]             LDA   initStep
  00d2 a10a     [2]             CMP   #10
  00d4 247b     [3]             BCC   L151 ;abs = 0151
  00d6 450000   [3]             LDHX  @initStep
  00d9 7c       [4]             INC   ,X
  00da c60000   [4]             LDA   initStep
  00dd a10a     [2]             CMP   #10
  00df 2436     [3]             BCC   L117 ;abs = 0117
  00e1 8c       [1]             CLRH  
  00e2 97       [1]             TAX   
  00e3 d60000   [4]             LDA   @initWaitTime,X
  00e6 ce0000   [4]             LDX   initStep
  00e9 510904   [4]             CBEQX #9,LF0 ;abs = 00f0
  00ec a305     [2]             CPX   #5
  00ee 2606     [3]             BNE   LF6 ;abs = 00f6
  00f0          LF0:    
  00f0 ac000000 [8]             CALL  LCD_WaitMilliSec
  00f4 2004     [3]             BRA   LFA ;abs = 00fa
  00f6          LF6:    
  00f6 ac000000 [8]             CALL  LCD_WaitMicroSec
  00fa          LFA:    
  00fa ce0000   [4]             LDX   initStep
  00fd 8c       [1]             CLRH  
  00fe d60000   [4]             LDA   @initCmdList,X
  0101 5f       [1]             CLRX  
  0102 ac000000 [8]             CALL  LCD_WriteCmd
  0106 4d       [1]             TSTA  
  0107          L107:   
  0107 2673     [3]             BNE   L17C ;abs = 017c
  0109 450002   [3]             LDHX  @lcdOperType:2
  010c cd0000   [6]             JSR   _CMP24_RC
  010f 00               DC.B  0
  0110 0000             DC.W  0
  0112 2689     [3]             BNE   L9D ;abs = 009d
  0114          L114:   
  0114 cc0054   [4]             JMP   L54 ;abs = 0054
  0117          L117:   
  0117 a696     [2]             LDA   #-106
  0119 ac000000 [8]             CALL  LCD_WaitMicroSec
  011d 450002   [3]             LDHX  @lcdOperType:2
  0120 cd0000   [6]             JSR   _CMP24_RC
  0123 00               DC.B  0
  0124 0000             DC.W  0
  0126 2717     [3]             BEQ   L13F ;abs = 013f
  0128 320003   [5]             LDHX  lcdOperType:3
  012b a601     [2]             LDA   #1
  012d 8b       [2]             PSHH  
  012e 8b       [2]             PSHH  
  012f 87       [2]             PSHA  
  0130 c60002   [4]             LDA   lcdOperType:2
  0133 ac000000 [8]             CALL  _CALL_STAR08_FAR
  0137 5f       [1]             CLRX  
  0138 8c       [1]             CLRH  
  0139 960003   [5]             STHX  lcdOperType:3
  013c cf0002   [4]             STX   lcdOperType:2
  013f          L13F:   
  013f c60000   [4]             LDA   lcdOperType
  0142 a101     [2]             CMP   #1
  0144          L144:   
  0144 27ce     [3]             BEQ   L114 ;abs = 0114
  0146 c60000   [4]             LDA   eventsPending
  0149 a507     [2]             BIT   #7
  014b 2645     [3]             BNE   L192 ;abs = 0192
  014d          L14D:   
  014d 203f     [3]             BRA   L18E ;abs = 018e
  014f          L14F:   
  014f 2041     [3]             BRA   L192 ;abs = 0192
  0151          L151:   
  0151 c60000   [4]             LDA   eventsPending
  0154 a507     [2]             BIT   #7
  0156 273c     [3]             BEQ   L194 ;abs = 0194
  0158 a601     [2]             LDA   #1
  015a ac000000 [8]             CALL  LCD_WaitMilliSec
  015e c60000   [4]             LDA   initStep
  0161 2705     [3]             BEQ   L168 ;abs = 0168
  0163 c60001   [4]             LDA   lcdOperType:1
  0166 2705     [3]             BEQ   L16D ;abs = 016d
  0168          L168:   
  0168 c60000   [4]             LDA   eventsPending
  016b 207a     [3]             BRA   L1E7 ;abs = 01e7
  016d          L16D:   
  016d c60000   [4]             LDA   mLcdBuffTableRef
  0170 260c     [3]             BNE   L17E ;abs = 017e
  0172 c60002   [4]             LDA   mLcdBuffTableRef:2
  0175 2707     [3]             BEQ   L17E ;abs = 017e
  0177 4f       [1]             CLRA  
  0178 ac000000 [8]             CALL  LCD_DisplayTheCurrentLine
  017c          L17C:   
  017c 2010     [3]             BRA   L18E ;abs = 018e
  017e          L17E:   
  017e c60006   [4]             LDA   mLcdBuffTableRef:6
  0181 260d     [3]             BNE   L190 ;abs = 0190
  0183 c60008   [4]             LDA   mLcdBuffTableRef:8
  0186 2708     [3]             BEQ   L190 ;abs = 0190
  0188 a601     [2]             LDA   #1
  018a ac000000 [8]             CALL  LCD_DisplayTheCurrentLine
  018e          L18E:   
  018e 206c     [3]             BRA   L1FC ;abs = 01fc
  0190          L190:   
  0190 a604     [2]             LDA   #4
  0192          L192:   
  0192 206e     [3]             BRA   L202 ;abs = 0202
  0194          L194:   
  0194 c60000   [4]             LDA   lcdOperType
  0197 a103     [2]             CMP   #3
  0199 2621     [3]             BNE   L1BC ;abs = 01bc
  019b 450005   [3]             LDHX  @lcdOperType:5
  019e cd0000   [6]             JSR   _CMP24_RC
  01a1 00               DC.B  0
  01a2 0000             DC.W  0
  01a4 279e     [3]             BEQ   L144 ;abs = 0144
  01a6 320006   [5]             LDHX  lcdOperType:6
  01a9 a601     [2]             LDA   #1
  01ab 8b       [2]             PSHH  
  01ac 8b       [2]             PSHH  
  01ad 87       [2]             PSHA  
  01ae c60005   [4]             LDA   lcdOperType:5
  01b1 ac000000 [8]             CALL  _CALL_STAR08_FAR
  01b5 ac000212 [8]             CALL  LCD_Task:530
  01b9          L1B9:   
  01b9 cc00c6   [4]             JMP   LC6 ;abs = 00c6
  01bc          L1BC:   
  01bc c60000   [4]             LDA   lcdOperType
  01bf a102     [2]             CMP   #2
  01c1 264c     [3]             BNE   L20F ;abs = 020f
  01c3 c60000   [4]             LDA   mLcdBuffTableRef
  01c6 2621     [3]             BNE   L1E9 ;abs = 01e9
  01c8 4f       [1]             CLRA  
  01c9 ac000000 [8]             CALL  LCD_DisplayTheCurrentLine
  01cd 4b40     [4]             DBNZA L20F ;abs = 020f
  01cf c60006   [4]             LDA   mLcdBuffTableRef:6
  01d2 2622     [3]             BNE   L1F6 ;abs = 01f6
  01d4 a601     [2]             LDA   #1
  01d6 ac000000 [8]             CALL  LCD_DisplayTheCurrentLine
  01da a101     [2]             CMP   #1
  01dc 2631     [3]             BNE   L20F ;abs = 020f
  01de c60000   [4]             LDA   eventsPending
  01e1 a507     [2]             BIT   #7
  01e3 261d     [3]             BNE   L202 ;abs = 0202
  01e5 20d2     [3]             BRA   L1B9 ;abs = 01b9
  01e7          L1E7:   
  01e7 2019     [3]             BRA   L202 ;abs = 0202
  01e9          L1E9:   
  927:                              }                                               
  928:                            }
  929:                          }                        
  930:                        }
  931:                      }
  932:                      else
  933:                      {
  934:                        /* Check if the second line has finished to send data */
  935:                        if(!(mLcdBuffTableRef[gLCD_SecondLine_c].mLcdBuffCmd))
  01e9 c60006   [4]             LDA   mLcdBuffTableRef:6
  01ec 2621     [3]             BNE   L20F ;abs = 020f
  936:                        {
  937:                          if(mLcd_LineProcess_Finished_c == LCD_DisplayTheCurrentLine(gLCD_SecondLine_c))
  01ee a601     [2]             LDA   #1
  01f0 ac000000 [8]             CALL  LCD_DisplayTheCurrentLine
  01f4 4b19     [4]             DBNZA L20F ;abs = 020f
  01f6          L1F6:   
  938:                          {
  939:                            /* The second line has finished sending data, consequently it is allowed to start displaying the first line */
  940:                            (void)LCD_LaunchNewCommand(gLCD_Event_Display_Start_c);                             
  01f6 a604     [2]             LDA   #4
  01f8 ac000000 [8]             CALL  LCD_LaunchNewCommand
  01fc          L1FC:   
  01fc 2011     [3]             BRA   L20F ;abs = 020f
  01fe          L1FE:   
  941:                          }
  942:                        }
  943:                      }                                                                                                                                                                      
  944:                    }
  945:                  }
  946:                }              
  947:              }                                    
  948:            }
  949:          }
  950:        }
  951:        else
  952:        {
  953:          /* Process a new freshed command */
  954:          if(eventsPending & gLCD_Event_WrCmd_Start_c)
  01fe a507     [2]             BIT   #7
  0200 270d     [3]             BEQ   L20F ;abs = 020f
  0202          L202:   
  955:          {
  956:            /* Initiate the new command */
  957:            eventCleared = LCD_LaunchNewCommand(eventsPending);             
  0202 ac000000 [8]             CALL  LCD_LaunchNewCommand
  0206 c70000   [4]             STA   eventCleared
  958:            
  959:            /* Clear the current procesing event */
  960:            eventsPending &= ~eventCleared;                            
  0209 43       [1]             COMA  
  020a 450000   [3]             LDHX  @eventsPending
  020d f4       [3]             AND   ,X
  020e f7       [2]             STA   ,X
  020f          L20F:   
  961:          }        
  962:        }
  963:      }          
  964:    } 
  020f a702     [2]             AIS   #2
  0211 8d       [7]             RTC   
  0212          L212:   
  0212 5f       [1]             CLRX  
  0213 8c       [1]             CLRH  
  0214 960006   [5]             STHX  lcdOperType:6
  0217 cf0005   [4]             STX   lcdOperType:5
  021a 8d       [7]             RTC   
  965:  
  966:  
  967:    /*****************************************************************************
  968:    * Function name:          LCD_LaunchNewCommand
  969:    *
  970:    * Parameters passed in:   list of events pending
  971:    * Returned value:         None
  972:    *
  973:    * Description:            Launch a new command to the LCD driver
  974:    *****************************************************************************/
  975:    static uint8_t LCD_LaunchNewCommand(uint8_t eventsPend)
  976:    {          
  0000 a7f8     [2]             AIS   #-8
  977:      uint8_t mLcdNewCommand, callbackType;
  978:      void (*pfNewCallback)(bool_t status);
  979:      uint8_t retEvent = 0;
  0002 95       [2]             TSX   
  0003 6f03     [5]             CLR   3,X
  980:      lcdBuffTableRef_t* pLcdBuffTableRef;
  981:           
  982:      if(!initStep)
  0005 ce0000   [4]             LDX   initStep
  0008 2618     [3]             BNE   L22 ;abs = 0022
  983:      {    
  984:        mLcdNewCommand  = initCmdList[initStep];
  000a 8c       [1]             CLRH  
  000b d60000   [4]             LDA   @initCmdList,X
  000e 95       [2]             TSX   
  000f e704     [3]             STA   4,X
  985:        pfNewCallback   = lcdOperType.pfLcdInitCallback;
  0011 320003   [5]             LDHX  lcdOperType:3
  0014 9eff02   [5]             STHX  2,SP
  0017 c60002   [4]             LDA   lcdOperType:2
  001a 95       [2]             TSX   
  001b f7       [2]             STA   ,X
  986:        callbackType    = 0;
  001c 6f05     [5]             CLR   5,X
  987:        
  988:        retEvent = gLCD_Event_Init_Start_c;
  001e a601     [2]             LDA   #1
  989:      }
  0020 2062     [3]             BRA   L84 ;abs = 0084
  0022          L22:    
  990:      else
  991:      {
  992:        if(eventsPend & gLCD_Event_Control_Start_c)
  0022 a502     [2]             BIT   #2
  0024 271d     [3]             BEQ   L43 ;abs = 0043
  993:        {
  994:          mLcdNewCommand  = lcdOperType.mLcdCtrlCmd; 
  0026 c60001   [4]             LDA   lcdOperType:1
  0029 95       [2]             TSX   
  002a e704     [3]             STA   4,X
  995:          pfNewCallback   = lcdOperType.pfLcdCtrlCallback;
  002c 320006   [5]             LDHX  lcdOperType:6
  002f 9eff02   [5]             STHX  2,SP
  0032 c60005   [4]             LDA   lcdOperType:5
  0035 95       [2]             TSX   
  0036 f7       [2]             STA   ,X
  996:          callbackType    = 1;
  0037 a601     [2]             LDA   #1
  0039 e705     [3]             STA   5,X
  997:          
  998:          /* Clear the current control command */
  999:          lcdOperType.mLcdCtrlCmd = 0; 
  003b 4f       [1]             CLRA  
  003c c70001   [4]             STA   lcdOperType:1
 1000:          
 1001:          retEvent = gLCD_Event_Control_Start_c;
  003f a602     [2]             LDA   #2
 1002:        }
  0041 2041     [3]             BRA   L84 ;abs = 0084
  0043          L43:    
 1003:        else
 1004:        {
 1005:          if(eventsPend & gLCD_Event_Display_Start_c)
  0043 a504     [2]             BIT   #4
  0045 2740     [3]             BEQ   L87 ;abs = 0087
 1006:          {
 1007:            /* Decide which line should be started to display */
 1008:            pLcdBuffTableRef = mLcdBuffTableRef + gLCD_FirstLine_c; 
  0047 450000   [3]             LDHX  @mLcdBuffTableRef
  004a 9eff07   [5]             STHX  7,SP
 1009:            if(pLcdBuffTableRef->mLcdBuffCmd)
  004d 7d       [3]             TST   ,X
  004e 2714     [3]             BEQ   L64 ;abs = 0064
 1010:            { /* Line 0 */
 1011:              /* Store the display command then clear it from the pending list */
 1012:              mLcdNewCommand  = pLcdBuffTableRef->mLcdBuffCmd;
  0050 f6       [3]             LDA   ,X
  0051 9ee705   [4]             STA   5,SP
 1013:              pLcdBuffTableRef->mLcdBuffCmd = 0;
  0054 7f       [4]             CLR   ,X
 1014:              
 1015:              pfNewCallback = pLcdBuffTableRef->pfBuffCallback;
  0055 e603     [3]             LDA   3,X
  0057 9ee701   [4]             STA   1,SP
  005a 9ece04   [5]             LDHX  4,X
  005d 9eff02   [5]             STHX  2,SP
 1016:              callbackType  = 2;
  0060 a602     [2]             LDA   #2
 1017:            }
  0062 201b     [3]             BRA   L7F ;abs = 007f
  0064          L64:    
 1018:            else
 1019:            {
 1020:              pLcdBuffTableRef = mLcdBuffTableRef + gLCD_SecondLine_c; 
  0064 450006   [3]             LDHX  @mLcdBuffTableRef:6
  0067 9eff07   [5]             STHX  7,SP
 1021:              if(pLcdBuffTableRef->mLcdBuffCmd)
  006a 7d       [3]             TST   ,X
  006b 2715     [3]             BEQ   L82 ;abs = 0082
 1022:              { /* Line 1 */
 1023:                /* Store the display command then clear it from the pending list */
 1024:                mLcdNewCommand  = pLcdBuffTableRef->mLcdBuffCmd;
  006d f6       [3]             LDA   ,X
  006e 9ee705   [4]             STA   5,SP
 1025:                pLcdBuffTableRef->mLcdBuffCmd = 0;
  0071 7f       [4]             CLR   ,X
 1026:                
 1027:                pfNewCallback = pLcdBuffTableRef->pfBuffCallback; 
  0072 e603     [3]             LDA   3,X
  0074 9ee701   [4]             STA   1,SP
  0077 9ece04   [5]             LDHX  4,X
  007a 9eff02   [5]             STHX  2,SP
 1028:                callbackType  = 3;           
  007d a603     [2]             LDA   #3
  007f          L7F:    
  007f 95       [2]             TSX   
  0080 e705     [3]             STA   5,X
  0082          L82:    
 1029:              }
 1030:            }
 1031:            
 1032:            retEvent = gLCD_Event_Display_Start_c; 
  0082 a604     [2]             LDA   #4
  0084          L84:    
  0084 95       [2]             TSX   
  0085 e703     [3]             STA   3,X
  0087          L87:    
 1033:          }        
 1034:        }    
 1035:      }
 1036:  
 1037:      if(FALSE == LCD_WriteCmd(gLCD_CmdRsRead_c, mLcdNewCommand))
  0087 5f       [1]             CLRX  
  0088 9ee605   [4]             LDA   5,SP
  008b ac000000 [8]             CALL  LCD_WriteCmd
  008f 4d       [1]             TSTA  
  0090 264e     [3]             BNE   LE0 ;abs = 00e0
 1038:      { /* New command has failed */
 1039:        /* Call the callback function with status false */
 1040:        if(pfNewCallback)
  0092 95       [2]             TSX   
  0093 cd0000   [6]             JSR   _CMP24_RC
  0096 00               DC.B  0
  0097 0000             DC.W  0
  0099 2741     [3]             BEQ   LDC ;abs = 00dc
 1041:        {
 1042:          (*(pfNewCallback))(FALSE);
  009b 9efe02   [5]             LDHX  2,SP
  009e 4f       [1]             CLRA  
  009f 8b       [2]             PSHH  
  00a0 8b       [2]             PSHH  
  00a1 87       [2]             PSHA  
  00a2 9ee604   [4]             LDA   4,SP
  00a5 ac000000 [8]             CALL  _CALL_STAR08_FAR
 1043:          
 1044:          /* Invalidate the callback pointer */
 1045:          switch(callbackType)
  00a9 95       [2]             TSX   
  00aa e605     [3]             LDA   5,X
  00ac a103     [2]             CMP   #3
  00ae 222c     [3]             BHI   LDC ;abs = 00dc
  00b0 4d       [1]             TSTA  
  00b1 270c     [3]             BEQ   LBF ;abs = 00bf
  00b3 410113   [4]             CBEQA #1,LC9 ;abs = 00c9
  00b6 41021a   [4]             CBEQA #2,LD3 ;abs = 00d3
  00b9 a103     [2]             CMP   #3
  00bb 261f     [3]             BNE   LDC ;abs = 00dc
  00bd 2014     [3]             BRA   LD3 ;abs = 00d3
  00bf          LBF:    
 1046:          {
 1047:            case 0:
 1048:                    lcdOperType.pfLcdInitCallback = NULL;
  00bf 5f       [1]             CLRX  
  00c0 8c       [1]             CLRH  
  00c1 960003   [5]             STHX  lcdOperType:3
  00c4 cf0002   [4]             STX   lcdOperType:2
 1049:                    break;
  00c7 2013     [3]             BRA   LDC ;abs = 00dc
  00c9          LC9:    
 1050:            case 1:
 1051:                    lcdOperType.pfLcdCtrlCallback = NULL;
  00c9 5f       [1]             CLRX  
  00ca 8c       [1]             CLRH  
  00cb 960006   [5]             STHX  lcdOperType:6
  00ce cf0005   [4]             STX   lcdOperType:5
 1052:                    break;
  00d1 2009     [3]             BRA   LDC ;abs = 00dc
  00d3          LD3:    
 1053:            case 2:
 1054:                    pLcdBuffTableRef->pfBuffCallback = NULL;
 1055:                    break;
 1056:            case 3:
 1057:                    pLcdBuffTableRef->pfBuffCallback = NULL;
  00d3 9efe07   [5]             LDHX  7,SP
  00d6 6f03     [5]             CLR   3,X
  00d8 6f04     [5]             CLR   4,X
  00da 6f05     [5]             CLR   5,X
  00dc          LDC:    
 1058:                    break;
 1059:          }                                     
 1060:        }
 1061:              
 1062:        /* New LCD status: IDLE */
 1063:        lcdOperType.mLcdState = mLcd_State_Idle_c;  
  00dc 4f       [1]             CLRA  
  00dd c70000   [4]             STA   lcdOperType
  00e0          LE0:    
 1064:      }
 1065:      
 1066:      return retEvent; 
  00e0 95       [2]             TSX   
  00e1 e603     [3]             LDA   3,X
 1067:    }
  00e3 a708     [2]             AIS   #8
  00e5 8d       [7]             RTC   
 1068:  
 1069:  
 1070:    /*****************************************************************************
 1071:    * Function name:          LCD_DisplayTheCurrentLine
 1072:    *
 1073:    * Parameters passed in:   currLine - the current line to be displayed
 1074:    * Returned value:         mLcd_LineProcess_OnGoing_c - there are character left 
 1075:    *                           to be displayed on the specified line
 1076:    *                         mLcd_LineProcess_Finished_c - no character left to be 
 1077:    *                           displayed and the callback associated to that buffer 
 1078:    *                           is serviced (if there is defined)
 1079:    *
 1080:    * Description:            Display the information on the current line 
 1081:    *****************************************************************************/
 1082:    static lcdLineProcessStatus_t LCD_DisplayTheCurrentLine(uint8_t currLine)
 1083:    {                                  
  0000 87       [2]             PSHA  
  0001 a7fc     [2]             AIS   #-4
 1084:      lcdLineProcessStatus_t procStatus;
 1085:      lcdBuffTableRef_t* pLcdBuffTableRef;
 1086:      
 1087:      /* Assure that you are touching the correct struct element */
 1088:      if(currLine > gLCD_SecondLine_c)
  0003 a101     [2]             CMP   #1
  0005 2305     [3]             BLS   LC ;abs = 000c
 1089:      {
 1090:        currLine = gLCD_SecondLine_c; 
  0007 a601     [2]             LDA   #1
  0009 95       [2]             TSX   
  000a e704     [3]             STA   4,X
  000c          LC:     
 1091:      }
 1092:      
 1093:      pLcdBuffTableRef = mLcdBuffTableRef + currLine;  
  000c 95       [2]             TSX   
  000d e604     [3]             LDA   4,X
  000f ae06     [2]             LDX   #6
  0011 42       [5]             MUL   
  0012 ab00     [2]             ADD   @mLcdBuffTableRef
  0014 95       [2]             TSX   
  0015 f7       [2]             STA   ,X
  0016 4f       [1]             CLRA  
  0017 a900     [2]             ADC   @mLcdBuffTableRef:MSB
  0019 87       [2]             PSHA  
  001a fe       [3]             LDX   ,X
  001b 8a       [3]             PULH  
  001c 9eff02   [5]             STHX  2,SP
 1094:      /* Process the current LCD line strings to display */
 1095:      if(pLcdBuffTableRef->buffLen)                                 
  001f 6d02     [4]             TST   2,X
  0021 275b     [3]             BEQ   L7E ;abs = 007e
 1096:      {                               
 1097:        if(FALSE == LCD_WriteCmd(gLCD_CmdRsWrite_c, maLcdBuffTable[currLine][pLcdBuffTableRef->lcdPos])) 
  0023 9ee605   [4]             LDA   5,SP
  0026 62       [1]             NSA   
  0027 a4f0     [2]             AND   #-16
  0029 9eee01   [4]             LDX   1,SP
  002c 87       [2]             PSHA  
  002d e601     [3]             LDA   1,X
  002f 97       [1]             TAX   
  0030 86       [3]             PULA  
  0031 89       [2]             PSHX  
  0032 95       [2]             TSX   
  0033 fb       [3]             ADD   ,X
  0034 f7       [2]             STA   ,X
  0035 4f       [1]             CLRA  
  0036 a900     [2]             ADC   #0
  0038 87       [2]             PSHA  
  0039 8a       [3]             PULH  
  003a 88       [3]             PULX  
  003b d60000   [4]             LDA   @maLcdBuffTable,X
  003e ae01     [2]             LDX   #1
  0040 ac000000 [8]             CALL  LCD_WriteCmd
  0044 4d       [1]             TSTA  
  0045 262b     [3]             BNE   L72 ;abs = 0072
 1098:        {
 1099:          /* Call the current line buffer callback */
 1100:          if(pLcdBuffTableRef->pfBuffCallback)
  0047 9efe02   [5]             LDHX  2,SP
  004a af03     [2]             AIX   #3
  004c cd0000   [6]             JSR   _CMP24_RC
  004f 00               DC.B  0
  0050 0000             DC.W  0
  0052 271e     [3]             BEQ   L72 ;abs = 0072
 1101:          {                              
 1102:            (*(pLcdBuffTableRef->pfBuffCallback))(FALSE);
  0054 9efe02   [5]             LDHX  2,SP
  0057 e603     [3]             LDA   3,X
  0059 9ece04   [5]             LDHX  4,X
  005c 87       [2]             PSHA  
  005d 4f       [1]             CLRA  
  005e 8b       [2]             PSHH  
  005f 8b       [2]             PSHH  
  0060 87       [2]             PSHA  
  0061 9ee604   [4]             LDA   4,SP
  0064 ac000000 [8]             CALL  _CALL_STAR08_FAR
 1103:            /* Invalidates the current line buffer callback pointer */
 1104:            pLcdBuffTableRef->pfBuffCallback = NULL;
  0068 9efe03   [5]             LDHX  3,SP
  006b 6f03     [5]             CLR   3,X
  006d 6f04     [5]             CLR   4,X
  006f 6f05     [5]             CLR   5,X
  0071 8a       [3]             PULH  
  0072          L72:    
 1105:          }                        
 1106:        }
 1107:                   
 1108:        /* Decrement the buffer length */
 1109:        pLcdBuffTableRef->buffLen--;
  0072 9efe02   [5]             LDHX  2,SP
  0075 6a02     [5]             DEC   2,X
 1110:        
 1111:        /* Increment the current byte position into string */
 1112:        pLcdBuffTableRef->lcdPos++;
  0077 6c01     [5]             INC   1,X
 1113:        
 1114:        /* Prepare the return status */
 1115:        procStatus = mLcd_LineProcess_OnGoing_c;
  0079 95       [2]             TSX   
  007a 6f03     [5]             CLR   3,X
 1116:      }
  007c 2031     [3]             BRA   LAF ;abs = 00af
  007e          L7E:    
 1117:      else
 1118:      {
 1119:        /* Call the current line buffer callback with status TRUE */
 1120:        if(pLcdBuffTableRef->pfBuffCallback)                       
  007e 9efe02   [5]             LDHX  2,SP
  0081 af03     [2]             AIX   #3
  0083 cd0000   [6]             JSR   _CMP24_RC
  0086 00               DC.B  0
  0087 0000             DC.W  0
  0089 271f     [3]             BEQ   LAA ;abs = 00aa
 1121:        {
 1122:          (*(pLcdBuffTableRef->pfBuffCallback))(TRUE);
  008b 9efe02   [5]             LDHX  2,SP
  008e e603     [3]             LDA   3,X
  0090 9ece04   [5]             LDHX  4,X
  0093 87       [2]             PSHA  
  0094 a601     [2]             LDA   #1
  0096 8b       [2]             PSHH  
  0097 8b       [2]             PSHH  
  0098 87       [2]             PSHA  
  0099 9ee604   [4]             LDA   4,SP
  009c ac000000 [8]             CALL  _CALL_STAR08_FAR
 1123:          /* Invalidates the current line buffer callback pointer */
 1124:          pLcdBuffTableRef->pfBuffCallback = NULL;                         
  00a0 9efe03   [5]             LDHX  3,SP
  00a3 6f03     [5]             CLR   3,X
  00a5 6f04     [5]             CLR   4,X
  00a7 6f05     [5]             CLR   5,X
  00a9 8a       [3]             PULH  
  00aa          LAA:    
 1125:        }
 1126:        
 1127:        /* Prepare the return status */
 1128:        procStatus = mLcd_LineProcess_Finished_c; 
  00aa a601     [2]             LDA   #1
  00ac 95       [2]             TSX   
  00ad e703     [3]             STA   3,X
  00af          LAF:    
 1129:      }
 1130:      
 1131:      return procStatus;             
  00af e603     [3]             LDA   3,X
 1132:    }
  00b1 a705     [2]             AIS   #5
  00b3 8d       [7]             RTC   
 1133:  #endif  
 1134:  
 1135:    
