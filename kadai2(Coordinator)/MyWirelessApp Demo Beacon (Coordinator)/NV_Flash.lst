*** EVALUATION ***
ANSI-C/cC++ Compiler for HC08 V-5.0.41 Build 12319, Nov 15 2012

    1:  /*****************************************************************************
    2:  * Non-volatile storage module local implementation.
    3:  *
    4:  * Copyright (c) 2006, Freescale, Inc. All rights reserved.
    5:  *
    6:  *
    7:  * No part of this document must be reproduced in any form - including copied,
    8:  * transcribed, printed or by any electronic means - without specific written
    9:  * permission from Freescale Semiconductor.
   10:  *
   11:  *****************************************************************************/
   12:  
   13:  #include "EmbeddedTypes.h"
   14:  #include "TS_Interface.h"
   15:  
   16:  #include "NV_FlashHAL.h"
   17:  #include "NV_Flash.h"
   18:  #include "FunctionLib.h"
   19:  
   20:  /*****************************************************************************
   21:  ******************************************************************************
   22:  * Private macros
   23:  ******************************************************************************
   24:  *****************************************************************************/
   25:  
   26:  /* Size of a member of a struct. */
   27:  #ifndef MbrSizeof
   28:  #define MbrSizeof(type, member)     (sizeof(((type *) 0)->member))
   29:  #endif
   30:  
   31:  #define  gNVPageMaxOffset_c  (NvSize_t)( sizeof(NvRawPage_t) - sizeof(NvStructuredPageHeader_t))
   32:  
   33:  /* There must be at least one more flash page than there are data sets, to */
   34:  /* allow for one copy of each data set plus a page for a new copy of one */
   35:  /* data set. */
   36:  #if gNvNumberOfRawPages_c <= gNvNumberOfDataSets_c
   37:  #error
   38:  #endif
   39:  
   40:  /* this macro must reflect the bit used for the idle task defined in BeeApp.c */
   41:  #define gIdleTaskNVIntervalEvent_c  ( 1 << 0 )
   42:  
   43:  
   44:  /*****************************************************************************
   45:  ******************************************************************************
   46:  * Private prototypes
   47:  ******************************************************************************
   48:  *****************************************************************************/
   49:  #if gNvStorageIncluded_d
   50:  static index_t NvDataSetIndexFromID(NvDataSetID_t dataSetID);
   51:  static index_t NvFindDataSet(NvDataSetID_t dataSetID);
   52:  static bool_t NvIsValidDataSet(index_t pageIndex);
   53:  static void NvSaveDataSet(index_t dataSetIndex);
   54:   #if gNvMultiStorageIncluded_d
   55:   static bool_t NvInPageMultiSave( index_t dataSetIndex );
   56:   #endif
   57:  #else
   58:  #define NvDataSetIndexFromID(dataSetID)  0
   59:  #define NvFindDataSet(dataSetID)  0
   60:  #define NvIsValidDataSet(pageIndex)  FALSE
   61:  #define NvSaveDataSet(dataSetIndex)
   62:  #endif /* gNvStorageIncluded_d */
   63:  
   64:  #if gNvSelfTest_d
   65:  static void NvSelfTest(void);
   66:  #endif
   67:  
   68:  /*****************************************************************************
   69:  ******************************************************************************
   70:  * Private type definitions
   71:  ******************************************************************************
   72:  *****************************************************************************/
   73:  
   74:  /* One entry per data set. */
   75:  typedef struct NvDataSetInfo_tag {
   76:    bool_t saveNextInterval;
   77:    NvSaveInterval_t ticksToNextSave;
   78:    NvSaveCounter_t countsToNextSave;
   79:  } NvDataSetInfo_t;
   80:  
   81:  typedef struct NvMultiSavedDataInfo_tag {
   82:    void * pSource;
   83:    NvSize_t sourceLength;
   84:  } NvMultiSavedDataInfo_t;
   85:  
   86:  typedef struct msMarker_tag {
   87:    uint8_t header;
   88:    uint8_t trailer;
   89:  } msMarker_t;
   90:  
   91:  
   92:  /*****************************************************************************
   93:  ******************************************************************************
   94:  * Private memory declarations
   95:  ******************************************************************************
   96:  *****************************************************************************/
   97:  
   98:  #if gNvStorageIncluded_d
   99:  /* Table of dirty flags, one per dataset in NvDataSetDescriptionTable[]. */
  100:  static NvDataSetInfo_t maNvDirtyFlags[gNvNumberOfDataSets_c];
  101:  
  102:  #if gNvMultiStorageIncluded_d
  103:  static  NvMultiSavedDataInfo_t maNvMultiSavedDataInfo[gNvNumberOfDataSets_c];
  104:  #endif
  105:  
  106:  /* Minimum number of calls to NvTimerTick() between saves of a given dataset. */
  107:  NvSaveInterval_t gNvMinimumTicksBetweenSaves = gNvMinimumTicksBetweenSaves_c;
  108:  /* Minimum number of calls to NvSaveOnIdle() between saves of a given dataset. */
  109:  static NvSaveCounter_t gNvCountsBetweenSaves = gNvCountsBetweenSaves_c;
  110:  
  111:  /* If this counter is != 0, do not save to NV Storage. */
  112:  static uint8_t mNvCriticalSectionFlag = 0;
  113:  #endif                                  /* gNvStorageIncluded_d */
  114:  
  115:  /* Scratch data sets used by the internal unit test. */
  116:  #if gNvSelfTest_d
  117:  
  118:  #ifdef  gNvNumberOfDataSets_c
  119:  #undef  gNvNumberOfDataSets_c
  120:  #define gNvNumberOfDataSets_c   3
  121:  #endif
  122:  
  123:  /* Data set 1. */
  124:  static uint8_t NvTestDataArray1[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  125:  static char NvTestDataString1[] = "For months, we have been triumphantly retreating before a demoralized enemy who is advancing in utter disorder.";
  126:  static uint8_t NvTestDataArray2[] = {222, 173, 190, 239, 0, 222, 202, 251, 173, 0};
  127:  
  128:  static NvDataItemDescription_t const gaNvDataSet01[] = {
  129:    {(void *) NvTestDataArray1,  sizeof(NvTestDataArray1)},
  130:    {(void *) NvTestDataString1, sizeof(NvTestDataString1)},
  131:    {(void *) NvTestDataArray2,  sizeof(NvTestDataArray2)},
  132:    {NULL, 0}
  133:  };
  134:  
  135:  /* Data set 2. */
  136:  static uint8_t scratchValue01 = 0x37;
  137:  static NvDataItemDescription_t const gaNvDataSet02[] = {
  138:    {(void *) &scratchValue01, sizeof(scratchValue01)},
  139:    {NULL, 0}
  140:  };
  141:  
  142:  /* Data set 3. Empty. Test this boundry case. */
  143:  static NvDataItemDescription_t const gaNvDataSet03[] = {
  144:    {NULL, 0}
  145:  };
  146:  
  147:  /* Table of data sets. Required by the NV storage module. */
  148:  /* If the NV storage module's self test flag is on, it will */
  149:  /* use it's own internal copy of this table, so it can't be */
  150:  /* defined here. */
  151:  #define gNvDataSet1ID_c     0x17
  152:  #define gNvDataSet2ID_c     0x99
  153:  #define gNvDataSet3ID_c     0x42
  154:  
  155:  static NvDataSetDescription_t const NvDataSetTable[gNvNumberOfDataSets_c] = {
  156:    { gNvDataSet1ID_c, gaNvDataSet01 },
  157:    { gNvDataSet2ID_c, gaNvDataSet02 },
  158:    { gNvDataSet3ID_c, gaNvDataSet03 }
  159:  };
  160:  #endif                                  /* gNvSelfTest_d */
  161:  
  162:  extern bool_t gNVInit;
  163:  
  164:  /*****************************************************************************
  165:  ******************************************************************************
  166:  * Public functions
  167:  ******************************************************************************
  168:  *****************************************************************************/
  169:  
  170:  /* There may be operations that take place over extended times that must
  171:   * be atomic from the point of view of NV Storage saves. These routines
  172:   * increment/decrement a counter; when the counter is non-zero, no NV
  173:   * saves will be done. Note that this does not affect NV restores.
  174:   */
  175:  
  176:  void NvClearCriticalSection(void) {
  177:  #if gNvStorageIncluded_d
  178:    if(mNvCriticalSectionFlag)  /* dg - in case of set/clear mismatch */
  179:      --mNvCriticalSectionFlag;
  180:  #endif /* gNvStorageIncluded_d */
  181:  }
  0000 8d       [7]             RTC   
  182:  
  183:  
  184:  void NvSetCriticalSection(void)
  185:  {
  186:  #if gNvStorageIncluded_d
  187:    ++mNvCriticalSectionFlag;
  188:  #endif /* gNvStorageIncluded_d */
  189:  }
  0000 8d       [7]             RTC   
  190:  
  191:  
  192:  /****************************************************************************/
  193:  
  194:  /* Called from the idle task to process save-on-next-idle and save-on-count. */
  195:  #if gNvStorageIncluded_d
  196:  void NvIdle(void)
  197:  {
  198:    index_t   i;
  199:    bool_t    bNvOperationPerformed = FALSE;
  200:  
  201:    if (mNvCriticalSectionFlag) {
  202:      return;
  203:    }
  204:    for (i = 0; i < gNvNumberOfDataSets_c; ++i) 
  205:    {
  206:    #if gNvMultiStorageIncluded_d
  207:      if( (maNvMultiSavedDataInfo[i].pSource != NULL ) && maNvMultiSavedDataInfo[i].sourceLength ) 
  208:        {
  209:        bNvOperationPerformed = TRUE;
  210:        if( FALSE == NvInPageMultiSave(i) )
  211:          {
  212:          NvSaveOnIdle(NvDataSetTable[i].dataSetID) ;
  213:          maNvMultiSavedDataInfo[i].pSource = NULL;
  214:          maNvMultiSavedDataInfo[i].sourceLength = 0;
  215:          }
  216:        }
  217:     #endif  
  218:    
  219:      if (!maNvDirtyFlags[i].countsToNextSave) 
  220:      {
  221:        NvSaveDataSet(i);
  222:        bNvOperationPerformed = TRUE;
  223:      }
  224:    }
  225:    
  226:    /* Restore the receiver state, if it was closed in order to write information in Flash */
  227:    if(bNvOperationPerformed)
  228:      NvOperationEnd();
  229:  }/* NvIdle() */
  230:  #endif /* gNvStorageIncluded_d */
  231:  
  232:  /****************************************************************************/
  233:  
  234:  /* Return TRUE if the given data set is dirty. */
  235:  #if gNvStorageIncluded_d
  236:  bool_t NvIsDataSetDirty
  237:    (
  238:    NvDataSetID_t dataSetID
  239:   )
  240:  {
  241:    index_t dataSetIndex = NvDataSetIndexFromID(dataSetID);
  242:    return (    maNvDirtyFlags[dataSetIndex].saveNextInterval
  243:            || (maNvDirtyFlags[dataSetIndex].countsToNextSave != gNvCountsBetweenSaves_c));
  244:  }/* NvIsDataSetDirty() */
  245:  #endif /* gNvStorageIncluded_d */
  246:  
  247:  /****************************************************************************/
  248:  
  249:  /* Call this once, before calling any other NV function.
  250:   *
  251:   * Any page that does not contain a valid, recognized data set is erased, in
  252:   * preparation for later reuse.
  253:   *
  254:   * It is unlikely, but possible, that there could be more than one copy of one
  255:   * or more data sets in NV storage. Normally the page containing the older
  256:   * version is erased after the new version is written, but a reset at just
  257:   * the wrong time could prevent the erasure.
  258:   *
  259:   * Having more than one copy of any data set is 1) unnecessary, 2) uses space
  260:   * that may be needed for future writes, and 3) would complicate other NV code.
  261:   * This function scans NV storage for alternate versions of the same data set,
  262:   * and if it finds one, erases the older copy (or copies).
  263:   */
  264:  #if gNvStorageIncluded_d
  265:  void NvModuleInit
  266:  (
  267:  	void
  268:  )
  269:  {
  270:  #if gNvDebug_d
  271:  	NvDataItemDescription_t const *pDataItemDescriptions;
  272:  	index_t dataSetIndex;
  273:  	NvSize_t dataSetSize;
  274:  #endif
  275:  	index_t i;
  276:  	index_t pageIndex;
  277:  	struct seqAndID_tag {
  278:  		NvDataSetID_t id;
  279:  		index_t pageIndex;
  280:  		NvDataSetSequenceNumber_t sequenceNumber;
  281:  	} seqAndID[gNvNumberOfRawPages_c];
  282:  	NvStructuredPageHeader_t *pThisHeader;
  283:  	index_t validDataSetsFound = 0;
  284:  #if gNvDebug_d
  285:  	/* The CodeWarrior HCS08 compiler complains about constant == constant. */
  286:  	uint16_t NvMaxDataSetSize = gNvMaxDataSetSize_c;
  287:  #endif
  288:  
  289:  	/* initialize flash layer */
  290:  	NvHalInit();
  291:  
  292:  	/* No data set starts dirty. */
  293:  	for (i = 0; i < gNvNumberOfDataSets_c; ++i)
  294:  	{
  295:  		maNvDirtyFlags[i].countsToNextSave = gNvCountsBetweenSaves;
  296:  	}
  297:  
  298:  	/* Scan for and erase duplicate copies of data sets. This code is very */
  299:  	/* slow (N^2), but it only runs once, and N is small. Data set IDs are */
  300:  	/* arbitrary values, so its necessary to search through the list. */
  301:  
  302:  	/* Visit every raw page. If it isn't a valid data set, and it isn't clean, */
  303:  	/* erase it. */
  304:  	for (pageIndex = 0; pageIndex < gNvNumberOfRawPages_c; ++pageIndex)
  305:  	{
  306:  		if (!NvIsValidDataSet(pageIndex))
  307:  		{
  308:  			NvHalErasePage(maNvRawPageAddressTable[pageIndex],mNvFlashPageEraseCmd_c);
  309:  		}
  310:  		else
  311:  		{
  312:  			/* Add this one to the list of valid pages we've visited. */
  313:  			pThisHeader = &((NvStructuredPage_t *) maNvRawPageAddressTable[pageIndex])->header;
  314:  			seqAndID[validDataSetsFound].id             = pThisHeader->dataSetID;
  315:  			seqAndID[validDataSetsFound].pageIndex      = pageIndex;
  316:  			seqAndID[validDataSetsFound].sequenceNumber = pThisHeader->sequenceNumber;
  317:  
  318:  			/* Does this page contain the same data set as a page we've already visited? */
  319:  			for (i = 0; i < validDataSetsFound; ++i)
  320:  			{
  321:  				if (seqAndID[i].id == pThisHeader->dataSetID)
  322:  				{
  323:  					/* Erase whichever copy has the older sequence number. */
  324:  					/* Mark the erased page so it's ID will never be == a valid page's ID. */
  325:  					if (seqAndID[i].sequenceNumber - pThisHeader->sequenceNumber == 1)
  326:  					{
  327:  						NvHalErasePage(maNvRawPageAddressTable[pageIndex], mNvFlashPageEraseCmd_c);
  328:  						seqAndID[validDataSetsFound].id = gNvInvalidDataSetID_c;
  329:  					}
  330:  					else
  331:  					{
  332:  						NvHalErasePage(maNvRawPageAddressTable[(seqAndID[i].pageIndex)],
  333:  														mNvFlashPageEraseCmd_c);
  334:  						seqAndID[i].id = gNvInvalidDataSetID_c;
  335:  					}
  336:  				}/* if (seqAndID[i].id == ... */
  337:  			}/* for (i = 0; i < ... */
  338:  
  339:  			++validDataSetsFound;
  340:  		}/* if (!NvIsValidDataSet(... else */
  341:  	}/* for (pageIndex = 0; ... */
  342:  
  343:  #if gNvDebug_d
  344:  	/* NVM_Interface.h defines the size of the client area of a page as an */
  345:  	/* unjustified immediate integer constant. Make sure that its correct. */
  346:  	/* Assert if it isn't. */
  347:  	if (NvMaxDataSetSize != MbrSizeof(NvStructuredPage_t, clientData))
  348:  	{
  349:  		for (;;)
  350:  		{ }
  351:  	}
  352:  
  353:  	/* Verify that all of the data sets defined by the client code will */
  354:  	/* fit into the NV storage page size. Doing this once here simplifies */
  355:  	/* other code. */
  356:  	for (dataSetIndex = 0; dataSetIndex < gNvNumberOfDataSets_c; ++dataSetIndex)
  357:  	{
  358:  		pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
  359:  		if (!pDataItemDescriptions)
  360:  		{
  361:  			continue;
  362:  		}
  363:  		dataSetSize = 0;
  364:  
  365:  		while (pDataItemDescriptions->length)
  366:  		{
  367:  			dataSetSize += pDataItemDescriptions->length;
  368:  			++pDataItemDescriptions;
  369:  		}
  370:  
  371:  		/* Assert if the data set is too big. */
  372:  		if (dataSetSize > MbrSizeof(NvStructuredPage_t, clientData))
  373:  		{
  374:  			for (;;)
  375:  			{ }
  376:  		}
  377:  	}
  378:  #endif   /* gNvDebug_d */
  379:  
  380:  #if gNvSelfTest_d
  381:  	NvSelfTest();
  382:  #endif
  383:  }/* NvModuleInit() */
  384:  #endif /* gNvStorageIncluded_d */
  385:  
  386:  /****************************************************************************/
  387:  
  388:  /* Search for a specific data structure in NV storage, delimited by a known
  389:   * string at the beginning and end of the struct, and a known structure length.
  390:   * The length includes both strings. The "strings" contain arbitrary bytes;
  391:   * they are not assumed to be null-terminated C strings.
  392:   *
  393:   * This function is only indended for use by by the early startup code (crt0
  394:   * and PlatformInit), which needs to find a struct containing hardware
  395:   * initialization values.
  396:   *
  397:   * At that point in the startup process, the stack is available, but no data
  398:   * in RAM has been initialized yet. ONLY const data (in ROM) is dependable.
  399:   * NvModuleInit() has not been called yet to initialize this module. Be very
  400:   * careful about calling local functions.
  401:   * NvHalInit() has not been called yet. Do not call HAL functions, directly
  402:   * or indirectly.
  403:   *
  404:   * Return a pointer to the NV storage copy of the data if found.
  405:   * Return NULL if not found.
  406:   */
  407:  
  408:  
  409:  /****************************************************************************/
  410:  
  411:  /* Copy the most recent version of a data set from NV storage to RAM. */
  412:  /* Note that the copy will succeed if a valid copy of the data set is found */
  413:  /* in NV storage, regardless of the state of the data set's dirty flag. */
  414:  /* Return TRUE if the copy is successful. */
  415:  #if gNvStorageIncluded_d
  416:  bool_t NvRestoreDataSet
  417:    (
  418:    NvDataSetID_t dataSetID
  419:    )
  420:  {
  421:    NvDataItemDescription_t const *pDataItemDescriptions;
  422:    index_t dataSetIndex;
  423:    index_t pageIndex;
  424:    NvSize_t pageOffset;
  425:  
  426:    /* Find the data set description. */
  427:    dataSetIndex = NvDataSetIndexFromID(dataSetID);
  428:  
  429:    /* Find the data set in NV storage. */
  430:    pageIndex = NvFindDataSet(dataSetID);
  431:    if (pageIndex == gNvInvalidPageIndex_c) {
  432:      return FALSE;
  433:    }
  434:  
  435:    pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
  436:  
  437:    /* Start reading just after the page header. */
  438:    pageOffset = sizeof(NvStructuredPageHeader_t);
  439:  
  440:    /* Copy data from the NV storage page to the destination data set. */
  441:    while (pDataItemDescriptions->length) {
  442:      NvHalRead(maNvRawPageAddressTable[pageIndex], pageOffset, pDataItemDescriptions->pointer, pDataItemDescriptions->length);
  443:      pageOffset += pDataItemDescriptions->length;
  444:      ++pDataItemDescriptions;
  445:    }
  446:  
  447:    maNvDirtyFlags[dataSetIndex].saveNextInterval = FALSE;
  448:    maNvDirtyFlags[dataSetIndex].countsToNextSave = gNvCountsBetweenSaves_c;
  449:  
  450:    return TRUE;
  451:  }/* NvRestoreDataSet() */
  452:  #endif /* gNvStorageIncluded_d */
  453:  
  454:  /****************************************************************************/
  455:  
  456:  /* Return TRUE if the copy is successful. */
  457:  #if (gNvStorageIncluded_d && gNvMultiStorageIncluded_d )
  458:  bool_t NvRestoreMultiSavedData
  459:    (
  460:                                                                                       
  461:    NvDataSetID_t dataSetID , void * pDest , uint16_t destLength
  462:    )
  463:  {
  464:    NvDataItemDescription_t const *pDataItemDescriptions;
  465:    index_t dataSetIndex;
  466:    index_t pageIndex;
  467:    NvSize_t pageOffset, dataOffset;
  468:    uint8_t  *pPageAddress;
  469:      
  470:    dataSetIndex = NvDataSetIndexFromID(dataSetID);
  471:    pageIndex = NvFindDataSet(dataSetID);
  472:  	if (pageIndex == gNvInvalidPageIndex_c)
  473:  	{
  474:  		return FALSE;
  475:  	}
  476:    pPageAddress = maNvRawPageAddressTable[pageIndex];
  477:    pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
  478:    pageOffset = sizeof(NvStructuredPageHeader_t);
  479:  
  480:    while (pDataItemDescriptions->length) {
  481:      pageOffset += pDataItemDescriptions->length;
  482:      ++pDataItemDescriptions;
  483:    }
  484:    dataOffset = 0;
  485:   
  486:   while(pageOffset + destLength + sizeof(msMarker_t) <= gNVPageMaxOffset_c ) 
  487:   {
  488:    if( pPageAddress[pageOffset] == 0xff ) 
  489:      {
  490:      break;
  491:      }
  492:    if(*((uint16_t*)(pPageAddress + pageOffset)) == 0x0f0f )
  493:      {
  494:      dataOffset = pageOffset;
  495:      }
  496:    pageOffset += destLength + sizeof(msMarker_t);
  497:   }
  498:   if(dataOffset) 
  499:   {
  500:    NvHalRead(pPageAddress, dataOffset + sizeof(msMarker_t) ,	(uint8_t*)pDest,destLength) ;
  501:   }
  502:   return TRUE;
  503:  
  504:    ////////////////////////////////////////////////
  505:  
  506:  }/* NvRestoreMultiSavedData*/
  507:  #endif /* (gNvStorageIncluded_d && gNvMultiStorageIncluded_d )*/
  508:  
  509:  
  510:  /****************************************************************************/
  511:  
  512:  /* Save the data set on the next call to NvIdle(). */
  513:  /* Use the save-on-count mechanism. */
  514:  void NvSaveOnIdle
  515:  (
  516:  	NvDataSetID_t dataSetID
  517:  )
  518:  {
  519:  #if !gNvStorageIncluded_d
  520:  (void)dataSetID;
  521:  #else
  522:    maNvDirtyFlags[NvDataSetIndexFromID(dataSetID)].countsToNextSave = 0;
  523:  #endif /* gNvStorageIncluded_d */
  524:  }
  0000 8d       [7]             RTC   
  525:  
  526:  
  527:  /****************************************************************************/
  528:  
  529:  void NvInPageMultiSaveOnIdle
  530:  (
  531:  	NvDataSetID_t dataSetID , void * pSource , uint16_t sourceLength
  532:  )
  533:  {
  534:  #if (gNvStorageIncluded_d && gNvMultiStorageIncluded_d )  
  535:    index_t index;
  536:    index = NvDataSetIndexFromID(dataSetID);
  537:    maNvMultiSavedDataInfo[index].pSource = pSource;
  538:    maNvMultiSavedDataInfo[index].sourceLength = sourceLength;  
  539:  #else 
  540:    (void)dataSetID;
  541:    (void)pSource;
  542:    (void)sourceLength; 
  543:    return; 
  544:  #endif
  545:  }
  0000 8d       [7]             RTC   
  546:  
  547:  
  548:  /****************************************************************************/
  549:  void NvSaveOnInterval
  550:    (
  551:    NvDataSetID_t dataSetID
  552:   )
  553:  {
  554:  #if !gNvStorageIncluded_d
  555:  (void)dataSetID;
  556:  #else
  557:    index_t dataSetIndex = NvDataSetIndexFromID(dataSetID);
  558:  
  559:    if (!maNvDirtyFlags[dataSetIndex].saveNextInterval)
  560:  	{
  561:      maNvDirtyFlags[dataSetIndex].ticksToNextSave  = gNvMinimumTicksBetweenSaves_c;
  562:      maNvDirtyFlags[dataSetIndex].saveNextInterval = TRUE;
  563:      TS_SendEvent(gIdleTaskID, gIdleTaskNVIntervalEvent_c);
  564:    }
  565:  #endif /* gNvStorageIncluded_d */
  566:  }/* NvSaveOnInterval() */
  0000 8d       [7]             RTC   
  567:  
  568:  
  569:  /****************************************************************************/
  570:  
  571:  /* Decrement the counter. Once it reaches 0, the next call to NvIdle() will */
  572:  /* save the data set. */
  573:  void NvSaveOnCount
  574:    (
  575:    NvDataSetID_t dataSetID
  576:   )
  577:  {
  578:  #if !gNvStorageIncluded_d
  579:  (void)dataSetID;
  580:  #else
  581:    index_t dataSetIndex = NvDataSetIndexFromID(dataSetID);
  582:  
  583:    if (maNvDirtyFlags[dataSetIndex].countsToNextSave) {
  584:      --maNvDirtyFlags[dataSetIndex].countsToNextSave;
  585:    }
  586:  #endif /* gNvStorageIncluded_d */
  587:  }/* NvSaveOnCount() */
  0000 8d       [7]             RTC   
  588:  
  589:  /****************************************************************************/
  590:  
  591:  /* Set the timer used by NvSaveOnInterval(). Takes effect after the next */
  592:  /* save. */
  593:  #if gNvStorageIncluded_d
  594:  void NvSetMinimumTicksBetweenSaves
  595:    (
  596:    NvSaveInterval_t newInterval
  597:   )
  598:  {
  599:    gNvMinimumTicksBetweenSaves = newInterval;
  600:  }/* NvSetMinimumTicksBetweenSaves() */
  601:  #endif /* gNvStorageIncluded_d */
  602:  
  603:  /****************************************************************************/
  604:  
  605:  /* Set the counter trigger value used by NvSaveOnCount(). Takes effect */
  606:  /* after the next save. */
  607:  #if gNvStorageIncluded_d
  608:  void NvSetCountsBetweenSaves
  609:    (
  610:    NvSaveCounter_t newCounter
  611:   )
  612:  {
  613:    gNvCountsBetweenSaves = newCounter;
  614:  }/* NvSetCountsBetweenSaves() */
  615:  #endif /* gNvStorageIncluded_d */
  616:  
  617:  /****************************************************************************/
  618:  
  619:  /* Called from the idle task to process save-on-interval requests. */
  620:  /* Returns FALSE if the timer tick counters for all data sets have reached */
  621:  /* zero. In this case, the timer can be turned off. */
  622:  /* Returns TRUE if any of the data sets' timer tick counters have not yet */
  623:  /* counted down to zero. In this case, the timer should be active. */
  624:  #if gNvStorageIncluded_d
  625:  bool_t NvTimerTick(bool_t countTick)
  626:  {
  627:    index_t i;
  628:    bool_t fTicksLeft = FALSE;
  629:    NvDataSetInfo_t *pDirtyFlags;
  630:  
  631:    if (countTick) {
  632:      pDirtyFlags = maNvDirtyFlags;
  633:      for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
  634:        
  635:        if(pDirtyFlags->ticksToNextSave)
  636:          --(pDirtyFlags->ticksToNextSave);
  637:        if(pDirtyFlags->ticksToNextSave)
  638:          fTicksLeft = TRUE;
  639:        if (pDirtyFlags->saveNextInterval && !pDirtyFlags->ticksToNextSave)
  640:        {
  641:          if(!mNvCriticalSectionFlag)
  642:          {
  643:            NvSaveDataSet(i);
  644:          }
  645:          else
  646:          {
  647:            pDirtyFlags->countsToNextSave = 0;
  648:          }
  649:        }
  650:  
  651:        ++pDirtyFlags;
  652:      }
  653:    }
  654:  
  655:    return fTicksLeft;
  656:  }/* NvTimerTick() */
  657:  #endif /* gNvStorageIncluded_d */
  658:  
  659:  /*****************************************************************************
  660:  ******************************************************************************
  661:  * Private functions
  662:  ******************************************************************************
  663:  *****************************************************************************/
  664:  
  665:  /* Compare two data set sequence numbers. */
  666:  /* Return   -1 if left  < right */
  667:  /*           0 if left == right */
  668:  /*           1 if left  > right */
  669:  /* Data set sequence numbers are unsigned, and modulo a power of two. Thus, */
  670:  /* 0 > (unsigned) -1. */
  671:  /* #if gNvStorageIncluded_d */
  672:  /* int8_t NvCmpSequenceNumbers */
  673:  /*   (*/
  674:  /*   uint8_t left, */
  675:  /*   uint8_t right */
  676:  /*  ) */
  677:  /* { */
  678:  /*   if (left == right) { */
  679:  /*     return 0; */
  680:  /*   } */
  681:  
  682:  /*   if ((left - right) & 0x80) { */
  683:  /*     return -1; */
  684:  /*   } */
  685:  
  686:  /*   return 1; */
  687:  /* }                                       /\* NvCmpSequenceNumbers() *\/ */
  688:  /* #endif                                  /\* #if gNvStorageIncluded_d *\/ */
  689:  
  690:  /****************************************************************************/
  691:  
  692:  /* Given a data set ID, return it's index in the NvDataSetTable[].
  693:   * Data set IDs are arbitrary values, so they have to be searched for.
  694:   */
  695:  #if gNvStorageIncluded_d
  696:  static index_t NvDataSetIndexFromID
  697:    (
  698:    NvDataSetID_t dataSetID
  699:   )
  700:  {
  701:    index_t i;
  702:  
  703:    for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
  704:      if (NvDataSetTable[i].pItemDescriptions
  705:           && (NvDataSetTable[i].dataSetID == dataSetID)) {
  706:        return i;
  707:      }
  708:    }
  709:  
  710:    /* Can't find it. Must be a programming error in the caller. There's */
  711:    /* no good way to handle errors, but at least this makes it obvious */
  712:    /* during debugging. */
  713:    for (;;) { }
  714:  }/* NvDataSetIndexFromID() */
  715:  #endif /* gNvStorageIncluded_d */
  716:  
  717:  /****************************************************************************/
  718:  
  719:  /* Search NV storage for a given data set. Return it's index if it is found */
  720:  /* and is valid. Return gNvInvalidPageIndex_c otherwise. */
  721:  #if gNvStorageIncluded_d
  722:  static index_t NvFindDataSet
  723:    (
  724:    NvDataSetID_t dataSetID
  725:   )
  726:  {
  727:    index_t i;
  728:  
  729:    for (i = 0; i < gNvNumberOfRawPages_c; ++i) {
  730:      if (((NvStructuredPage_t *) maNvRawPageAddressTable[i])->header.dataSetID == dataSetID) {
  731:        return i;
  732:      }
  733:    }
  734:  
  735:    return gNvInvalidPageIndex_c;
  736:  }/* NvFindDataSet() */
  737:  #endif                                  /* gNvStorageIncluded_d */
  738:  
  739:  /****************************************************************************/
  740:  
  741:  /* Examine an NV storage page. Check the magic number, check that the header
  742:   * and trailer match, and check that the data set ID is recognized by the
  743:   * application's table of data set descriptions.
  744:   * Return TRUE if it looks legit; FALSE otherwise.
  745:   */
  746:  #if gNvStorageIncluded_d
  747:  static bool_t NvIsValidDataSet
  748:    (
  749:    index_t pageIndex
  750:   )
  751:  {
  752:    bool_t legitDataSetID;
  753:    index_t i;
  754:    NvStructuredPage_t *pPage = ((NvStructuredPage_t *) maNvRawPageAddressTable[pageIndex]);
  755:  
  756:    /* Is the data set ID legit? */
  757:    for (legitDataSetID = FALSE, i = 0; i < gNvNumberOfDataSets_c; ++i) {
  758:      if (NvDataSetTable[i].dataSetID
  759:           && (NvDataSetTable[i].dataSetID == pPage->header.dataSetID)) {
  760:        legitDataSetID = TRUE;
  761:        break;
  762:      }
  763:    }
  764:  
  765:    /* Do the header and trailer match? */
  766:    /* Is the magic number legit? */
  767:    if (legitDataSetID
  768:         && FLib_MemCmp(&pPage->header, &pPage->trailer, sizeof(pPage->header))
  769:         && (pPage->header.magicNumber == mNvMagicNumber_c)) {
  770:      return TRUE;
  771:    }
  772:  
  773:    return FALSE;
  774:  }                                       /* NvIsValidDataSet() */
  775:  #endif                                  /* gNvStorageIncluded_d */
  776:  
  777:  /****************************************************************************/
  778:  
  779:  /*
  780:  Save the contents of a data set, regardless of the state of the set's
  781:   * dirty flag. Always writes a full page.
  782:   *
  783:   * Retry if the HAL reports an error. There isn't anything that the caller
  784:   * can do about errors, so reporting one would be pointless.
  785:   *
  786:   * The flash controller reports errors that it detects, but power supply
  787:   * fluctuations may still cause undetected errors. Its tempting to compute
  788:   * some kind of checksum, and verify it after write, and also when a data
  789:   * set is restored. This would complicate the code somewhat, and may not
  790:   * be a common enough problem to be worth the extra code space.
  791:   */
  792:  #if gNvStorageIncluded_d
  793:  static void NvSaveDataSet
  794:    (
  795:    index_t dataSetIndex
  796:   )
  797:  {
  798:    NvDataItemDescription_t const *pDataItemDescriptions;
  799:    NvDataSetID_t dataSetID;
  800:  
  801:    index_t oldDataSetPageIndex;
  802:    NvStructuredPageHeader_t pageHeader;
  803:    index_t pageIndex;
  804:    NvSize_t pageOffset;
  805:    uint8_t retries;
  806:    bool_t status;                        /* FALSE on HAL error. */
  807:    unsigned char hexFF = 0xff;
  808:  
  809:    /* Search for an unused page. Almost as fast as keeping an array of */
  810:    /* page status flags, and uses less RAM. */
  811:  	for (pageIndex = 0; pageIndex < gNvNumberOfRawPages_c; ++pageIndex)
  812:  	{
  813:  		if (!NvIsValidDataSet(pageIndex))
  814:  			break;
  815:  	}
  816:  
  817:    /* There should always be an available page. If there isn't, there is */
  818:    /* either an internal error in this code or the application, or there's */
  819:    /* hardware failure. Either way, there's nothing that can be done about */
  820:    /* it except to ignore the attempted write. */
  821:    if(pageIndex >= gNvNumberOfRawPages_c)
  822:      return;
  823:  
  824:    dataSetID = NvDataSetTable[dataSetIndex].dataSetID;
  825:  
  826:    /* Set up the page header/trailer. */
  827:    pageHeader.magicNumber = mNvMagicNumber_c;
  828:    pageHeader.dataSetID = dataSetID;
  829:  
  830:    oldDataSetPageIndex = NvFindDataSet(dataSetID);
  831:  	if (oldDataSetPageIndex == gNvInvalidPageIndex_c)
  832:  	{
  833:  		pageHeader.sequenceNumber = 0;
  834:  	}
  835:  	else
  836:  	{
  837:  		pageHeader.sequenceNumber =
  838:  		((NvStructuredPage_t *) maNvRawPageAddressTable[oldDataSetPageIndex])->header.sequenceNumber + 1;
  839:  	}
  840:  
  841:    /* Keep trying until either it works, or it fails often enough that */
  842:    /* it is unlikely to ever work. */
  843:    NvOperationStart();
  844:    retries = mNvFlashCmdRetries_c;
  845:  	while (retries--)
  846:  	{
  847:  		pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
  848:  		pageOffset = 0;
  849:  
  850:  		/* Write the page header to the beginning of the page. */
  851:  		status = NvHalWrite(maNvRawPageAddressTable[pageIndex],
  852:  												pageOffset,
  853:  												(unsigned char *) &pageHeader,
  854:  												sizeof(pageHeader));
  855:  		pageOffset += sizeof(pageHeader);
  856:  
  857:  		/* Write the client data to the page. Note that the sizes of all of the
  858:  			data sets in NvDataSetTable[] were validated in NvModuleInit(), so it
  859:  			isn't necesary to check it here. */
  860:  		while (status && pDataItemDescriptions->length)
  861:  		{
  862:  			status = NvHalWrite(maNvRawPageAddressTable[pageIndex],
  863:  			pageOffset, pDataItemDescriptions->pointer, pDataItemDescriptions->length);
  864:  			pageOffset += pDataItemDescriptions->length;
  865:  			++pDataItemDescriptions;
  866:  		}
  867:  
  868:  		/* Pad to the end of the page's data field. The HAL does not allow writing
  869:  			partial pages, but it doesn't check. */
  870:  		while (status && (pageOffset < sizeof(NvRawPage_t) - sizeof(pageHeader)))
  871:  		{
  872:  			status = NvHalWrite(maNvRawPageAddressTable[pageIndex],
  873:  													pageOffset,
  874:  													&hexFF,
  875:  													sizeof(hexFF));
  876:  			pageOffset += sizeof(hexFF);
  877:  		}
  878:  
  879:  		/* Write the terminal copy of the header. If this works, we're done. */
  880:  		if (status && NvHalWrite(maNvRawPageAddressTable[pageIndex], pageOffset,
  881:  														(unsigned char *) &pageHeader, sizeof(pageHeader)))
  882:  		{
  883:  			break;
  884:  		}
  885:  
  886:  		/* Something didn't work. Erase the page and try again. */
  887:  		NvHalErasePage(maNvRawPageAddressTable[pageIndex],mNvFlashPageEraseCmd_c);
  888:  	}/* while (retries--) */
  889:  
  890:  	/* If it didn't work, don't update anything. */
  891:  	if (status)
  892:  	{
  893:  		/* The new copy is safe. Erase the old one. Rereading the data set to
  894:  			verify that it wrote correctly would be safer, but it would also be
  895:  			slower and would take more code. */
  896:  		if (oldDataSetPageIndex != gNvInvalidPageIndex_c)
  897:  		{
  898:  			NvHalErasePage(maNvRawPageAddressTable[oldDataSetPageIndex], mNvFlashPageEraseCmd_c);
  899:  		}
  900:  		maNvDirtyFlags[dataSetIndex].saveNextInterval = FALSE;
  901:      maNvDirtyFlags[dataSetIndex].countsToNextSave = gNvCountsBetweenSaves_c;
  902:  	}/* if (status) */
  903:  }/* NvSaveDataSet() */
  904:  #endif                                  /* gNvStorageIncluded_d */
  905:  
  906:  
  907:  /****************************************************************************/
  908:  
  909:  #if (gNvStorageIncluded_d && gNvMultiStorageIncluded_d )
  910:  
  911:  static bool_t NvInPageMultiSave
  912:    (
  913:    index_t dataSetIndex
  914:    )
  915:  {
  916:    NvDataItemDescription_t const *pDataItemDescriptions;
  917:    NvDataSetID_t dataSetID;
  918:    uint8_t  *pPageAddress;
  919:    msMarker_t msMarker;
  920:    index_t pageIndex;
  921:    NvSize_t pageOffset;
  922:    
  923:    dataSetID = NvDataSetTable[dataSetIndex].dataSetID;
  924:    pageIndex = NvFindDataSet(dataSetID);
  925:  	if (pageIndex == gNvInvalidPageIndex_c)
  926:  	{
  927:  	//	return FALSE;
  928:  	// there is no saved page with this ID  
  929:  	for(;;){}
  930:  	  //  for debug purposes 
  931:  	}
  932:    pPageAddress = maNvRawPageAddressTable[pageIndex];
  933:    pDataItemDescriptions = NvDataSetTable[dataSetIndex].pItemDescriptions;
  934:    pageOffset = sizeof(NvStructuredPageHeader_t);
  935:  
  936:    while (pDataItemDescriptions->length) {
  937:      pageOffset += pDataItemDescriptions->length;
  938:      ++pDataItemDescriptions;
  939:    }
  940:  
  941:  NvOperationStart();
  942:  for(;;)
  943:  {
  944:    if ((pageOffset + maNvMultiSavedDataInfo[dataSetIndex].sourceLength + sizeof(msMarker_t)) > gNVPageMaxOffset_c ) 
  945:      {
  946:       return FALSE;
  947:      }
  948:    if(pPageAddress[pageOffset] == 0xff ) 
  949:      {
  950:      msMarker.header = 0xf;
  951:      msMarker.trailer = 0xf;
  952:      if(TRUE == NvHalUnbufferedWrite( pPageAddress , pageOffset , &msMarker.header , 1) )
  953:        {
  954:        if(TRUE == NvHalUnbufferedWrite( pPageAddress , pageOffset + sizeof(msMarker_t) , (uint8_t*)maNvMultiSavedDataInfo[dataSetIndex].pSource , maNvMultiSavedDataInfo[dataSetIndex].sourceLength )) 
  955:          {
  956:           if(TRUE == NvHalUnbufferedWrite( pPageAddress , pageOffset + sizeof(msMarker.header) , &msMarker.trailer , 1)) 
  957:           {
  958:            maNvMultiSavedDataInfo[dataSetIndex].pSource = NULL;
  959:            maNvMultiSavedDataInfo[dataSetIndex].sourceLength = 0;
  960:            
  961:            return TRUE;
  962:           }
  963:          }
  964:        } 
  965:      else 
  966:       {
  967:        if(pPageAddress[pageOffset] == 0xff ) 
  968:          {
  969:           return FALSE;
  970:          }
  971:       }
  972:        
  973:      }
  974:    pageOffset += maNvMultiSavedDataInfo[dataSetIndex].sourceLength + sizeof(msMarker_t);
  975:   }
  976:   
  977:  
  978:  }/* NvInPageMultiSave */
  979:  #endif                                  /* (gNvStorageIncluded_d && gNvMultiStorageIncluded_d ) */
  980:  
  981:  
  982:  /****************************************************************************/
  983:  
  984:  /* Unit test. This is a debugging aid; it isn't intended to test every */
  985:  /* possible case. It isn't even a good smoke test. It doesn't try to */
  986:  /* insure completely correct operation; the calls to NvSelfTestError() are */
  987:  /* only intended to provide convenient places to put debugger breakpoints. */
  988:  
  989:  #if gNvSelfTest_d
  990:  
  991:  uint8_t NvSelfTestErrors = 0;
  992:  static void NvSelfTestError(void)
  993:  {
  994:    NvSelfTestErrors++;
  995:  }
  996:  
  997:  static void NvSelfTest()
  998:  {
  999:    uint8_t buf[16];
 1000:    index_t i;
 1001:    unsigned char const *p = NULL;
 1002:  
 1003:    /* Test valid page recognition for invalid pages. */
 1004:    for (i = 0; i < gNvNumberOfRawPages_c; ++i) {
 1005:      if (NvIsValidDataSet(i)) {
 1006:        NvSelfTestError();
 1007:      }
 1008:    }
 1009:  
 1010:    /* Write some data sets. */
 1011:    for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
 1012:      NvSaveDataSet(NvDataSetTable[i].dataSetID);
 1013:    }
 1014:  
 1015:  
 1016:    /* Copy some data, change it, and restore the data set. */
 1017:  
 1018:    for (i = 0; i < sizeof(NvTestDataArray2); ++i) {
 1019:      buf[i] = NvTestDataArray2[i];
 1020:      NvTestDataArray2[i] = 0;
 1021:    }
 1022:  
 1023:    if (!NvRestoreDataSet(gNvDataSet1ID_c)) {
 1024:      NvSelfTestError();
 1025:    }
 1026:  
 1027:    for (i = 0; i < sizeof(NvTestDataArray2); ++i) {
 1028:      if (buf[i] != NvTestDataArray2[i]) {
 1029:        NvSelfTestError();
 1030:      }
 1031:    }
 1032:  
 1033:    /* Try writing a new version of each data set. */
 1034:    for (i = 0; i < gNvNumberOfDataSets_c; ++i) {
 1035:      NvSaveDataSet(NvDataSetTable[i].dataSetID);
 1036:    }
 1037:  }                                       /* NvSelfTest() */
 1038:  #endif                                  /* #if gNvSelfTest_d */
 1039:  
