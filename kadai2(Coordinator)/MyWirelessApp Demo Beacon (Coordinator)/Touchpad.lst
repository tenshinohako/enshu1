*** EVALUATION ***
ANSI-C/cC++ Compiler for HC08 V-5.0.41 Build 12319, Nov 15 2012

    1:  /*****************************************************************************
    2:  * Touchpad Hardware Abstraction Layer
    3:  *
    4:  * Copyright (c) 2010, Freescale, Inc. All rights reserved
    5:  *
    6:  * No part of this document must be reproduced in any form - including copied,
    7:  * transcribed, printed or by any electronic means, - without specific written 
    8:  * permission from Freescale Semiconductor
    9:  * 
   10:  *****************************************************************************/
   11:  
   12:  #include "EmbeddedTypes.h"
   13:  #include "IrqControlLib.h"
   14:  #include "IoConfig.h"
   15:  #include "TS_Interface.h"
   16:  #include "Touchpad_Interface.h"
   17:  #include "Touchpad.h"
   18:  #include "IIC_Interface.h"
   19:  #include "FunctionLib.h"
   20:  
   21:  
   22:  
   23:  #pragma MESSAGE DISABLE C4001 // Warning C4001: Condition always FALSE
   24:  
   25:  
   26:  /*****************************************************************************
   27:  ******************************************************************************
   28:  * Private macros 
   29:  ******************************************************************************
   30:  *****************************************************************************/
   31:  /* Touchpad events */
   32:  #define gTP_Event_WriteBlockSuccess_c       (1<<1)
   33:  #define gTP_Event_WriteBlockFail_c          (1<<2)
   34:  #define gTP_Event_ReadBlockSuccess_c        (1<<3)
   35:  #define gTP_Event_ReadBlockFail_c           (1<<4)
   36:  #define gTP_Event_ISR_c                     (1<<5)
   37:  
   38:  #define gTP_I2cTransfOperMaxSize_c          (8)
   39:  #define gTP_DataTableMaxSize_c              (20) 
   40:  #define gTP_RmiAddrByteSize_c               (1)
   41:  
   42:  #define gWriteBlockMaxSize_c                (16)
   43:  /* In debug mode some table's elements are automatically cleared for more readability */                                          
   44:  #define DEBUG_MODE_ENABLE                   (0)  
   45:  
   46:  /* Table operations sizes for each touchpad process */
   47:  #define gTP_DevRestart_TransfOperNo_c       (1)
   48:  #define gTP_GetDevInfo_TransfOperNo_c       (4)
   49:  #define gTP_GetDevConfig_TransfOperNo_c     (2)
   50:  #define gTP_SetDevConfig_TransfOperNo_c     (5)
   51:  #define gTP_Isr_TransfOperNo_c              (2)
   52:  
   53:  /*****************************************************************************
   54:  ******************************************************************************
   55:  * Private type definitions 
   56:  ******************************************************************************
   57:  *****************************************************************************/
   58:  
   59:  /* Type of operation */
   60:  typedef enum
   61:  {
   62:    mTP_OperType_Read_c  = 0,     
   63:    mTP_OperType_Write_c  
   64:  } tpOperType_t;
   65:               
   66:  /* Structure used to define the entry element in the table of operations */
   67:  typedef struct tpI2cTransfOper_tag  
   68:  {   
   69:    uint8_t             regAddr;
   70:    uint8_t*            pBuff;
   71:    uint8_t             buffLength;     
   72:    tpOperType_t        tpOperType;
   73:  } tpI2cTransfOper_t;
   74:    
   75:               
   76:  /* Structure to control the RMI operation over the IIC */
   77:  typedef struct 
   78:  {   
   79:    bool_t                accessLock;
   80:    tpI2cTransfOper_t     rmiBlockAccess;    
   81:  } rmiBlockAccess_t;
   82:  
   83:  /*****************************************************************************
   84:  ******************************************************************************
   85:  * Private memory declaration 
   86:  ******************************************************************************
   87:  *****************************************************************************/
   88:  #if(gTouchpadIncluded_d == 1)
   89:  
   90:  /* Id for the Touchpad task */
   91:  static tsTaskID_t             gTP_TaskId;
   92:  
   93:  static  uint8_t               gTP_IntStatus;
   94:  static  uint8_t               gTP_DevStatus;
   95:  
   96:  /* Variables associated with I2C communication */
   97:  static tpI2cTransfOper_t      maTP_I2cTransfOperTable[gTP_I2cTransfOperMaxSize_c];
   98:  static volatile index_t       maTP_I2cTransfOperNo;             
   99:  static volatile index_t       maTP_I2cOperCurrIndex;
  100:  
  101:  static uint8_t                maDataTable[gTP_DataTableMaxSize_c];
  102:  static rmiBlockAccess_t       gRmiBlockAccess; 
  103:      
  104:  /* Structure containing all information required by the application's callback function */
  105:  tpCallbackInfo_t              gTP_CallbackInfo;
  106:  
  107:  static uint8_t                gWriteBlock[gWriteBlockMaxSize_c]; 
  108:  
  109:  /* Block size used to be read by the touchpad task */
  110:  static uint8_t gBlockSize = 0; /* However the global variables are cleared at initialization */
  111:  
  112:  /* Variable counting the number of ISR passing during reset operation */
  113:  static volatile uint8_t       gTP_DevResetIdx;
  114:                   
  115:  #endif
  116:  
  117:  /*****************************************************************************
  118:  ******************************************************************************
  119:  * Private function prototypes 
  120:  ******************************************************************************
  121:  *****************************************************************************/
  122:  
  123:  /* TP Task; Process the TP events in interrupt-driven context */
  124:  void TP_Task(event_t events);
  125:  #if(gTouchpadIncluded_d == 1)
  126:    /* TP callback function */
  127:    static void (*pfTpCallback)(tpCallbackInfo_t tpCallbackInfo);
  128:  
  129:    /*****************************************************************************/
  130:    static void TP_SaveDevInfo(void);
  131:    static void TP_SaveDevConfig(void);
  132:    static void TP_UpdateDevConfig(uint8_t mIntEn0Reg, uint8_t mGestEn1Reg); 
  133:    static statusCode_t TP_GetFingerInfo(uint8_t mFingerNum);
  134:    static void TP_GestureRecognition(void);
  135:    static bool_t TP_ReadBlock(uint8_t startAddr, uint8_t blockLength, uint8_t* pRxBuff);       
  136:    static bool_t TP_WriteBlock(uint8_t startAddr, uint8_t blockLength, uint8_t* pTxBuff);
  137:    static void RmiWriteAddrCallback(bool_t status);
  138:    static void RmiCompleteAccessCallback(bool_t status);
  139:  #endif //(gTouchpadIncluded_d == 1)
  140:  
  141:  /*****************************************************************************
  142:  ******************************************************************************
  143:  * Private functions 
  144:  ******************************************************************************
  145:  *****************************************************************************/
  146:  
  147:  /*****************************************************************************
  148:  * TP_Init
  149:  * 
  150:  * Interface assumption:
  151:  *
  152:  * Return value: generic status code
  153:  *
  154:  * Initialize the touchpad sensor, IIC communication, global variables
  155:  *****************************************************************************/
  156:  statusCode_t TP_Init(void)
  157:  {
  158:  #if(gTouchpadIncluded_d == 1)
  159:    uint8_t retStatus = TP_OK;
  160:  
  161:    if(FALSE == IIC_SetBaudRate(gTP_Default_IIC_CommRate_c))
  162:    {
  163:      retStatus = TP_ERR_IIC_COMM;     
  164:    }
  165:    else
  166:    {
  167:      /* Create the touchpad task */
  168:      gTP_TaskId = TS_CreateTask(gTP_TaskPriority_c, TP_Task); 
  169:      
  170:      if(gTsInvalidTaskID_c != gTP_TaskId)
  171:      {
  172:        /* Set the pointer callback to NULL */
  173:        pfTpCallback = NULL; 
  174:        
  175:        #if(gTP_Mode_c == gTP_IrqIsrMode_c)
  176:          /* IRQ pin settings */
  177:          m_IRQSC_c =(mIRQSC_IRQPE_c | mIRQSC_IRQIE_c | mIRQ_FallingEdge_Sense_c);
  178:        #endif
  179:        #if(gTP_Mode_c == gTP_KbiIsrMode_c)
  180:          /* KBI2P0 pin setting */
  181:          m_KBI2PE_c |= mKBI2PE_KBIPE0_c;
  182:          
  183:          m_KBI2SC_c = mKBI2SC_KBIE_c;
  184:        #endif
  185:        
  186:        /* Initialize the block access flag */
  187:        gRmiBlockAccess.accessLock = FALSE;
  188:        
  189:        /* Clear all values from the global variable responsible for passing the 
  190:           information to the callback */
  191:        FLib_MemSet(&gTP_CallbackInfo, 0, sizeof(tpCallbackInfo_t));
  192:        
  193:        /* Reset the variable which detect the reset operation */
  194:        gTP_DevResetIdx = 0;      
  195:      }
  196:      else
  197:      {
  198:        retStatus = TP_ERR_INVALID_PARAM;
  199:      }
  200:    } 
  201:           
  202:    return retStatus; 
  203:  #else    
  204:    return  TP_OK;
  0000 4f       [1]             CLRA  
  205:  #endif    
  206:  }
  0001 8d       [7]             RTC   
  207:  
  208:  /*****************************************************************************
  209:  * TP_Uninit
  210:  *
  211:  * Interface assumption:
  212:  *
  213:  * Return value: None
  214:  * 
  215:  * Uninit the touchpad sensor, IIC communication, disallocates the memory for 
  216:  * global variable
  217:  *****************************************************************************/
  218:  void TP_Uninit(void)
  219:  {
  220:  #if(gTouchpadIncluded_d == 1)   
  221:    /* Destroy the touchpad task if there is a valid ID */
  222:    if(gTsInvalidTaskID_c != gTP_TaskId)
  223:    {
  224:      TS_DestroyTask(gTP_TaskId);  
  225:    }
  226:    
  227:    #if(gTP_Mode_c == gTP_IrqIsrMode_c)
  228:      /* IRQ pin disable */
  229:      m_IRQSC_c = mIRQSC_Reset_c;
  230:    #endif
  231:    #if(gTP_Mode_c == gTP_KbiIsrMode_c)
  232:      /* KBI2P0 pin disable */
  233:      m_KBI2SC_c = mKBI2SC_Reset_c;
  234:    #endif
  235:  #endif
  236:  }
  0000 8d       [7]             RTC   
  237:  
  238:      
  239:  /*****************************************************************************
  240:  * TP_DevRestart
  241:  * 
  242:  * Interface assumption:
  243:  *
  244:  * Return value: generic status code
  245:  *
  246:  * Reset the touchpad sensor
  247:  * 
  248:  *****************************************************************************/
  249:  statusCode_t TP_DevRestart(void)            
  250:  {    
  251:  #if(gTouchpadIncluded_d == 1)  
  252:    uint8_t retStatus = TP_OK;
  253:    tpI2cTransfOper_t* pTransfOper = maTP_I2cTransfOperTable;
  254:               
  255:    /* Store the function id */
  256:    gTP_CallbackInfo.funcId = gTP_DevRestartId_c;
  257:    
  258:    /* Reset the variable counting the External ISR occurence; during reset the 
  259:       external pin interrupt is going twice */
  260:    gTP_DevResetIdx = 0;     
  261:    
  262:    /* Reset the current transfer count */
  263:    maTP_I2cTransfOperNo = gTP_DevRestart_TransfOperNo_c;
  264:   
  265:    /* Prepare the first entry into the action table: Reset sensor */
  266:    *maDataTable = gTP_DevReset_c;   
  267:    pTransfOper->regAddr    = PDT_F01_RMI_COMMAND_BASE + mRMI_DeviceCommand_Offset_c;
  268:    pTransfOper->pBuff      = maDataTable;
  269:    pTransfOper->buffLength = 1;
  270:    pTransfOper->tpOperType = mTP_OperType_Write_c;
  271:      
  272:    /* Prepare the second entry to be read: Interrupt status: this is necessary to deassert the ATTN line again */
  273:    (++pTransfOper)->regAddr  = PDT_F01_RMI_DATA_BASE + mRMI_InterruptStatus_Offset_c; 
  274:    pTransfOper->pBuff        = maDataTable + 1;
  275:    pTransfOper->buffLength   = 1;
  276:    pTransfOper->tpOperType   = mTP_OperType_Read_c;        
  277:    
  278:    #if(DEBUG_MODE_ENABLE == 1)
  279:      /* Clear the remaining entries in the action table after filling with necessary actions */
  280:      FLib_MemSet((maTP_I2cTransfOperTable + maTP_I2cTransfOperNo + 1), 0, (gTP_I2cTransfOperMaxSize_c - maTP_I2cTransfOperNo - 1) * sizeof(tpI2cTransfOper_t));     
  281:  
  282:      /* Keep clear the data table */
  283:      FLib_MemSet((maDataTable + maTP_I2cTransfOperNo + 1), 0, (gTP_DataTableMaxSize_c - maTP_I2cTransfOperNo - 1));
  284:    #endif  
  285:    
  286:    /* Prepare one IIC Write operation */
  287:    maTP_I2cOperCurrIndex = 0;
  288:    
  289:    pTransfOper = maTP_I2cTransfOperTable;     
  290:    if(FALSE == TP_WriteBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))      
  291:    {
  292:      retStatus = TP_ERR_IIC_COMM;
  293:    }
  294:     
  295:    return retStatus;
  296:  #else
  297:    return  TP_OK;
  0000 4f       [1]             CLRA  
  298:  #endif   
  299:  }
  0001 8d       [7]             RTC   
  300:  
  301:  
  302:  /*****************************************************************************
  303:  * TP_GetDevInfo
  304:  * 
  305:  * Interface assumption:   This function should be called after calling the 
  306:  *                         TP_DevRestart() in order to get the correct information 
  307:  *
  308:  * Return value: generic status code
  309:  *
  310:  * Collects the information about the device configuration
  311:  *****************************************************************************/
  312:  statusCode_t TP_GetDevInfo(void)
  313:  {                    
  314:  #if(gTouchpadIncluded_d == 1)  
  315:    uint8_t retStatus = TP_OK;
  316:    tpI2cTransfOper_t* pTransfOper = maTP_I2cTransfOperTable;
  317:   
  318:    if(gTP_DevResetIdx != 2)
  319:    {
  320:      retStatus = TP_ERR_DEVICE_NOT_READY;
  321:    }
  322:    else
  323:    {
  324:      /* Store the function id */
  325:      gTP_CallbackInfo.funcId = gTP_GetDevInfoId_c;
  326:      
  327:      /* Fill the array with further operations to be accomplished in the TP_Task */
  328:      maTP_I2cTransfOperNo = gTP_GetDevInfo_TransfOperNo_c;    
  329:      
  330:      /* Prepare the first entry to be read: No of fingers, finger's absolute values, 
  331:      finger's relative values, gesture, sensor adjustement capabilities */
  332:      pTransfOper->regAddr      = PDT_F11_2D_QUERY_BASE + m2D_ReportingMode_Offset_c;  
  333:      pTransfOper->pBuff        = maDataTable;      
  334:      pTransfOper->buffLength   = 1;
  335:      pTransfOper->tpOperType   = mTP_OperType_Read_c;
  336:      
  337:      /* Prepare the second entry to be read: gesture types */
  338:      (++pTransfOper)->regAddr  = PDT_F11_2D_QUERY_BASE + m2D_GestureQuery_Offset_c; 
  339:      pTransfOper->pBuff        = maDataTable + 1;      
  340:      pTransfOper->buffLength   = 2;
  341:      pTransfOper->tpOperType   = mTP_OperType_Read_c;    
  342:       
  343:      /* Prepare the third entry to be read: reporting mode */
  344:      (++pTransfOper)->regAddr  = PDT_F11_2D_CONTROL_BASE + m2D_ReportMode_Offset_c; 
  345:      pTransfOper->pBuff        = maDataTable + 3;      
  346:      pTransfOper->buffLength   = 1;
  347:      pTransfOper->tpOperType   = mTP_OperType_Read_c;               
  348:  
  349:      /* Prepare the fourth entry to be read: product id string */   
  350:      (++pTransfOper)->regAddr  = PDT_F01_RMI_QUERY_BASE + mRMI_ProductIdQuery0_Offset_c;
  351:      pTransfOper->pBuff        = maDataTable + 4;       
  352:      pTransfOper->buffLength   = gTP_ProdIdLengthMax_c;
  353:      pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  354:      
  355:      /* Prepare the fifth entry to be read: maximum X and Y position */               
  356:      (++pTransfOper)->regAddr  = PDT_F11_2D_CONTROL_BASE + m2D_MaxXPositionLow_Offset_c;
  357:      pTransfOper->pBuff        = maDataTable + 4 + gTP_ProdIdLengthMax_c;
  358:      pTransfOper->buffLength   = 4;
  359:      pTransfOper->tpOperType   = mTP_OperType_Read_c;             
  360:      
  361:      #if(DEBUG_MODE_ENABLE == 1)
  362:        /* Clear the left entries in the action table */
  363:        FLib_MemSet((maTP_I2cTransfOperTable + maTP_I2cTransfOperNo + 1), 0, (gTP_I2cTransfOperMaxSize_c - maTP_I2cTransfOperNo - 1) * sizeof(tpI2cTransfOper_t));
  364:                 
  365:        /* Keep clear the data table */
  366:        FLib_MemSet(maDataTable, 0, gTP_DataTableMaxSize_c);       
  367:      #endif  
  368:                       
  369:      /* Prepare the first IIC read operation */
  370:      maTP_I2cOperCurrIndex = 0;
  371:       
  372:      pTransfOper = maTP_I2cTransfOperTable;     
  373:      if(FALSE == TP_ReadBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))     
  374:      {
  375:        retStatus = TP_ERR_IIC_COMM;
  376:      }    
  377:    }  
  378:     
  379:    return retStatus;
  380:  #else
  381:    return  TP_OK;
  0000 4f       [1]             CLRA  
  382:  #endif   
  383:  }
  0001 8d       [7]             RTC   
  384:  
  385:  
  386:  /*****************************************************************************
  387:  * TP_GetDevConfig
  388:  * 
  389:  * Interface assumption:
  390:  *
  391:  * Return value: generic status code
  392:  *
  393:  * Configure the list of gestures to be identified together with their 
  394:  * associated parameters
  395:  *****************************************************************************/
  396:  statusCode_t TP_GetDevConfig(void)     
  397:  {
  398:  #if(gTouchpadIncluded_d == 1)
  399:    uint8_t retStatus         = TP_OK;
  400:    uint8_t maDataTableIndex  = 0;
  401:    tpI2cTransfOper_t* pTransfOper = maTP_I2cTransfOperTable;
  402:    
  403:    if(FALSE == gTP_CallbackInfo.devInfo.mHasGesture)
  404:    {
  405:      retStatus = TP_ERR_INVALID_PARAM;  
  406:    }
  407:    else
  408:    {    
  409:      /* Store the function id */
  410:      gTP_CallbackInfo.funcId = gTP_GetDevConfigId_c; 
  411:      
  412:      /* Fill the array with further operations to be accomplished in the TP_Task */       
  413:      maTP_I2cTransfOperNo = gTP_GetDevConfig_TransfOperNo_c;
  414:      if((TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasSingleTap) || 
  415:         (TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasDoubleTap) || 
  416:         (TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasTapAndHold))
  417:      {        
  418:        /* Prepare the current entry into the action table: maximum tap time */
  419:        pTransfOper->regAddr      = PDT_F11_2D_CONTROL_BASE + m2D_MaxTapTime_Offset_c;  
  420:        pTransfOper->pBuff        = maDataTable;
  421:        pTransfOper->buffLength   = 1;
  422:        pTransfOper->tpOperType   = mTP_OperType_Read_c;
  423:  
  424:        /* Prepare the current entry into the action table: maximum tap distance */      
  425:        (++pTransfOper)->regAddr  = PDT_F11_2D_CONTROL_BASE + m2D_MaxTapDistance_Offset_c; 
  426:        pTransfOper->pBuff        = maDataTable + 1;
  427:        pTransfOper->buffLength   = 1;
  428:        pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  429:        
  430:        /* Update the table index and transfer number */
  431:        maDataTableIndex +=2;          
  432:        maTP_I2cTransfOperNo +=2;
  433:        pTransfOper++;
  434:      }
  435:  
  436:      if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasFlick)
  437:      {
  438:        /* Prepare two entries into the action table: minimum flick distance and speed */      
  439:        pTransfOper->regAddr      = PDT_F11_2D_CONTROL_BASE + m2D_MinFlickDistance_Offset_c;  
  440:        pTransfOper->pBuff        = maDataTable + maDataTableIndex;
  441:        pTransfOper->buffLength   = 2;
  442:        pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  443:        
  444:        /* Update the table index */
  445:        maDataTableIndex +=2; 
  446:        maTP_I2cTransfOperNo++;
  447:        pTransfOper++;         
  448:      }
  449:      
  450:      if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPress)
  451:      {
  452:        /* Prepare the current entry into the action table: minimum press time */      
  453:        pTransfOper->regAddr      = PDT_F11_2D_CONTROL_BASE + m2D_MinPressTime_Offset_c;  
  454:        pTransfOper->pBuff        = maDataTable + maDataTableIndex;
  455:        pTransfOper->buffLength   = 1;
  456:        pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  457:        
  458:        /* Update the table index and number of transfers */
  459:        maDataTableIndex++;  
  460:        maTP_I2cTransfOperNo++;
  461:        pTransfOper++;            
  462:      }
  463:      
  464:      if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPalm)
  465:      {     
  466:        pTransfOper->regAddr      = PDT_F11_2D_CONTROL_BASE + m2D_PalmReject_Offset_c;  
  467:        pTransfOper->pBuff        = maDataTable + maDataTableIndex;
  468:        pTransfOper->buffLength   = 1;
  469:        pTransfOper->tpOperType   = mTP_OperType_Read_c;  
  470:  
  471:        /* Update the table index and number of transfers */
  472:        maDataTableIndex++;  
  473:        maTP_I2cTransfOperNo++;
  474:        pTransfOper++;      
  475:      }       
  476:      
  477:      /* Prepare the read of functions supported by the device */  
  478:      pTransfOper->regAddr      = PDT_F01_RMI_CONTROL_BASE + mRMI_InterruptEnable0_Offset_c;  
  479:      pTransfOper->pBuff        = maDataTable + maDataTableIndex;
  480:      pTransfOper->buffLength   = 1;
  481:      pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  482:      
  483:      /* Update the table index */    
  484:      maDataTableIndex++;
  485:     
  486:      /* Prepare the read of gesture enabled by the device */
  487:      (++pTransfOper)->regAddr  = PDT_F11_2D_CONTROL_BASE + m2D_GestureEnable1_Offset_c;  
  488:      pTransfOper->pBuff        = maDataTable + maDataTableIndex;
  489:      pTransfOper->buffLength   = 1;
  490:      pTransfOper->tpOperType   = mTP_OperType_Read_c;
  491:      
  492:      #if(DEBUG_MODE_ENABLE == 1)
  493:        /* Clear the remaining entries in the action table */
  494:        FLib_MemSet((maTP_I2cTransfOperTable + maTP_I2cTransfOperNo + 1), 0, (gTP_I2cTransfOperMaxSize_c - maTP_I2cTransfOperNo - 1) * sizeof(tpI2cTransfOper_t));
  495:        
  496:        /* Clear the data table before reading from it */      
  497:        FLib_MemSet(maDataTable, 0, gTP_DataTableMaxSize_c);     
  498:      #endif    
  499:        
  500:      /* Prepare the first IIC read operation */
  501:      maTP_I2cOperCurrIndex = 0;
  502:      
  503:      pTransfOper = maTP_I2cTransfOperTable;     
  504:      if(FALSE == TP_ReadBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))      
  505:      {
  506:        retStatus = TP_ERR_IIC_COMM;
  507:      }                              
  508:    }
  509:    
  510:    return retStatus; 
  511:  #else
  512:    return  TP_OK;
  0000 4f       [1]             CLRA  
  513:  #endif    
  514:  }
  0001 8d       [7]             RTC   
  515:  
  516:  
  517:  
  518:  /*****************************************************************************
  519:  * TP_SetDevConfig
  520:  * 
  521:  * Interface assumption:
  522:  *
  523:  * Return value: generic status code
  524:  *
  525:  * Configure the list of gestures to be identified together with their 
  526:  * associated parameters
  527:  *****************************************************************************/
  528:  statusCode_t TP_SetDevConfig (devConfig_t mDevConfig)
  529:  {      
  530:  #if(gTouchpadIncluded_d == 1)  
  531:    uint8_t retStatus = TP_OK;
  532:    bool_t  nextStep  = TRUE;
  533:    uint8_t dummy;
  534:    tpI2cTransfOper_t*  pTransfOper = maTP_I2cTransfOperTable;  
  535:         
  536:    if(FALSE == gTP_CallbackInfo.devInfo.mHasGesture)
  537:    {
  538:      retStatus =  TP_ERR_INVALID_PARAM;
  539:    }
  540:    else
  541:    {     
  542:      /* Store the function id */
  543:      gTP_CallbackInfo.funcId = gTP_SetDevConfigId_c;
  544:                      
  545:      /* Clear the data table */
  546:      FLib_MemSet(maDataTable, 0, gTP_DataTableMaxSize_c);
  547:         
  548:      /* Prepare the function to be available */ 
  549:      dummy = 0;               
  550:      if(TRUE == mDevConfig.mFuncIntEn.mGpioEn)
  551:      {
  552:        dummy |= gTP_GpioIntMask_c;    
  553:      } 
  554:  
  555:      if(TRUE == mDevConfig.mFuncIntEn.mDevStatusEn)
  556:      {
  557:        dummy |= gTP_StatusIntMask_c;       
  558:      }
  559:      #pragma MESSAGE DISABLE C5917               
  560:      if(TRUE == mDevConfig.mFuncIntEn.mSelfTestEn)
  561:      {          
  562:        dummy |= gTP_BistIntMask_c;                        
  563:      }
  564:           
  565:      if(TRUE == mDevConfig.mFuncIntEn.mFlashEn)
  566:      {
  567:        dummy |= gTP_FlashIntMask_c;       
  568:      }                      
  569:          
  570:      if(TRUE == mDevConfig.mFuncIntEn.mSensorEn)
  571:      {
  572:        dummy |= gTP_Abs0IntMask_c;                  
  573:      }
  574:        
  575:      /* Update the maDataTable[1] */
  576:      maDataTable[1] = dummy;
  577:               
  578:      /* Prepare the gestures available */
  579:      dummy = 0;
  580:      /* Single tap */    
  581:      if(TRUE == mDevConfig.mGestIntEn.mSingleTapIntEn)
  582:      {
  583:        if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasSingleTap)
  584:        {
  585:          /* Add the 'single tap' to the gesture list */         
  586:          dummy |= gTP_SingleTapMask_c;        
  587:        }
  588:        else
  589:        {
  590:          retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  591:          nextStep = FALSE;        
  592:        }
  593:      }     
  594:      
  595:      /* Double tap */
  596:      if(TRUE == nextStep)
  597:      {       
  598:        if(TRUE == mDevConfig.mGestIntEn.mDoubleTapIntEn)
  599:        {
  600:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasDoubleTap)
  601:          {
  602:            /* Add the 'double tap' to the gesture list */            
  603:            dummy |= gTP_DoubleTapMask_c;               
  604:          }
  605:          else
  606:          {
  607:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  608:            nextStep = FALSE;          
  609:          }
  610:        }                  
  611:      }    
  612:           
  613:      /* Tap and hold */
  614:      if(TRUE == nextStep)
  615:      {         
  616:        if(TRUE == mDevConfig.mGestIntEn.mTapAndHoldIntEn)
  617:        {
  618:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasTapAndHold)
  619:          {
  620:            /* Add the 'tap and hold' to the gesture list */            
  621:            dummy |= gTP_TapAndHoldMask_c;           
  622:          }
  623:          else
  624:          {
  625:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  626:            nextStep = FALSE;           
  627:          }
  628:        }                            
  629:      }        
  630:            
  631:      /* Flick */
  632:      if(TRUE == nextStep)
  633:      {
  634:        if(TRUE == mDevConfig.mGestIntEn.mFlickIntEn)
  635:        {
  636:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasFlick)
  637:          {
  638:            /* Add the 'flick' to the gesture list */            
  639:            dummy |= gTP_FlickMask_c;              
  640:          }
  641:          else
  642:          {
  643:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  644:            nextStep = FALSE;         
  645:          }
  646:        }      
  647:      }
  648:                
  649:      /* Press */
  650:      if(TRUE == nextStep)
  651:      {
  652:        if(TRUE == mDevConfig.mGestIntEn.mPressIntEn)
  653:        {
  654:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPress)
  655:          {
  656:            /* Add the 'press' to the gesture list */               
  657:            dummy |= gTP_PressMask_c;          
  658:          }
  659:          else
  660:          {
  661:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  662:            nextStep = FALSE;          
  663:          }
  664:        }            
  665:      }
  666:      
  667:      /* Pinch */
  668:      if(TRUE == nextStep)
  669:      {
  670:        if(TRUE == mDevConfig.mGestIntEn.mPinchIntEn)
  671:        {
  672:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPinch)
  673:          {
  674:            /* Add the 'pinch' to the gesture list */           
  675:            dummy |= gTP_PinchMask_c;            
  676:          }
  677:          else
  678:          {
  679:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  680:            nextStep = FALSE;          
  681:          }
  682:        }      
  683:      }       
  684:      
  685:      /* Store the configuration to the data table entry 2 */
  686:      maDataTable[2] = dummy; 
  687:      
  688:      /* Prepare for the next config update */
  689:      dummy = 0;    
  690:      /* Palm */
  691:      if(TRUE == nextStep)
  692:      {
  693:        if(TRUE == mDevConfig.mGestIntEn.mPalmIntEn)
  694:        {
  695:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPalm)
  696:          {
  697:            /* Add the 'palm' to the gesture list */            
  698:            dummy |= gTP_PalmMask_c;             
  699:          }
  700:          else
  701:          {
  702:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  703:            nextStep = FALSE;           
  704:          }
  705:        }               
  706:      }
  707:    
  708:      /* Rotate */
  709:      if(TRUE == nextStep)
  710:      {
  711:        if(TRUE == mDevConfig.mGestIntEn.mRotateIntEn)
  712:        {
  713:          if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasRotate)
  714:          {
  715:            /* Add the 'rotate' to the gesture list */            
  716:            dummy |= gTP_RotateMask_c;          
  717:          }
  718:          else
  719:          {
  720:            retStatus = TP_ERR_GESTURE_NOT_SUPPORTED;
  721:            nextStep = FALSE;           
  722:          }
  723:        }                  
  724:      }    
  725:      
  726:      /* Store the remaining of configuration to the data table */
  727:      maDataTable[3] = dummy; 
  728:      
  729:      if(TRUE == nextStep)     
  730:      {             
  731:        /* Fill the table with appropriate operations */
  732:        /* Store the number of operations */
  733:        maTP_I2cTransfOperNo = gTP_SetDevConfig_TransfOperNo_c;
  734:        
  735:        *maDataTable = gTP_Configured_c;
  736:        /* Prepare the first entry into the action table: write the Configure bit in the Device Control Register */
  737:        pTransfOper->regAddr      = PDT_F01_RMI_CONTROL_BASE + mRMI_DeviceControl_Offset_c;  
  738:        pTransfOper->pBuff        = maDataTable;
  739:        pTransfOper->buffLength   = 1;
  740:        pTransfOper->tpOperType   = mTP_OperType_Write_c;
  741:               
  742:        /* Prepare the second entry into the action table: write the list of function to be available */   
  743:        (++pTransfOper)->regAddr  = PDT_F01_RMI_CONTROL_BASE + mRMI_InterruptEnable0_Offset_c; 
  744:        pTransfOper->pBuff        = maDataTable + 1;
  745:        pTransfOper->buffLength   = 1;
  746:        pTransfOper->tpOperType   = mTP_OperType_Write_c;              
  747:        
  748:        /* Prepare the third entry into the action table: write the list of gestures to be enabled */
  749:        (++pTransfOper)->regAddr  = PDT_F11_2D_CONTROL_BASE + m2D_GestureEnable1_Offset_c;
  750:        pTransfOper->pBuff        = maDataTable + 2;        
  751:        if(!(*(maDataTable + 3)))           
  752:        {
  753:          pTransfOper->buffLength   = 1;        
  754:        }
  755:        else
  756:        {
  757:          pTransfOper->buffLength   = 2;             
  758:        }
  759:        pTransfOper->tpOperType   = mTP_OperType_Write_c;
  760:                                           
  761:        /* Prepare the fourth entry into the action table: read the Device status in order to check if configuration has done */
  762:        (++pTransfOper)->regAddr  = PDT_F01_RMI_DATA_BASE + mRMI_DeviceStatus_Offset_c; 
  763:        pTransfOper->pBuff        = maDataTable + 4;
  764:        pTransfOper->buffLength   = 1;
  765:        pTransfOper->tpOperType   = mTP_OperType_Read_c;             
  766:        
  767:        /* Prepare the fifth entry into the action table: read the Interrupt enable register to check if configuration has done */
  768:        (++pTransfOper)->regAddr  = PDT_F01_RMI_CONTROL_BASE + mRMI_InterruptEnable0_Offset_c;
  769:        pTransfOper->pBuff        = maDataTable + 5;  
  770:        pTransfOper->buffLength   = 1;
  771:        pTransfOper->tpOperType   = mTP_OperType_Read_c;
  772:        
  773:        /* Prepare the fifth entry into the action table:  read the Gesture Interrupt enable register to check if configuration has done */
  774:        (++pTransfOper)->regAddr  = PDT_F11_2D_CONTROL_BASE + m2D_GestureEnable1_Offset_c;
  775:        pTransfOper->pBuff        = maDataTable + 6;  
  776:        pTransfOper->buffLength   = 1;
  777:        pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  778:                
  779:        #if(DEBUG_MODE_ENABLE == 1) 
  780:          /* Clear the rest of the entries in the action table */
  781:          FLib_MemSet((maTP_I2cTransfOperTable + maTP_I2cTransfOperNo + 1), 0, (gTP_I2cTransfOperMaxSize_c - maTP_I2cTransfOperNo - 1) * sizeof(tpI2cTransfOper_t));                                                 
  782:        #endif
  783:        
  784:        /* Prepare the first IIC Write operation */
  785:        maTP_I2cOperCurrIndex = 0;
  786:        
  787:        pTransfOper = maTP_I2cTransfOperTable; 
  788:        if(FALSE == TP_WriteBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))    
  789:        {
  790:          retStatus = TP_ERR_IIC_COMM;     
  791:        }    
  792:      }
  793:    }
  794:     
  795:    return retStatus; 
  796:  #else
  797:    (void)  mDevConfig;
  798:    return  TP_OK;
  0000 4f       [1]             CLRA  
  799:  #endif  
  800:  }
  0001 8d       [7]             RTC   
  801:  
  802:  
  803:  /*****************************************************************************
  804:  * TP_SetCallback
  805:  * 
  806:  * Interface assumption:
  807:  *
  808:  * Return value: generic status code
  809:  *
  810:  * Provides a pointer to the callback function for any touchpad event
  811:  *****************************************************************************/
  812:  statusCode_t TP_SetCallback(tpCallback_t callback)
  813:  {  
  814:  #if(gTouchpadIncluded_d == 1)  
  815:    uint8_t retStatus = TP_OK;
  816:  
  817:    if(NULL == callback)
  818:    {
  819:      retStatus = TP_ERR_INVALID_PARAM;
  820:    }
  821:    else
  822:    {
  823:      pfTpCallback = callback;    
  824:    }
  825:    
  826:    return retStatus;
  827:  #else
  828:    (void) callback;
  829:    return TP_OK;     
  0000 4f       [1]             CLRA  
  830:  #endif    
  831:  }
  0001 8d       [7]             RTC   
  832:  
  833:  
  834:  /****************************************************************************/
  835:  /* Place it in NON_BANKED memory */
  836:  #ifdef MEMORY_MODEL_BANKED
  837:  #pragma CODE_SEG __NEAR_SEG NON_BANKED
  838:  #else
  839:  #pragma CODE_SEG DEFAULT
  840:  #endif  /* MEMORY_MODEL_BANKED */
  841:  /* TP Interrupt Service Routine */
  842:  
  843:  #if(gTP_Mode_c == gTP_PollingMode_c)
  844:  /* When touchpad is used in polling mode, TP_InterruptHandler
  845:  should be called periodically by the application and is not 
  846:  an interrupt handler */
  847:  void TP_InterruptHandler(void)  
  848:  #else
  849:  INTERRUPT_KEYWORD void TP_InterruptHandler(void)
  850:  #endif
  851:  {
  852:  #if(gTouchpadIncluded_d == 1)  
  853:    #if(gTP_Mode_c == gTP_IrqIsrMode_c)
  854:      /* Acknowledge the external IRQ interrupt event */
  855:      m_IRQSC_c |= mIRQSC_IRQACK_c;
  856:    #endif
  857:    #if(gTP_Mode_c == gTP_KbiIsrMode_c)
  858:      /* Acknowledge the KBI2P0 interrupt event */
  859:      m_KBI2SC_c |= mKBI2SC_KBACK_c;
  860:    #endif
  861:    
  862:    if(gTP_CallbackInfo.funcId)
  863:    {
  864:      if(gTP_CallbackInfo.funcId != gTP_DevRestartId_c) 
  865:      {
  866:        /* Store the function identifier */ 
  867:        gTP_CallbackInfo.funcId = gTP_IsrId_c;                                
  868:      }
  869:      else
  870:      {
  871:        gTP_DevResetIdx++;
  872:      }
  873:      
  874:      /* Send event to the TP_Task */
  875:      TS_SendEvent(gTP_TaskId, gTP_Event_ISR_c);                            
  876:    }
  877:          
  878:  #endif    
  879:  }
  0000 81       [6]             RTS   
  880:  #pragma CODE_SEG DEFAULT
  881:  
  882:  #if(gTouchpadIncluded_d == 1) 
  883:    /*****************************************************************************
  884:    * TP_Task
  885:    * 
  886:    * Interface assumption:
  887:    *
  888:    * Return value: generic status code
  889:    *
  890:    * 
  891:    *****************************************************************************/
  892:    void TP_Task(event_t events)  
  893:    { 
  894:      volatile uint8_t iFingerNum;
  895:      uint8_t operType; 
  896:      tpI2cTransfOper_t* pTransfOper = maTP_I2cTransfOperTable;
  897:                    
  898:      if(events & gTP_Event_ISR_c)
  899:      { /* Events from the TP_ISR */
  900:        if(gTP_CallbackInfo.funcId == gTP_IsrId_c) 
  901:        {                   
  902:          maTP_I2cTransfOperNo = gTP_Isr_TransfOperNo_c;     
  903:          
  904:          /* Prepare the first entry in the table of actions: Device Status */
  905:          pTransfOper->regAddr      = PDT_F01_RMI_DATA_BASE + mRMI_DeviceStatus_Offset_c;
  906:          pTransfOper->pBuff        = maDataTable;
  907:          pTransfOper->buffLength   = 1;
  908:          pTransfOper->tpOperType   = mTP_OperType_Read_c;         
  909:          
  910:          /* Prepare the second entry in the table of actions: Interrupt status: this should deassert the ATTN line */
  911:          (++pTransfOper)->regAddr  = PDT_F01_RMI_DATA_BASE + mRMI_InterruptStatus_Offset_c;
  912:          pTransfOper->pBuff        = maDataTable + 1;
  913:          pTransfOper->buffLength   = 1;
  914:          pTransfOper->tpOperType   = mTP_OperType_Read_c;        
  915:          
  916:          /* Prepare the third entry into the table of operation: finger info and gestures status */
  917:          (++pTransfOper)->regAddr  = PDT_F11_2D_DATA_BASE + m2D_FingerState_Offset_c;
  918:          pTransfOper->pBuff        = maDataTable + 2;
  919:          pTransfOper->buffLength   = gBlockSize;
  920:          pTransfOper->tpOperType   = mTP_OperType_Read_c;      
  921:  
  922:          #if(DEBUG_MODE_ENABLE == 1)
  923:            /* Clear all entries in the action table before filling with necessary actions */
  924:            FLib_MemSet((maTP_I2cTransfOperTable + maTP_I2cTransfOperNo + 1), 0, (gTP_I2cTransfOperMaxSize_c - maTP_I2cTransfOperNo - 1) * sizeof(tpI2cTransfOper_t));
  925:  
  926:            /* Keep clear the data table */
  927:            FLib_MemSet(maDataTable, 0, gTP_DataTableMaxSize_c);     
  928:          #endif      
  929:          
  930:          /* Prepare the first IIC read operation */
  931:          maTP_I2cOperCurrIndex = 0;
  932:          
  933:          pTransfOper = maTP_I2cTransfOperTable;
  934:          if(FALSE == TP_ReadBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))    
  935:          {
  936:            /* Call the application callback with the error status of the initial function */
  937:            gTP_CallbackInfo.status = FALSE;
  938:            
  939:            pfTpCallback(gTP_CallbackInfo);  
  940:          }           
  941:        }
  942:        else
  943:        {
  944:          if((gTP_CallbackInfo.funcId == gTP_DevRestartId_c) && (gTP_DevResetIdx == 2))      
  945:          {
  946:            /* Send event to the TP_Task */
  947:            TS_SendEvent(gTP_TaskId, gTP_Event_WriteBlockSuccess_c);         
  948:          }
  949:        }
  950:      }
  951:      else if((events & gTP_Event_ReadBlockSuccess_c) || (events & gTP_Event_WriteBlockSuccess_c))
  952:      {
  953:        uint8_t functId = gTP_CallbackInfo.funcId; 
  954:        
  955:        /* The following operations are valid only for 'GetDevInfo()', 'GetGesturesConfig()', 'TP_ISR()', 'SetGesturesList()', 'TP_RestartDevice()' functions */
  956:        if(functId && (functId <= gTP_DevRestartId_c))
  957:        {
  958:          /* Check if the operation is the last one in the list */
  959:          if(++maTP_I2cOperCurrIndex <= maTP_I2cTransfOperNo)
  960:          {
  961:            /* For the device restart function if the reset didn't finished, then take no action */
  962:            if((maTP_I2cOperCurrIndex == 1) && (functId == gTP_DevRestartId_c))
  963:            {
  964:              if(gTP_DevResetIdx < 2) 
  965:              {
  966:                /* Decrement the current transfer (previously incremented in the condition) because the action should not be taken, then leaves the function */
  967:                maTP_I2cOperCurrIndex--;
  968:                return; 
  969:              }
  970:            }
  971:                    
  972:            /* Check the type of the next transfer over the I2C: read or write */
  973:            pTransfOper = maTP_I2cTransfOperTable + maTP_I2cOperCurrIndex;
  974:            operType = pTransfOper->tpOperType;        
  975:            
  976:            if(mTP_OperType_Read_c == operType)
  977:            {                 
  978:              /* Prepare the next transfer over the I2C */
  979:              if(FALSE == TP_ReadBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))    
  980:              {
  981:                /* Call the application callback with the error status of the initial function */
  982:                gTP_CallbackInfo.status = FALSE;
  983:              
  984:                pfTpCallback(gTP_CallbackInfo);      
  985:              }               
  986:            }
  987:            else if(mTP_OperType_Write_c == operType)
  988:            {                                                       
  989:              /* Prepare the next transfer over the I2C */
  990:              if(FALSE == TP_WriteBlock(pTransfOper->regAddr, pTransfOper->buffLength, pTransfOper->pBuff))    
  991:              {
  992:                /* Call the application callback with the error status of the initial function */        
  993:                gTP_CallbackInfo.status = FALSE;
  994:              
  995:                pfTpCallback(gTP_CallbackInfo);     
  996:              }          
  997:            }               
  998:          }
  999:          else
 1000:          {     
 1001:            switch(functId)
 1002:            {
 1003:              case gTP_GetDevInfoId_c:
 1004:                      TP_SaveDevInfo();                      
 1005:                                                
 1006:                      /* Update the status of the callback */  
 1007:                      gTP_CallbackInfo.status = TRUE;                                                              
 1008:                      break;
 1009:                
 1010:              case gTP_GetDevConfigId_c:
 1011:                      TP_SaveDevConfig();
 1012:                                                           
 1013:                      /* Update the status of the callback */ 
 1014:                      gTP_CallbackInfo.status = TRUE;                                                                         
 1015:                      break;
 1016:              
 1017:              case gTP_SetDevConfigId_c:                              
 1018:                      /* Call the application callback with the success status of the initial function */                     
 1019:                      gTP_DevStatus = *(maDataTable + 4);
 1020:                      
 1021:                      /* Set the returned status of the function */
 1022:                      if((!(gTP_DevStatus & gTP_Unconfigured_c)) && (*(maDataTable + 1) == *(maDataTable + 5)) && (*(maDataTable + 2) == *(maDataTable + 6)))
 1023:                      {
 1024:                        gTP_CallbackInfo.status = TRUE; 
 1025:                      }
 1026:                      else
 1027:                      {
 1028:                        gTP_CallbackInfo.status = FALSE;
 1029:                      }
 1030:                                       
 1031:                      /* Updates the available function and gesture list */
 1032:                      TP_UpdateDevConfig(*(maDataTable + 5), *(maDataTable + 6)); 
 1033:                      break;
 1034:                
 1035:              case gTP_IsrId_c:
 1036:                      /* Get the Interrupt and Device Status registers information */                                     
 1037:                      gTP_DevStatus = *maDataTable;
 1038:                      gTP_IntStatus = *(maDataTable + 1);
 1039:                      
 1040:                      /* Check if interrupt has occured due to finger presence on the sensor surface */
 1041:                      if(gTP_IntStatus & gTP_Abs0IntMask_c)
 1042:                      {
 1043:                        /* Process information about fingers position */
 1044:                        for(iFingerNum = 0; iFingerNum < gTP_MaxNoOfFingers; iFingerNum++)
 1045:                        {                       
 1046:                          
 1047:                          if(TP_OK != TP_GetFingerInfo(iFingerNum))              
 1048:                          {
 1049:                            /* Call the application callback with the error status of the initial function */   
 1050:                            gTP_CallbackInfo.status = FALSE;
 1051:                          
 1052:                            pfTpCallback(gTP_CallbackInfo);
 1053:                            return;                                        
 1054:                          }                                           
 1055:                        }
 1056:                          
 1057:                        /* Process information about gesture status */
 1058:                        TP_GestureRecognition();                          
 1059:                                                                                           
 1060:                        /* Prepare the status of the callback */             
 1061:                        gTP_CallbackInfo.status = TRUE;
 1062:                      }
 1063:                      else
 1064:                      {
 1065:                        /* Prepare the status of the callback */
 1066:                        gTP_CallbackInfo.status = FALSE;                    
 1067:                      }                                                                                       
 1068:                      break;
 1069:              
 1070:              case gTP_DevRestartId_c:                                    
 1071:                      /* Update the status of the callback */                
 1072:                      gTP_CallbackInfo.status = TRUE;                                                                                                               
 1073:                      break;
 1074:            }
 1075:            
 1076:            /* Call the application callback with the parameters updated */
 1077:            pfTpCallback(gTP_CallbackInfo);
 1078:          }      
 1079:        }   
 1080:      }
 1081:      else if(events & (gTP_Event_ReadBlockFail_c | gTP_Event_WriteBlockFail_c))
 1082:      {
 1083:        uint8_t functId = gTP_CallbackInfo.funcId;
 1084:        
 1085:        /* The following operations are valid only for 'GetDeviceInfo()', 'GetGesturesConfig()', 'TP_ISR()', 'SetGesturesList()', 'TP_RestartDevice()' functions */
 1086:        if(functId && (functId <= gTP_DevRestartId_c))
 1087:        {
 1088:          /* Call the application callback with the error status of the initial function */   
 1089:          gTP_CallbackInfo.status = FALSE;
 1090:              
 1091:          pfTpCallback(gTP_CallbackInfo);       
 1092:        }                        
 1093:      }         
 1094:    }
 1095:  
 1096:  
 1097:    /*****************************************************************************
 1098:    * TP_SaveDevInfo
 1099:    * 
 1100:    * Interface assumption:
 1101:    *
 1102:    * Return value: None
 1103:    *
 1104:    * 
 1105:    *****************************************************************************/
 1106:    static void TP_SaveDevInfo(void)
 1107:    {    
 1108:      uint8_t dummy;
 1109:           
 1110:      /* Fill the appropriate structure of type 'devInfo' with the default values */
 1111:      FLib_MemSet(&(gTP_CallbackInfo.devInfo), 0, sizeof(devInfo_t));
 1112:           
 1113:      /* Save the number of finger and other parameters (abs, rel values, gesture and sensitivity) */
 1114:      gTP_CallbackInfo.devInfo.mNoOfFingers  = (*maDataTable & gTP_NoOfFingersMask_c) + 1;  
 1115:      
 1116:      dummy = *maDataTable;  
 1117:      if(dummy & gTP_AbsModeMask_c)
 1118:      {
 1119:        gTP_CallbackInfo.devInfo.mHasAbs = TRUE;     
 1120:      }  
 1121:      if(dummy & gTP_RelModeMask_c)
 1122:      {
 1123:        gTP_CallbackInfo.devInfo.mHasRel = TRUE;
 1124:      }
 1125:      if(dummy & gTP_GestureMask_c)
 1126:      {
 1127:        gTP_CallbackInfo.devInfo.mHasGesture = TRUE;
 1128:      }
 1129:      if(dummy & gTP_SensAdjMask_c)
 1130:      {
 1131:        gTP_CallbackInfo.devInfo.mHasSensAdj = TRUE;
 1132:      }
 1133:               
 1134:      /* Save the gesture suite supported by the sensor */
 1135:      if(TRUE == gTP_CallbackInfo.devInfo.mHasGesture)
 1136:      {
 1137:        dummy = *(maDataTable + 1);
 1138:        if(dummy & gTP_SingleTapMask_c)
 1139:        {
 1140:          gTP_CallbackInfo.devInfo.mGestList.mHasSingleTap = TRUE;
 1141:        }
 1142:        if(dummy & gTP_DoubleTapMask_c)
 1143:        {
 1144:          gTP_CallbackInfo.devInfo.mGestList.mHasDoubleTap = TRUE; 
 1145:        }
 1146:        if(dummy & gTP_TapAndHoldMask_c)
 1147:        {
 1148:          gTP_CallbackInfo.devInfo.mGestList.mHasTapAndHold  = TRUE;
 1149:        }
 1150:        if(dummy & gTP_FlickMask_c)
 1151:        {
 1152:          gTP_CallbackInfo.devInfo.mGestList.mHasFlick = TRUE;
 1153:        }
 1154:        if(dummy & gTP_PressMask_c)
 1155:        {
 1156:          gTP_CallbackInfo.devInfo.mGestList.mHasPress = TRUE; 
 1157:        }
 1158:        if(dummy & gTP_PinchMask_c)
 1159:        {
 1160:          gTP_CallbackInfo.devInfo.mGestList.mHasPinch = TRUE; 
 1161:        }
 1162:        
 1163:        dummy = *(maDataTable + 2);
 1164:        if(dummy & gTP_RotateMask_c)
 1165:        {
 1166:          gTP_CallbackInfo.devInfo.mGestList.mHasRotate = TRUE; 
 1167:        }
 1168:        if(dummy & gTP_PalmMask_c)
 1169:        {
 1170:          gTP_CallbackInfo.devInfo.mGestList.mHasPalm = TRUE; 
 1171:        }                              
 1172:      }
 1173:      
 1174:      /* Save the reported mode */
 1175:      gTP_CallbackInfo.devInfo.mReportedMode  = *(maDataTable + 3)  & gTP_ReportingModeMask_c;
 1176:            
 1177:      /* Save the product id string */
 1178:      FLib_MemCpy(gTP_CallbackInfo.devInfo.mProdId, (maDataTable + 4), gTP_ProdIdLengthMax_c);
 1179:           
 1180:      /* Save the maximum X and Y positions */
 1181:      gTP_CallbackInfo.devInfo.mMaxXPos = (uint16_t)(*(maDataTable + gTP_ProdIdLengthMax_c + 4) + (*(maDataTable + gTP_ProdIdLengthMax_c + 5) << 8)); 
 1182:      gTP_CallbackInfo.devInfo.mMaxYPos = (uint16_t)(*(maDataTable + gTP_ProdIdLengthMax_c + 6) + (*(maDataTable + gTP_ProdIdLengthMax_c + 7) << 8)); 
 1183:            
 1184:      /* Update the 'gBlockSize' global variable further used in the TP_Task() function */
 1185:      /* Compute the block size to be read */
 1186:      if(TRUE == gTP_CallbackInfo.devInfo.mHasAbs)
 1187:      {
 1188:        gBlockSize += gTP_FingerAbsValSize_c;        
 1189:      }
 1190:      if(TRUE == gTP_CallbackInfo.devInfo.mHasRel)
 1191:      {
 1192:        gBlockSize += gTP_FingerRelValSize_c;        
 1193:      }
 1194:      /* Increase the total block size with size for each finger info block */
 1195:      gBlockSize *= gTP_CallbackInfo.devInfo.mNoOfFingers;
 1196:      
 1197:      /* Add to the total block size, the size of gesture status list and gestures parameters */
 1198:      gBlockSize += (gTP_GestureStatusSize_c + gTP_GestureInfoSize_c + TP_FingerStateSize(gTP_CallbackInfo.devInfo.mNoOfFingers));              
 1199:    }
 1200:  
 1201:  
 1202:    /*****************************************************************************
 1203:    * TP_SaveDevConfig
 1204:    * 
 1205:    * Interface assumption:
 1206:    *
 1207:    * Return value: None
 1208:    *
 1209:    * 
 1210:    *****************************************************************************/
 1211:    static void TP_SaveDevConfig(void)   
 1212:    {    
 1213:      uint8_t dummy;
 1214:      uint8_t* pDataTable = maDataTable;
 1215:      
 1216:             
 1217:      /* Fill the appropriate structure of type 'devConfig' with default values */
 1218:      FLib_MemSet(&(gTP_CallbackInfo.devConfig), 0, sizeof(devConfig_t));
 1219:      
 1220:      if((TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasSingleTap) || 
 1221:         (TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasDoubleTap) || 
 1222:         (TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasTapAndHold))
 1223:      {
 1224:          gTP_CallbackInfo.devConfig.mGestConfigParam.mTapConfigParam.mMaximumTapTime      = *(pDataTable++);
 1225:          gTP_CallbackInfo.devConfig.mGestConfigParam.mTapConfigParam.mMaximumTapDistance  = *(pDataTable++);    
 1226:      }
 1227:       
 1228:      if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasFlick)
 1229:      {
 1230:          gTP_CallbackInfo.devConfig.mGestConfigParam.mFlickConfigParam.mMinimumFlickDistance  = *(pDataTable++);
 1231:          gTP_CallbackInfo.devConfig.mGestConfigParam.mFlickConfigParam.mMinimumFlickSpeed     = *(pDataTable++); 
 1232:      }
 1233:      
 1234:      if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPress)
 1235:      {
 1236:          gTP_CallbackInfo.devConfig.mGestConfigParam.mPressConfigParam = *(pDataTable++);
 1237:      }
 1238:      
 1239:      if(TRUE == gTP_CallbackInfo.devInfo.mGestList.mHasPalm)
 1240:      {
 1241:        gTP_CallbackInfo.devConfig.mGestConfigParam.mPalmConfigParam = *(pDataTable++);
 1242:      }
 1243:  
 1244:      /* Save the information about the function and gestures enabled */
 1245:      dummy = *(maDataTable + 6);
 1246:      
 1247:      if(dummy & gTP_FlashIntMask_c)
 1248:      {
 1249:        gTP_CallbackInfo.devConfig.mFuncIntEn.mFlashEn = TRUE;    
 1250:      }
 1251:      if(dummy & gTP_BistIntMask_c)
 1252:      {
 1253:        gTP_CallbackInfo.devConfig.mFuncIntEn.mSelfTestEn = TRUE;
 1254:      }
 1255:      if(dummy & gTP_StatusIntMask_c)
 1256:      {
 1257:        gTP_CallbackInfo.devConfig.mFuncIntEn.mDevStatusEn = TRUE;
 1258:      }
 1259:      if(dummy & gTP_Abs0IntMask_c)
 1260:      {
 1261:        gTP_CallbackInfo.devConfig.mFuncIntEn.mSensorEn = TRUE;
 1262:      }  
 1263:      if(dummy & gTP_GpioIntMask_c)
 1264:      {
 1265:        gTP_CallbackInfo.devConfig.mFuncIntEn.mGpioEn = TRUE;
 1266:      }    
 1267:        
 1268:      /* Gestures enabled */   
 1269:      dummy = *(maDataTable + 7);
 1270:       
 1271:      if(dummy & gTP_PinchMask_c)
 1272:      {
 1273:        gTP_CallbackInfo.devConfig.mGestIntEn.mPinchIntEn = TRUE;    
 1274:      }
 1275:      if(dummy & gTP_PressMask_c)
 1276:      {
 1277:        gTP_CallbackInfo.devConfig.mGestIntEn.mPressIntEn = TRUE;    
 1278:      }
 1279:      if(dummy & gTP_FlickMask_c)
 1280:      {
 1281:        gTP_CallbackInfo.devConfig.mGestIntEn.mFlickIntEn = TRUE;     
 1282:      }
 1283:      if(dummy & gTP_DoubleTapMask_c)
 1284:      {
 1285:        gTP_CallbackInfo.devConfig.mGestIntEn.mDoubleTapIntEn = TRUE;     
 1286:      }
 1287:      if(dummy & gTP_TapAndHoldMask_c)
 1288:      {
 1289:        gTP_CallbackInfo.devConfig.mGestIntEn.mTapAndHoldIntEn = TRUE;     
 1290:      }
 1291:      if(dummy & gTP_SingleTapMask_c)
 1292:      {
 1293:        gTP_CallbackInfo.devConfig.mGestIntEn.mSingleTapIntEn = TRUE;     
 1294:      }                      
 1295:    }
 1296:  
 1297:  
 1298:    /*****************************************************************************
 1299:    * TP_UpdateDevConfig
 1300:    * 
 1301:    * Interface assumption:
 1302:    *
 1303:    * Return value: generic status code
 1304:    *
 1305:    * 
 1306:    *****************************************************************************/
 1307:    static void TP_UpdateDevConfig(uint8_t mIntEn0Reg, uint8_t mGestEn1Reg)   
 1308:    {
 1309:      uint8_t dummy;
 1310:      
 1311:      /* Fill the appropriate structures of types 'funcIntEn_t' and 'gestIntEn_t' with default values */
 1312:      FLib_MemSet(&(gTP_CallbackInfo.devConfig), 0, sizeof(funcIntEn_t) + sizeof(gestIntEn_t));
 1313:        
 1314:      /* Update the function enable interrupt list */
 1315:      dummy = mIntEn0Reg;    
 1316:      if(dummy & gTP_FlashIntMask_c)
 1317:      {
 1318:        gTP_CallbackInfo.devConfig.mFuncIntEn.mFlashEn = TRUE;   
 1319:      }
 1320:      if(dummy & gTP_BistIntMask_c)
 1321:      {
 1322:        gTP_CallbackInfo.devConfig.mFuncIntEn.mSelfTestEn = TRUE;       
 1323:      }
 1324:      if(dummy & gTP_StatusIntMask_c)
 1325:      {
 1326:        gTP_CallbackInfo.devConfig.mFuncIntEn.mDevStatusEn = TRUE;       
 1327:      }
 1328:      if(dummy & gTP_Abs0IntMask_c)
 1329:      {
 1330:        gTP_CallbackInfo.devConfig.mFuncIntEn.mSensorEn = TRUE;       
 1331:      }
 1332:      if(dummy & gTP_GpioIntMask_c)
 1333:      {
 1334:        gTP_CallbackInfo.devConfig.mFuncIntEn.mGpioEn = TRUE;      
 1335:      } 
 1336:      
 1337:      /* Update the gesture enable interrupt list */
 1338:      dummy = mGestEn1Reg; 
 1339:      if(dummy & gTP_PinchMask_c)
 1340:      {
 1341:        gTP_CallbackInfo.devConfig.mGestIntEn.mPinchIntEn = TRUE;    
 1342:      }
 1343:      if(dummy & gTP_PressMask_c)
 1344:      {
 1345:        gTP_CallbackInfo.devConfig.mGestIntEn.mPressIntEn = TRUE;        
 1346:      }
 1347:      if(dummy & gTP_FlickMask_c)
 1348:      {
 1349:        gTP_CallbackInfo.devConfig.mGestIntEn.mFlickIntEn = TRUE;        
 1350:      }
 1351:      if(dummy & gTP_DoubleTapMask_c)
 1352:      {
 1353:        gTP_CallbackInfo.devConfig.mGestIntEn.mDoubleTapIntEn = TRUE;        
 1354:      }
 1355:      if(dummy & gTP_TapAndHoldMask_c)
 1356:      {
 1357:        gTP_CallbackInfo.devConfig.mGestIntEn.mTapAndHoldIntEn = TRUE;        
 1358:      } 
 1359:      if(dummy & gTP_SingleTapMask_c)
 1360:      {
 1361:        gTP_CallbackInfo.devConfig.mGestIntEn.mSingleTapIntEn = TRUE;        
 1362:      }                    
 1363:    }
 1364:  
 1365:  
 1366:    /*****************************************************************************
 1367:    * TP_GetFingerInfo
 1368:    * 
 1369:    * Interface assumption:
 1370:    *
 1371:    * Return value: generic status code
 1372:    *
 1373:    * 
 1374:    *****************************************************************************/
 1375:    static statusCode_t TP_GetFingerInfo(uint8_t mFingerNum)
 1376:    {  
 1377:      statusCode_t  retStatus = TP_OK;
 1378:      uint8_t       mFingerShift, mFingerStateSize;
 1379:      uint8_t       maDataTableIndex;
 1380:      uint8_t*      pDataTable; 
 1381:      fingerInfo_t* pFingerInfo = &gTP_CallbackInfo.fingerInfo[mFingerNum];
 1382:      
 1383:      /* Input parameters checking */  
 1384:      if(mFingerNum > gTP_CallbackInfo.devInfo.mNoOfFingers)
 1385:      {
 1386:        retStatus = TP_ERR_INVALID_PARAM;   
 1387:      }
 1388:      else
 1389:      {
 1390:        mFingerStateSize =(uint8_t) TP_FingerStateSize(gTP_CallbackInfo.devInfo.mNoOfFingers);
 1391:        maDataTableIndex = mFingerStateSize - 1;
 1392:        mFingerShift = (uint8_t)((2*mFingerNum) % 8);    
 1393:           
 1394:        /* Get the status finger */    
 1395:        pFingerInfo->mFingerStatus = (*(maDataTable + maDataTableIndex + 2) >> mFingerShift) & gTP_FingerStateMask_c; 
 1396:        
 1397:        if(TRUE == gTP_CallbackInfo.devInfo.mHasAbs)
 1398:        {
 1399:          if(TRUE == gTP_CallbackInfo.devInfo.mHasRel)
 1400:          {
 1401:            /* Compute the current index in the data table where info about finger are */
 1402:            maDataTableIndex = (mFingerNum * gTP_MaxFingerInfoSize_c) + mFingerStateSize;
 1403:            /* First two table entries are allocated for Interrupt and Device Status Registers so the index should be incremented */
 1404:            maDataTableIndex += 2;         
 1405:            
 1406:            /* Update the pointer to the data table */
 1407:            pDataTable = maDataTable + maDataTableIndex + gTP_FingerAbsValSize_c;
 1408:            
 1409:            /* Get the relative values */
 1410:            pFingerInfo->mDeltaX = *(pDataTable);
 1411:            pFingerInfo->mDeltaY = *(pDataTable + 1);
 1412:          }
 1413:          else
 1414:          {
 1415:            /* Compute the current index in the data table where info about finger are */
 1416:            maDataTableIndex = (mFingerNum * gTP_FingerAbsValSize_c) + mFingerStateSize;         
 1417:            /* First two table entries are allocated for Interrupt and Device Status Registers so the index should be incremented */
 1418:            maDataTableIndex += 2; 
 1419:            
 1420:            /* Put the relative values to zero */
 1421:            pFingerInfo->mDeltaX = 0;        
 1422:            pFingerInfo->mDeltaY = 0;          
 1423:          }
 1424:          
 1425:          /* Update the pointer to the data table */
 1426:          pDataTable = maDataTable + maDataTableIndex;
 1427:          
 1428:          /* Get the absolute values */
 1429:          /* Get the X, Y position */
 1430:          pFingerInfo->mPosX = ((uint16_t)(*(pDataTable) << 4) + (*(pDataTable + 2) & gTP_LowNibbleMask_c));
 1431:          pFingerInfo->mPosY = ((uint16_t)(*(pDataTable + 1) << 4) + ((*(pDataTable + 2) & gTP_HighNibbleMask_c) >> 4));          
 1432:                         
 1433:          /* Get the finger width for X and Y */
 1434:          pFingerInfo->mWidthX = *(pDataTable + 3) & gTP_LowNibbleMask_c;
 1435:          pFingerInfo->mWidthY = *(pDataTable + 3) >> 4;       
 1436:             
 1437:          /* Get the finger strength */
 1438:          pFingerInfo->mFingerStrength = *(pDataTable + 4);           
 1439:        }
 1440:        else
 1441:        {
 1442:          maDataTableIndex = (mFingerNum * gTP_FingerRelValSize_c) + mFingerStateSize;          
 1443:          /* First two table entries are allocated for Interrupt and Device Status Registers so the index should be incremented */
 1444:          maDataTableIndex += 2; 
 1445:          
 1446:          /* Put absolute values to zero */ 
 1447:          pFingerInfo->mPosX = 0;
 1448:          pFingerInfo->mPosY = 0;
 1449:          pFingerInfo->mWidthX = 0;
 1450:          pFingerInfo->mFingerStrength = 0;       
 1451:                
 1452:          /* Get the relative values */ 
 1453:          pFingerInfo->mDeltaX = *(maDataTable + maDataTableIndex);
 1454:          pFingerInfo->mDeltaY = *(maDataTable + maDataTableIndex + 1);             
 1455:        }  
 1456:      }
 1457:                             
 1458:      return retStatus;    
 1459:    }
 1460:  
 1461:    /*****************************************************************************
 1462:    * TP_GestureRecognition
 1463:    * 
 1464:    * Interface assumption:
 1465:    *
 1466:    * Return value: generic status code
 1467:    *
 1468:    * 
 1469:    *****************************************************************************/
 1470:    static void TP_GestureRecognition(void)
 1471:    {    
 1472:      uint8_t maDataTableIndex = 0;
 1473:      uint8_t dummy;
 1474:      uint8_t *pDataTable;
 1475:      
 1476:      /* Fill the appropriate structures of type 'gestStatusList_t' and 'gestInfo_t' with default values */
 1477:      FLib_MemSet(&(gTP_CallbackInfo.gestStatusList), 0, sizeof(gestStatusList_t) + sizeof(gestInfo_t));
 1478:        
 1479:      /* Compute the current index in the data table where info about gesture are */
 1480:      if(TRUE == gTP_CallbackInfo.devInfo.mHasAbs)
 1481:      {
 1482:        maDataTableIndex = gTP_FingerAbsValSize_c;
 1483:      }
 1484:      if(TRUE == gTP_CallbackInfo.devInfo.mHasRel)
 1485:      {
 1486:        maDataTableIndex += gTP_FingerRelValSize_c; 
 1487:      }
 1488:      /* Update the position with the number of fingers */
 1489:      maDataTableIndex *= gTP_CallbackInfo.devInfo.mNoOfFingers;
 1490:      maDataTableIndex += TP_FingerStateSize(gTP_CallbackInfo.devInfo.mNoOfFingers); 
 1491:      /* First two table entries are allocated for Interrupt and Device Status Registers so the index should be incremented */
 1492:      maDataTableIndex += 2;
 1493:          
 1494:      /* Update the pointer to the data table then the gesture status list */
 1495:      pDataTable = maDataTable + maDataTableIndex;   
 1496:      dummy = *pDataTable; 
 1497:      /* Update again the pointer to the data table in orde to point to the gestures parameters */
 1498:      pDataTable += 2;
 1499:      
 1500:      if(dummy & gTP_PinchMask_c)
 1501:      {
 1502:        gTP_CallbackInfo.gestStatusList.mPinch      = TRUE;        
 1503:        gTP_CallbackInfo.gestInfo.mPinchGestureInfo = *(pDataTable);     
 1504:      }
 1505:      if(dummy & gTP_PressMask_c)
 1506:      {
 1507:        gTP_CallbackInfo.gestStatusList.mPress = TRUE;     
 1508:      }
 1509:      if(dummy & gTP_FlickMask_c)
 1510:      { 
 1511:        gTP_CallbackInfo.gestStatusList.mFlick = TRUE;
 1512:        gTP_CallbackInfo.gestInfo.mFlickGestureInfo.mFlickDistanceX = *(pDataTable); 
 1513:        gTP_CallbackInfo.gestInfo.mFlickGestureInfo.mFlickDistanceY = *(pDataTable + 1); 
 1514:        gTP_CallbackInfo.gestInfo.mFlickGestureInfo.mFlickTime      = *(pDataTable + 2);                
 1515:      }
 1516:      if(dummy & gTP_SingleTapMask_c)
 1517:      {
 1518:        gTP_CallbackInfo.gestStatusList.mSingleTap  = TRUE;     
 1519:      }
 1520:      if(dummy & gTP_DoubleTapMask_c)
 1521:      {
 1522:        gTP_CallbackInfo.gestStatusList.mDoubleTap  = TRUE;     
 1523:      }
 1524:      if(dummy & gTP_TapAndHoldMask_c)
 1525:      {
 1526:        gTP_CallbackInfo.gestStatusList.mTapAndHold = TRUE;     
 1527:      }
 1528:      
 1529:      /* Get palm and rotate status */
 1530:      dummy = *(maDataTable + maDataTableIndex + 1); 
 1531:      if(dummy & gTP_RotateMask_c)
 1532:      {
 1533:        gTP_CallbackInfo.gestStatusList.mRotate  = TRUE; 
 1534:        gTP_CallbackInfo.gestInfo.mRotateGestureInfo.mRotateMotion    = *(pDataTable + 1);
 1535:        gTP_CallbackInfo.gestInfo.mRotateGestureInfo.mFingersDistance = *(pDataTable + 2);    
 1536:      }
 1537:      if(dummy & gTP_PalmMask_c)
 1538:      {
 1539:        gTP_CallbackInfo.gestStatusList.mPalm = TRUE;        
 1540:      }     
 1541:    }
 1542:     
 1543:  
 1544:    /*****************************************************************************
 1545:    * TP_ReadBlock
 1546:    * 
 1547:    * Interface assumption:
 1548:    *
 1549:    * Return value: generic status code
 1550:    *
 1551:    * 
 1552:    *****************************************************************************/
 1553:    static bool_t TP_ReadBlock(uint8_t startAddr, uint8_t blockLength, uint8_t* pRxBuff)
 1554:    {     
 1555:      bool_t retStatus = FALSE;
 1556:           
 1557:      if(gRmiBlockAccess.accessLock == FALSE)
 1558:      {
 1559:        /* Prepare the structure to be used by the RmiWriteAddrCallback */
 1560:        gRmiBlockAccess.rmiBlockAccess.regAddr      = startAddr;
 1561:        gRmiBlockAccess.rmiBlockAccess.buffLength   = blockLength;
 1562:        gRmiBlockAccess.rmiBlockAccess.tpOperType   = mTP_OperType_Read_c;
 1563:        gRmiBlockAccess.rmiBlockAccess.pBuff        = pRxBuff;
 1564:        gRmiBlockAccess.accessLock                  = TRUE; 
 1565:        
 1566:        /* Transmit the start address of the RMI registers block */
 1567:        retStatus = IIC_Transmit_Master(&gRmiBlockAccess.rmiBlockAccess.regAddr, 
 1568:                                        gTP_RmiAddrByteSize_c, 
 1569:                                        gTP_SlaveAddress_c, 
 1570:                                        RmiWriteAddrCallback); 
 1571:        if(retStatus == FALSE)
 1572:        {
 1573:          gRmiBlockAccess.accessLock = FALSE; 
 1574:        }
 1575:      }
 1576:           
 1577:      return retStatus;  
 1578:    }
 1579:  
 1580:    /*****************************************************************************
 1581:    * TP_WriteBlock
 1582:    * 
 1583:    * Interface assumption:
 1584:    *
 1585:    * Return value: generic status code
 1586:    *
 1587:    * 
 1588:    *****************************************************************************/
 1589:    static bool_t TP_WriteBlock(uint8_t startAddr, uint8_t blockLength, uint8_t* pTxBuff)
 1590:    {    
 1591:      rmiBlockAccess_t* pRmiBlockAccess = &gRmiBlockAccess;
 1592:      bool_t            retStatus       = FALSE;
 1593:         
 1594:      if((pRmiBlockAccess->accessLock == FALSE) && (blockLength < gWriteBlockMaxSize_c))
 1595:      {  
 1596:        /* Prepare the structure to be used by the RmiCompleteAccessCallback */
 1597:        pRmiBlockAccess->rmiBlockAccess.regAddr      = startAddr; 
 1598:        pRmiBlockAccess->rmiBlockAccess.buffLength   = blockLength;
 1599:        pRmiBlockAccess->rmiBlockAccess.tpOperType   = mTP_OperType_Write_c;
 1600:        pRmiBlockAccess->rmiBlockAccess.pBuff        = pTxBuff;
 1601:        pRmiBlockAccess->accessLock                  = TRUE;   
 1602:                    
 1603:        *gWriteBlock = pRmiBlockAccess->rmiBlockAccess.regAddr; 
 1604:        FLib_MemCpy((gWriteBlock + 1), pTxBuff, blockLength);
 1605:                                                                      
 1606:        /* Start transmission over the IIC */
 1607:        retStatus = IIC_Transmit_Master(gWriteBlock, 
 1608:                                        blockLength + 1, 
 1609:                                        gTP_SlaveAddress_c, 
 1610:                                        RmiCompleteAccessCallback); 
 1611:        
 1612:        if(retStatus == FALSE)
 1613:        {
 1614:          pRmiBlockAccess->accessLock = FALSE; 
 1615:        }                                                                       
 1616:      }
 1617:      
 1618:      return retStatus;  
 1619:    } 
 1620:      
 1621:  
 1622:    /*****************************************************************************
 1623:    * RmiWriteAddrCallback
 1624:    * 
 1625:    * Interface assumption:
 1626:    *
 1627:    * Return value: none
 1628:    *
 1629:    * 
 1630:    *****************************************************************************/
 1631:    static void RmiWriteAddrCallback(bool_t status)
 1632:    {         
 1633:      if(gRmiBlockAccess.rmiBlockAccess.tpOperType  == mTP_OperType_Read_c)
 1634:      {
 1635:        if(FALSE == status)
 1636:        {
 1637:          /* Release the access to the 'gRmiBlockAccess' variable */
 1638:          gRmiBlockAccess.accessLock = FALSE;
 1639:                
 1640:          /* Send event to the TP_Task */
 1641:          TS_SendEvent(gTP_TaskId, gTP_Event_ReadBlockFail_c);  
 1642:        }
 1643:        else
 1644:        {
 1645:          if(FALSE == IIC_Receive_Master((uint8_t*)gRmiBlockAccess.rmiBlockAccess.pBuff, 
 1646:                                         gRmiBlockAccess.rmiBlockAccess.buffLength, 
 1647:                                         gTP_SlaveAddress_c, 
 1648:                                         RmiCompleteAccessCallback))        
 1649:          {
 1650:            /* Release the access to the 'gRmiBlockAccess' variable */
 1651:            gRmiBlockAccess.accessLock = FALSE;
 1652:                       
 1653:            /* Send event to the TP_Task */
 1654:            TS_SendEvent(gTP_TaskId, gTP_Event_ReadBlockFail_c);    
 1655:          }
 1656:        }
 1657:      }
 1658:    }
 1659:  
 1660:  
 1661:    /*****************************************************************************
 1662:    * RmiCompleteAccessCallback
 1663:    * 
 1664:    * Interface assumption:
 1665:    *
 1666:    * Return value: none
 1667:    *
 1668:    * 
 1669:    *****************************************************************************/
 1670:    static void RmiCompleteAccessCallback(bool_t status)
 1671:    {       
 1672:      event_t dummyEvent;
 1673:          
 1674:      if(gRmiBlockAccess.rmiBlockAccess.tpOperType == mTP_OperType_Read_c)
 1675:      {
 1676:        dummyEvent = (FALSE == status) ?  gTP_Event_ReadBlockFail_c : gTP_Event_ReadBlockSuccess_c; 
 1677:      }
 1678:      else
 1679:      { /* Write RMI block */            
 1680:        if(gRmiBlockAccess.rmiBlockAccess.tpOperType == mTP_OperType_Write_c)
 1681:        {
 1682:          dummyEvent = (FALSE == status) ?  gTP_Event_WriteBlockFail_c : gTP_Event_WriteBlockSuccess_c;     
 1683:        }
 1684:      }
 1685:      
 1686:      /* Release the access to the 'gRmiBlockAccess' variable */
 1687:      gRmiBlockAccess.accessLock = FALSE;
 1688:      
 1689:      /* Send event to the TP_Task */
 1690:      TS_SendEvent(gTP_TaskId, dummyEvent);  
 1691:    }
 1692:  #endif
 1693:   
