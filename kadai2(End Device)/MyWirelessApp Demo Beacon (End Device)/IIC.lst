*** EVALUATION ***
ANSI-C/cC++ Compiler for HC08 V-5.0.41 Build 12319, Nov 15 2012

    1:  /*****************************************************************************
    2:  * IIC Serial Port implementation.
    3:  *
    4:  * (c) Copyright 2008, Freescale, Inc. All rights reserved.
    5:  *
    6:  *
    7:  * No part of this document must be reproduced in any form - including copied,
    8:  * transcribed, printed or by any electronic means - without specific written
    9:  * permission from Freescale Semiconductor.
   10:  *
   11:  *****************************************************************************/
   12:  
   13:  #include "IIC.h"
   14:  #include "IIC_Interface.h"
   15:  #include "IoConfig.h"
   16:  #include "IrqControlLib.h"
   17:  
   18:  
   19:  #ifndef gMacStandAlone_d
   20:  #define gMacStandAlone_d 0
   21:  #endif
   22:  
   23:  #if gMacStandAlone_d
   24:    #include "Mac_Globals.h"
   25:  #endif
   26:  
   27:  /*Set the IIC task Priority  */
   28:  #ifndef gTsI2CTaskPriority_c
   29:  #define gTsI2CTaskPriority_c             0x05
   30:  #endif 
   31:  
   32:  /*****************************************************************************
   33:  ******************************************************************************
   34:  * Private macros
   35:  ******************************************************************************
   36:  *****************************************************************************/
   37:  
   38:  #if gIIC_Slave_TxDataAvailableSignal_Enable_c
   39:  
   40:  /* Verify if there is data to be received from the Slave */
   41:  #define IIC_IsTxDataAvailable()  ( (gIIC_TxDataAvailablePortDataReg_c & gIIC_TxDataAvailablePinMask_c) == 0)
   42:  #endif
   43:  /*****************************************************************************
   44:  ******************************************************************************
   45:  * Private type definitions
   46:  ******************************************************************************
   47:  *****************************************************************************/
   48:  /* The transmit code keeps a circular list of buffers to be sent */
   49:  typedef struct IIcTxBufRef_tag {
   50:    unsigned char const *pBuf;
   51:    void (*pfCallBack)(unsigned char const *pBuf);
   52:  } IIcTxBufRef_t;
   53:  
   54:  typedef enum
   55:    {
   56:      mIIC_OpType_Tx_c,
   57:      mIIC_OpType_Rx_c
   58:    }iicOpType_t;
   59:  
   60:  typedef struct iicMasterOp_tag {
   61:    iicOpType_t iicOpType;
   62:    uint8_t *pBuf;
   63:    uint8_t bufLen;
   64:  } iicMasterOp_t;
   65:  
   66:  /*****************************************************************************
   67:  ******************************************************************************
   68:  * Public memory definitions
   69:  ******************************************************************************
   70:  *****************************************************************************/
   71:  #if gIIC_Enabled_d
   72:  /* ID for IIC task */
   73:           tsTaskID_t   gIIcTaskId;
   74:  volatile index_t      mIIcRxBufferByteCount;
   75:  
   76:  #endif
   77:  
   78:  //extern void  (*pfIIcMasterCallBack)(void);
   79:  
   80:  
   81:  
   82:  /*****************************************************************************
   83:  ******************************************************************************
   84:  * Private memory definitions
   85:  ******************************************************************************
   86:  *****************************************************************************/
   87:  #if gIIC_Enabled_d
   88:  /* The leading index is the next position to store a buffer reference.
   89:      The trailing index is the buffer currently being transmitted.
   90:      Using a separate table for the buffer lengths reduces code size */    
   91:  static IIcTxBufRef_t  maIIcTxBufRefTable[gIIC_SlaveTransmitBuffersNo_c];
   92:  static index_t        maIIcTxBufLenTable[gIIC_SlaveTransmitBuffersNo_c];
   93:  static index_t        mIIcTxBufRefLeadingIndex;    /* Post-increment. */
   94:  static index_t        mIIcTxBufRefTrailingIndex;   /* Post-increment. */
   95:  
   96:  /* Callback table and index pointers */
   97:  static IIcTxBufRef_t  maIIcTxCallbackTable[gIIC_SlaveTransmitBuffersNo_c];
   98:  static index_t        maIIcTxCallbackLeadingIndex   = 0; 
   99:  static index_t        maIIcTxCallbackTrailingIndex  = 0; 
  100:  
  101:  /* I2C module has a small local circular Rx buffer to store data until the
  102:      application can retrieve it. In addition to the leading and trailing
  103:      indexes, the Rx code keeps a count of the number of bytes in the buffer. */
  104:  static uint8_t        maIIcRxBuf[gIIC_SlaveReceiveBufferSize_c];
  105:  static index_t        mIIcRxBufLeadingIndex;       /* Post-increment. */
  106:  static index_t        mIIcRxBufTrailingIndex;      /* Post-increment. */
  107:  /* Local variable to keep the I2C Rx callback provided by the application */
  108:  static void           (*pfIIcSlaveRxCallBack)(void);
  109:  static void           (*pfIIcMasterRxCallBack)(void (*pfCallBack)(void));
  110:  static void           (*pfIIcMasterTxCallBack)(bool_t status);
  111:  static iicMasterOp_t   mIICMasterOp;
  112:  
  113:  #endif
  114:  
  115:  #if 1 
  116:  void IIC_CycleWrite(uint8_t bout);
  117:  void IIC_RegWrite(uint8_t address, uint8_t reg, uint8_t val);
  118:  uint8_t IIC_RegRead(uint8_t address, uint8_t reg);
  119:  void IIC_CycleWrite(uint8_t bout);
  120:  uint8_t IIC_CycleRead(uint8_t byteLeft);
  121:  void IIC_Start(void);
  122:  void IIC_Stop(void);
  123:  void IIC_RepeatStart(void);
  124:  uint8_t IIC_StopRead(void);
  125:  void IIC_RegWriteN(uint8_t address, uint8_t reg1,uint8_t N,uint8_t *array);
  126:  void IIC_RegReadN(uint8_t address, uint8_t reg1, uint8_t N,uint8_t *array);
  127:  void IIC_Bus_Reset(void);
  128:  
  129:  #endif
  130:  
  131:  static uint16_t timeout;
  132:    
  133:  
  134:  #if 0
  135:  void IIC_SetCallBack(void (*pfCallBack)(void)) {
  136:  	
  137:  	pfIIcMasterCallBack = pfCallBack;
  138:  	  	  
  139:  }
  140:  #endif
  141:  /*****************************************************************************
  142:  *   IIC_ModuleInit 
  143:  *
  144:  *   Initializes the I2C module 
  145:  ******************************************************************************/
  146:  void IIC_ModuleInit(void)
  147:  {
  148:  #if gIIC_Enabled_d  
  149:    /* Configure the I2C hardware peripheral */
  150:    mIIC_C_c = mIICC_Reset_c;
  0000 3f6c     [5]             CLR   108
  151:    /* Clear the I2C Rx software buffer */
  152:    mIIcRxBufLeadingIndex = mIIcRxBufTrailingIndex = mIIcRxBufferByteCount = 0;
  0002 4f       [1]             CLRA  
  0003 450000   [3]             LDHX  @mIIcRxBufferByteCount
  0006 f7       [2]             STA   ,X
  0007 f6       [3]             LDA   ,X
  0008 c70000   [4]             STA   mIIcRxBufTrailingIndex
  000b c70000   [4]             STA   mIIcRxBufLeadingIndex
  153:    pfIIcSlaveRxCallBack = NULL;
  000e 5f       [1]             CLRX  
  000f 8c       [1]             CLRH  
  0010 960001   [5]             STHX  pfIIcSlaveRxCallBack:1
  0013 cf0000   [4]             STX   pfIIcSlaveRxCallBack
  154:    pfIIcMasterTxCallBack = NULL;
  0016 960001   [5]             STHX  pfIIcMasterTxCallBack:1
  0019 cf0000   [4]             STX   pfIIcMasterTxCallBack
  155:    
  156:    #if  gIIC_Slave_TxDataAvailableSignal_Enable_c
  157:  /* Configure as output the GPIO that will be used to signal to the host that
  158:       the blackBox I2C slave device has data to be transmitted */
  159:  /* Signal to the host that there are no data available to be read */     
  160:    gIIC_TxDataAvailablePortDataReg_c |= gIIC_TxDataAvailablePinMask_c; 
  161:    gIIC_TxDataAvailablePortDDirReg_c |= gIIC_TxDataAvailablePinMask_c;
  162:  #endif
  163:  
  164:    mIIC_S_c = mIICS_Init_c;   
  001c 6e126d   [4]             MOV   #18,109
  165:    mIIC_F_c = gIIC_DefaultBaudRate_c;
  001f 6e1d6b   [4]             MOV   #29,107
  166:  
  167:    #if defined(PROCESSOR_MC1323X)  
  168:    IIC1C2 = mIICxC2_Init_c; 
  0022 3f6f     [5]             CLR   111
  169:  #endif
  170:   /* Create I2C module main task */
  171:    //IIC_TaskInit();
  172:  
  173:    mIIC_C_c = mIICC_IICEN_c; // Polling base
  0024 6e806c   [4]             MOV   #-128,108
  174:  
  175:  #endif  
  176:  }
  0027 8d       [7]             RTC   
  177:  
  178:  
  179:  
  180:  /*********************************************************\
  181:  * Initiate IIC Bus Reset
  182:  \*********************************************************/
  183:  
  184:  void IIC_Bus_Reset(void)
  185:  {
  0000 a7ec     [2]             AIS   #-20
  186:        int loop;
  187:          
  188:        // Disable the I2C block on the Host Controller 
  189:        IICC1 &= ~(init_IICC1);            
  0002 1f6c     [5]             BCLR  7,108
  190:  
  191:        PAUSE;
  0004 95       [2]             TSX   
  0005 6f03     [5]             CLR   3,X
  0007 6f02     [5]             CLR   2,X
  0009          L9:     
  0009 9d       [1]             NOP   
  000a 95       [2]             TSX   
  000b 6c03     [5]             INC   3,X
  000d 2602     [3]             BNE   L11 ;abs = 0011
  000f 6c02     [5]             INC   2,X
  0011          L11:    
  0011 9efe03   [5]             LDHX  3,SP
  0014 650019   [3]             CPHX  #25
  0017 91f0     [3]             BLT   L9 ;abs = 0009
  192:               
  193:        /* Create START condition (SDA goes low while SCL is high) */
  194:        I2C_SDA_DD_L;   // SDA = 0   //PTA5 
  0019 1a01     [5]             BSET  5,1
  001b 1b00     [5]             BCLR  5,0
  195:        PAUSE;
  001d 95       [2]             TSX   
  001e 6f05     [5]             CLR   5,X
  0020 6f04     [5]             CLR   4,X
  0022          L22:    
  0022 9d       [1]             NOP   
  0023 95       [2]             TSX   
  0024 6c05     [5]             INC   5,X
  0026 2602     [3]             BNE   L2A ;abs = 002a
  0028 6c04     [5]             INC   4,X
  002a          L2A:    
  002a 9efe05   [5]             LDHX  5,SP
  002d 650019   [3]             CPHX  #25
  0030 91f0     [3]             BLT   L22 ;abs = 0022
  196:        I2C_SCL_DD_H;   // SCL = 1   //PTA6
  0032 1d01     [5]             BCLR  6,1
  197:        PAUSE;
  0034 95       [2]             TSX   
  0035 6f07     [5]             CLR   7,X
  0037 6f06     [5]             CLR   6,X
  0039          L39:    
  0039 9d       [1]             NOP   
  003a 95       [2]             TSX   
  003b 6c07     [5]             INC   7,X
  003d 2602     [3]             BNE   L41 ;abs = 0041
  003f 6c06     [5]             INC   6,X
  0041          L41:    
  0041 9efe07   [5]             LDHX  7,SP
  0044 650019   [3]             CPHX  #25
  0047 91f0     [3]             BLT   L39 ;abs = 0039
  198:  
  199:        /* Release SDA back high */
  200:        I2C_SDA_DD_H;   // SDA = 1
  0049 1b01     [5]             BCLR  5,1
  201:        PAUSE;
  004b 95       [2]             TSX   
  004c 6f09     [5]             CLR   9,X
  004e 6f08     [5]             CLR   8,X
  0050          L50:    
  0050 9d       [1]             NOP   
  0051 95       [2]             TSX   
  0052 6c09     [5]             INC   9,X
  0054 2602     [3]             BNE   L58 ;abs = 0058
  0056 6c08     [5]             INC   8,X
  0058          L58:    
  0058 9efe09   [5]             LDHX  9,SP
  005b 650019   [3]             CPHX  #25
  005e 91f0     [3]             BLT   L50 ;abs = 0050
  202:      
  203:        /* Clock SCL for at least 9 clocks until SDA goes high */
  204:        loop = 0;
  0060 95       [2]             TSX   
  0061 6f01     [5]             CLR   1,X
  0063 7f       [4]             CLR   ,X
  205:  
  206:        while (loop < 90)
  0064 204a     [3]             BRA   LB0 ;abs = 00b0
  0066          L66:    
  207:        {
  208:              loop++;
  0066 95       [2]             TSX   
  0067 6c01     [5]             INC   1,X
  0069 2601     [3]             BNE   L6C ;abs = 006c
  006b 7c       [4]             INC   ,X
  006c          L6C:    
  209:              /* Apply one SCL clock pulse */
  210:              I2C_SCL_DD_H; // SCL = 1
  006c 1d01     [5]             BCLR  6,1
  211:              PAUSE;
  006e 6f0b     [5]             CLR   11,X
  0070 6f0a     [5]             CLR   10,X
  0072          L72:    
  0072 9d       [1]             NOP   
  0073 95       [2]             TSX   
  0074 6c0b     [5]             INC   11,X
  0076 2602     [3]             BNE   L7A ;abs = 007a
  0078 6c0a     [5]             INC   10,X
  007a          L7A:    
  007a 9efe0b   [5]             LDHX  11,SP
  007d 650019   [3]             CPHX  #25
  0080 91f0     [3]             BLT   L72 ;abs = 0072
  212:              I2C_SCL_DD_L; // SCL = 0
  0082 1c01     [5]             BSET  6,1
  0084 1d00     [5]             BCLR  6,0
  213:              PAUSE;
  0086 95       [2]             TSX   
  0087 6f0d     [5]             CLR   13,X
  0089 6f0c     [5]             CLR   12,X
  008b          L8B:    
  008b 9d       [1]             NOP   
  008c 95       [2]             TSX   
  008d 6c0d     [5]             INC   13,X
  008f 2602     [3]             BNE   L93 ;abs = 0093
  0091 6c0c     [5]             INC   12,X
  0093          L93:    
  0093 9efe0d   [5]             LDHX  13,SP
  0096 650019   [3]             CPHX  #25
  0099 91f0     [3]             BLT   L8B ;abs = 008b
  214:              /* If SDA is high and a complete byte was sent then exit the loop */ 
  215:              if( ( PTAD & 0x20 ) && ((loop % 9) == 0) )
  009b 0b0012   [5]             BRCLR 5,0,LB0 ;abs = 00b0
  009e 9efe01   [5]             LDHX  1,SP
  00a1 89       [2]             PSHX  
  00a2 8b       [2]             PSHH  
  00a3 ae09     [2]             LDX   #9
  00a5 8c       [1]             CLRH  
  00a6 cd0000   [6]             JSR   _IMODS_STAR08
  00a9 a702     [2]             AIS   #2
  00ab 650000   [3]             CPHX  #0
  00ae 2708     [3]             BEQ   LB8 ;abs = 00b8
  00b0          LB0:    
  00b0 9efe01   [5]             LDHX  1,SP
  00b3 65005a   [3]             CPHX  #90
  00b6 91ae     [3]             BLT   L66 ;abs = 0066
  00b8          LB8:    
  216:                    break;
  217:        }
  218:      
  219:        /* Create STOP condition (SDA goes high while SCL is high) */
  220:        I2C_SDA_DD_L;          // SDA = 0
  00b8 1a01     [5]             BSET  5,1
  00ba 1b00     [5]             BCLR  5,0
  221:        PAUSE;
  00bc 95       [2]             TSX   
  00bd 6f0f     [5]             CLR   15,X
  00bf 6f0e     [5]             CLR   14,X
  00c1          LC1:    
  00c1 9d       [1]             NOP   
  00c2 95       [2]             TSX   
  00c3 6c0f     [5]             INC   15,X
  00c5 2602     [3]             BNE   LC9 ;abs = 00c9
  00c7 6c0e     [5]             INC   14,X
  00c9          LC9:    
  00c9 9efe0f   [5]             LDHX  15,SP
  00cc 650019   [3]             CPHX  #25
  00cf 91f0     [3]             BLT   LC1 ;abs = 00c1
  222:        I2C_SCL_DD_H;          // SCL = 1
  00d1 1d01     [5]             BCLR  6,1
  223:        PAUSE;
  00d3 95       [2]             TSX   
  00d4 6f11     [5]             CLR   17,X
  00d6 6f10     [5]             CLR   16,X
  00d8          LD8:    
  00d8 9d       [1]             NOP   
  00d9 95       [2]             TSX   
  00da 6c11     [5]             INC   17,X
  00dc 2602     [3]             BNE   LE0 ;abs = 00e0
  00de 6c10     [5]             INC   16,X
  00e0          LE0:    
  00e0 9efe11   [5]             LDHX  17,SP
  00e3 650019   [3]             CPHX  #25
  00e6 91f0     [3]             BLT   LD8 ;abs = 00d8
  224:        I2C_SDA_DD_H;          // SDA = 1
  00e8 1b01     [5]             BCLR  5,1
  225:        PAUSE;
  00ea 95       [2]             TSX   
  00eb 6f13     [5]             CLR   19,X
  00ed 6f12     [5]             CLR   18,X
  00ef          LEF:    
  00ef 9d       [1]             NOP   
  00f0 95       [2]             TSX   
  00f1 6c13     [5]             INC   19,X
  00f3 2602     [3]             BNE   LF7 ;abs = 00f7
  00f5 6c12     [5]             INC   18,X
  00f7          LF7:    
  00f7 9efe13   [5]             LDHX  19,SP
  00fa 650019   [3]             CPHX  #25
  00fd 91f0     [3]             BLT   LEF ;abs = 00ef
  226:  
  227:        //Set operation back to default for all pins on PTADD and Enable I2C
  228:        PTADD = init_PTADD;
  00ff 6e4001   [4]             MOV   #64,1
  229:        
  230:        IICC1 = init_IICC1;
  0102 6e806c   [4]             MOV   #-128,108
  231:        
  232:  }
  0105 a714     [2]             AIS   #20
  0107 8d       [7]             RTC   
  233:  
  234:  
  235:  
  236:  /*********************************************************\
  237:  * IIC Write Register
  238:  \*********************************************************/
  239:  void IIC_RegWrite(uint8_t address, uint8_t reg,uint8_t val)
  240:  {                      
  0000 87       [2]             PSHA  
  241:    mIIC_C_c |= mIICC_TX_c;                       // Transmit Mode
  0001 186c     [5]             BSET  4,108
  242:    IIC_Start();                                  // Send Start
  0003 89       [2]             PSHX  
  0004 ac000000 [8]             CALL  IIC_Start
  243:    IIC_CycleWrite(address);                      // Send IIC "Write" Address
  0008 95       [2]             TSX   
  0009 e605     [3]             LDA   5,X
  000b ac000000 [8]             CALL  IIC_CycleWrite
  244:    IIC_CycleWrite(reg);                          // Send Register
  000f 86       [3]             PULA  
  0010 ac000000 [8]             CALL  IIC_CycleWrite
  245:    IIC_CycleWrite(val);                          // Send Value
  0014 95       [2]             TSX   
  0015 f6       [3]             LDA   ,X
  0016 ac000000 [8]             CALL  IIC_CycleWrite
  246:    IIC_Stop();                                   // Send Stop
  001a ac000000 [8]             CALL  IIC_Stop
  247:  }
  001e 8a       [3]             PULH  
  001f 8d       [7]             RTC   
  248:  
  249:  /*********************************************************\
  250:  * IIC Read Register
  251:  \*********************************************************/
  252:  uint8_t IIC_RegRead(uint8_t address, uint8_t reg)
  253:  {
  0000 87       [2]             PSHA  
  0001 8b       [2]             PSHH  
  254:    volatile uint8_t b;
  255:                           
  256:    mIIC_C_c |= mIICC_TX_c;                       // Transmit Mode
  0002 186c     [5]             BSET  4,108
  257:    IIC_Start();                                  // Send Start
  0004 89       [2]             PSHX  
  0005 ac000000 [8]             CALL  IIC_Start
  258:    IIC_CycleWrite(address);                      // Send IIC "Write" Address
  0009 95       [2]             TSX   
  000a f6       [3]             LDA   ,X
  000b ac000000 [8]             CALL  IIC_CycleWrite
  259:    IIC_CycleWrite(reg);                          // Send Register
  000f 95       [2]             TSX   
  0010 e602     [3]             LDA   2,X
  0012 ac000000 [8]             CALL  IIC_CycleWrite
  260:    IIC_RepeatStart();                            // Send Repeat Start
  0016 ac000000 [8]             CALL  IIC_RepeatStart
  261:    IIC_CycleWrite(address+1);                    // Send IIC "Read" Address
  001a 86       [3]             PULA  
  001b 4c       [1]             INCA  
  001c ac000000 [8]             CALL  IIC_CycleWrite
  262:    b = IIC_CycleRead(1);                         // *** Dummy read: reads "IIC_ReadAddress" value ***
  0020 a601     [2]             LDA   #1
  0022 ac000000 [8]             CALL  IIC_CycleRead
  0026 95       [2]             TSX   
  0027 f7       [2]             STA   ,X
  263:    b = IIC_StopRead();                           // Send Stop Read command
  0028 ac000000 [8]             CALL  IIC_StopRead
  002c 95       [2]             TSX   
  002d f7       [2]             STA   ,X
  264:    return b;
  002e f6       [3]             LDA   ,X
  265:  }
  002f a702     [2]             AIS   #2
  0031 8d       [7]             RTC   
  266:  
  267:  /*********************************************************\
  268:  * IIC Cycle Write
  269:  \*********************************************************/
  270:  void IIC_CycleWrite(uint8_t bout)
  271:  {
  0000 87       [2]             PSHA  
  0001 8b       [2]             PSHH  
  272:    volatile uint8_t error = 0x00;
  0002 95       [2]             TSX   
  0003 7f       [4]             CLR   ,X
  273:    uint8_t read_status;
  274:    
  275:    timeout = 0;	  
  0004 5f       [1]             CLRX  
  0005 8c       [1]             CLRH  
  0006 960000   [5]             STHX  timeout
  276:    while ((mIICS_TCF_c != (mIIC_S_c & mIICS_TCF_c)) && (timeout<1000))
  0009 2008     [3]             BRA   L13 ;abs = 0013
  000b          LB:     
  277:      timeout++;
  000b 450000   [3]             LDHX  @timeout
  000e 6c01     [5]             INC   1,X
  0010 2601     [3]             BNE   L13 ;abs = 0013
  0012 7c       [4]             INC   ,X
  0013          L13:    
  0013 b66d     [3]             LDA   109
  0015 a480     [2]             AND   #-128
  0017 418006   [4]             CBEQA #-128,L20 ;abs = 0020
  001a ac000063 [8]             CALL  IIC_CycleWrite:99
  001e 25eb     [3]             BCS   LB ;abs = 000b
  0020          L20:    
  0020 ac000063 [8]             CALL  IIC_CycleWrite:99
  278:    
  279:    if (timeout >= 1000)
  0024 2505     [3]             BCS   L2B ;abs = 002b
  280:      error |= 0x08; 
  0026 95       [2]             TSX   
  0027 f6       [3]             LDA   ,X
  0028 aa08     [2]             ORA   #8
  002a f7       [2]             STA   ,X
  002b          L2B:    
  281:    
  282:    mIIC_D_c = bout; 
  002b 95       [2]             TSX   
  002c e601     [3]             LDA   1,X
  002e b76e     [3]             STA   110
  283:    
  284:    timeout = 0;
  0030 5f       [1]             CLRX  
  0031 8c       [1]             CLRH  
  0032 960000   [5]             STHX  timeout
  285:    while ((mIICS_IICIF_c != (mIIC_S_c & mIICS_IICIF_c)) && (timeout<1000))
  0035 2008     [3]             BRA   L3F ;abs = 003f
  0037          L37:    
  286:      timeout++;
  0037 450000   [3]             LDHX  @timeout
  003a 6c01     [5]             INC   1,X
  003c 2601     [3]             BNE   L3F ;abs = 003f
  003e 7c       [4]             INC   ,X
  003f          L3F:    
  003f 026d06   [5]             BRSET 1,109,L48 ;abs = 0048
  0042 ac000063 [8]             CALL  IIC_CycleWrite:99
  0046 25ef     [3]             BCS   L37 ;abs = 0037
  0048          L48:    
  0048 ac000063 [8]             CALL  IIC_CycleWrite:99
  287:    
  288:    if (timeout >= 1000)
  004c 2505     [3]             BCS   L53 ;abs = 0053
  289:      error |= 0x10;
  004e 95       [2]             TSX   
  004f f6       [3]             LDA   ,X
  0050 aa10     [2]             ORA   #16
  0052 f7       [2]             STA   ,X
  0053          L53:    
  290:    
  291:    mIIC_S_c |= mIICS_IICIF_c;
  0053 126d     [5]             BSET  1,109
  292:    
  293:    read_status = mIIC_S_c & mIICS_RXAK_c;
  0055 b66d     [3]             LDA   109
  0057 a401     [2]             AND   #1
  294:    
  295:    if( mIICS_RXAK_c == read_status )
  0059 4b05     [4]             DBNZA L60 ;abs = 0060
  296:      error |= 0x20;
  005b 95       [2]             TSX   
  005c f6       [3]             LDA   ,X
  005d aa20     [2]             ORA   #32
  005f f7       [2]             STA   ,X
  0060          L60:    
  297:  }
  0060 a702     [2]             AIS   #2
  0062 8d       [7]             RTC   
  0063          L63:    
  0063 320000   [5]             LDHX  timeout
  0066 6503e8   [3]             CPHX  #1000
  0069 8d       [7]             RTC   
  298:  
  299:  /*********************************************************\
  300:  * IIC Cycle Read
  301:  \*********************************************************/
  302:  uint8_t IIC_CycleRead(uint8_t byteLeft)
  303:  {
  0000 87       [2]             PSHA  
  0001 8b       [2]             PSHH  
  304:    uint8_t bread; 
  305:    volatile uint8_t error = 0x00;
  0002 95       [2]             TSX   
  0003 7f       [4]             CLR   ,X
  306:    
  307:    timeout = 0;
  0004 5f       [1]             CLRX  
  0005 8c       [1]             CLRH  
  0006 960000   [5]             STHX  timeout
  308:    while ((mIICS_TCF_c != (mIIC_S_c & mIICS_TCF_c)) && (timeout<1000))	  	  
  0009 2008     [3]             BRA   L13 ;abs = 0013
  000b          LB:     
  309:      timeout++;
  000b 450000   [3]             LDHX  @timeout
  000e 6c01     [5]             INC   1,X
  0010 2601     [3]             BNE   L13 ;abs = 0013
  0012 7c       [4]             INC   ,X
  0013          L13:    
  0013 b66d     [3]             LDA   109
  0015 a480     [2]             AND   #-128
  0017 418006   [4]             CBEQA #-128,L20 ;abs = 0020
  001a ac000067 [8]             CALL  IIC_CycleRead:103
  001e 25eb     [3]             BCS   LB ;abs = 000b
  0020          L20:    
  0020 ac000067 [8]             CALL  IIC_CycleRead:103
  310:    
  311:    if (timeout >= 1000)
  0024 2505     [3]             BCS   L2B ;abs = 002b
  312:      error|=0x08;
  0026 95       [2]             TSX   
  0027 f6       [3]             LDA   ,X
  0028 aa08     [2]             ORA   #8
  002a f7       [2]             STA   ,X
  002b          L2B:    
  313:    
  314:    mIIC_C_c &= ~(mIICC_TX_c);
  002b 196c     [5]             BCLR  4,108
  315:      
  316:    
  317:    if( byteLeft <= 1 )
  002d 95       [2]             TSX   
  002e e601     [3]             LDA   1,X
  0030 a101     [2]             CMP   #1
  0032 2203     [3]             BHI   L37 ;abs = 0037
  318:  	  mIIC_C_c |= mIICC_TXAK_c;
  0034 166c     [5]             BSET  3,108
  0036 65       [3]             SKIP2 L39 ;abs = 0039
  0037          L37:    
  319:    else
  320:  	  mIIC_C_c &= ~(mIICC_TXAK_c); 
  0037 176c     [5]             BCLR  3,108
  0039          L39:    
  321:    
  322:    
  323:    bread = mIIC_D_c;
  0039 b66e     [3]             LDA   110
  324:    
  325:    timeout = 0; 	  
  003b 5f       [1]             CLRX  
  003c 8c       [1]             CLRH  
  003d 960000   [5]             STHX  timeout
  326:    while ((mIICS_IICIF_c != (mIIC_S_c & mIICS_IICIF_c)) && (timeout<1000))	  	  
  0040 2008     [3]             BRA   L4A ;abs = 004a
  0042          L42:    
  327:      timeout++;
  0042 450000   [3]             LDHX  @timeout
  0045 6c01     [5]             INC   1,X
  0047 2601     [3]             BNE   L4A ;abs = 004a
  0049 7c       [4]             INC   ,X
  004a          L4A:    
  004a 026d06   [5]             BRSET 1,109,L53 ;abs = 0053
  004d ac000067 [8]             CALL  IIC_CycleRead:103
  0051 25ef     [3]             BCS   L42 ;abs = 0042
  0053          L53:    
  0053 ac000067 [8]             CALL  IIC_CycleRead:103
  328:    
  329:    
  330:    if (timeout >= 1000)
  0057 2509     [3]             BCS   L62 ;abs = 0062
  331:      error |= 0x10;
  0059 87       [2]             PSHA  
  005a 95       [2]             TSX   
  005b e601     [3]             LDA   1,X
  005d aa10     [2]             ORA   #16
  005f e701     [3]             STA   1,X
  0061 86       [3]             PULA  
  0062          L62:    
  332:     
  333:    mIIC_S_c |= mIICS_IICIF_c;
  0062 126d     [5]             BSET  1,109
  334:    
  335:    
  336:    return bread;
  337:  }
  0064 a702     [2]             AIS   #2
  0066 8d       [7]             RTC   
  0067          L67:    
  0067 320000   [5]             LDHX  timeout
  006a 6503e8   [3]             CPHX  #1000
  006d 8d       [7]             RTC   
  338:  
  339:  /*********************************************************\
  340:  * IIC Write Multiple Registers
  341:  \*********************************************************/
  342:  void IIC_RegWriteN(uint8_t address, uint8_t reg1, uint8_t N, uint8_t *array)
  343:  {                           
  0000 87       [2]             PSHA  
  0001 89       [2]             PSHX  
  0002 8b       [2]             PSHH  
  344:    mIIC_C_c |= mIICC_TX_c;                       // Transmit Mode
  0003 186c     [5]             BSET  4,108
  345:    IIC_Start();                                  // Send Start
  0005 ac000000 [8]             CALL  IIC_Start
  346:    IIC_CycleWrite(address);                      // Send IIC "Write" Address
  0009 95       [2]             TSX   
  000a e607     [3]             LDA   7,X
  000c ac000000 [8]             CALL  IIC_CycleWrite
  347:    IIC_CycleWrite(reg1);                         // Send Register
  0010 95       [2]             TSX   
  0011 e606     [3]             LDA   6,X
  0013 ac000000 [8]             CALL  IIC_CycleWrite
  348:    while (N>0)                                   // Send N Values
  0017 2010     [3]             BRA   L29 ;abs = 0029
  0019          L19:    
  349:    {
  350:      IIC_CycleWrite(*array);
  0019 9efe01   [5]             LDHX  1,SP
  001c f6       [3]             LDA   ,X
  001d ac000000 [8]             CALL  IIC_CycleWrite
  351:      array++;
  0021 95       [2]             TSX   
  0022 6c01     [5]             INC   1,X
  0024 2601     [3]             BNE   L27 ;abs = 0027
  0026 7c       [4]             INC   ,X
  0027          L27:    
  352:      N--;
  0027 6a02     [5]             DEC   2,X
  0029          L29:    
  0029 95       [2]             TSX   
  002a 6d02     [4]             TST   2,X
  002c 26eb     [3]             BNE   L19 ;abs = 0019
  353:    }
  354:    IIC_Stop();                                   // Send Stop
  002e ac000000 [8]             CALL  IIC_Stop
  355:  }
  0032 a703     [2]             AIS   #3
  0034 8d       [7]             RTC   
  356:  
  357:  /*********************************************************\
  358:  * IIC Read Multiple Registers
  359:  \*********************************************************/
  360:  void IIC_RegReadN(uint8_t address, uint8_t reg1,uint8_t N,uint8_t *array)
  361:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  362:    uint8_t read_data;
  363:                                  
  364:    mIIC_C_c |= mIICC_TX_c;                       // Transmit Mode
  0002 186c     [5]             BSET  4,108
  365:    IIC_Start();                                  // Send Start
  0004 87       [2]             PSHA  
  0005 ac000000 [8]             CALL  IIC_Start
  366:    IIC_CycleWrite(address);                      // Send IIC "Write" Address
  0009 95       [2]             TSX   
  000a e607     [3]             LDA   7,X
  000c ac000000 [8]             CALL  IIC_CycleWrite
  367:    IIC_CycleWrite(reg1);                         // Send Register
  0010 95       [2]             TSX   
  0011 e606     [3]             LDA   6,X
  0013 ac000000 [8]             CALL  IIC_CycleWrite
  368:    IIC_RepeatStart();                            // Send Repeat Start
  0017 ac000000 [8]             CALL  IIC_RepeatStart
  369:    IIC_CycleWrite(address+1);                    // Send IIC "Read" Address
  001b 95       [2]             TSX   
  001c e607     [3]             LDA   7,X
  001e 4c       [1]             INCA  
  001f ac000000 [8]             CALL  IIC_CycleWrite
  370:    read_data = IIC_CycleRead(N);                         // *** Dummy read: reads "IIC_ReadAddress" value ***
  0023 95       [2]             TSX   
  0024 f6       [3]             LDA   ,X
  0025 ac000000 [8]             CALL  IIC_CycleRead
  371:    while (N>1)                                   // Read N-1 Register Values
  0029 2011     [3]             BRA   L3C ;abs = 003c
  002b          L2B:    
  372:    {
  373:      N--;
  002b 4a       [1]             DECA  
  374:      read_data = IIC_CycleRead(N);
  002c 87       [2]             PSHA  
  002d ac000000 [8]             CALL  IIC_CycleRead
  375:      *array = read_data;
  0031 9efe02   [5]             LDHX  2,SP
  0034 f7       [2]             STA   ,X
  376:      array++;
  0035 95       [2]             TSX   
  0036 6c02     [5]             INC   2,X
  0038 2602     [3]             BNE   L3C ;abs = 003c
  003a 6c01     [5]             INC   1,X
  003c          L3C:    
  003c 86       [3]             PULA  
  003d a101     [2]             CMP   #1
  003f 22ea     [3]             BHI   L2B ;abs = 002b
  377:      
  378:    }
  379:    read_data = IIC_StopRead();
  0041 ac000000 [8]             CALL  IIC_StopRead
  380:    *array = read_data;                                   // Read Last value
  0045 9efe01   [5]             LDHX  1,SP
  0048 f7       [2]             STA   ,X
  381:  }
  0049 a702     [2]             AIS   #2
  004b 8d       [7]             RTC   
  382:  
  383:  
  384:  /*********************************************************\
  385:  * Initiate IIC Start Condition
  386:  \*********************************************************/
  387:  void IIC_Start(void)
  388:  {
  0000 a7fe     [2]             AIS   #-2
  389:    volatile uint8_t read_status;
  390:    volatile uint8_t error = 0x00;
  0002 95       [2]             TSX   
  0003 7f       [4]             CLR   ,X
  391:    
  392:    read_status = mIIC_S_c;
  0004 b66d     [3]             LDA   109
  0006 e701     [3]             STA   1,X
  393:      
  394:    mIIC_C_c |= mIICC_MST_c;
  0008 1a6c     [5]             BSET  5,108
  395:    
  396:    timeout = 0;   
  000a 5f       [1]             CLRX  
  000b 8c       [1]             CLRH  
  000c 960000   [5]             STHX  timeout
  397:    while ( (mIICS_BUSY_c != (mIIC_S_c & mIICS_BUSY_c) ) && (timeout<1000))
  000f 2008     [3]             BRA   L19 ;abs = 0019
  0011          L11:    
  398:      timeout++;
  0011 450000   [3]             LDHX  @timeout
  0014 6c01     [5]             INC   1,X
  0016 2601     [3]             BNE   L19 ;abs = 0019
  0018 7c       [4]             INC   ,X
  0019          L19:    
  0019 0a6d08   [5]             BRSET 5,109,L24 ;abs = 0024
  001c 320000   [5]             LDHX  timeout
  001f 6503e8   [3]             CPHX  #1000
  0022 25ed     [3]             BCS   L11 ;abs = 0011
  0024          L24:    
  399:    
  400:    if (timeout >= 1000)
  0024 320000   [5]             LDHX  timeout
  0027 6503e8   [3]             CPHX  #1000
  002a 2505     [3]             BCS   L31 ;abs = 0031
  401:      error |= 0x01;
  002c 95       [2]             TSX   
  002d f6       [3]             LDA   ,X
  002e aa01     [2]             ORA   #1
  0030 f7       [2]             STA   ,X
  0031          L31:    
  402:    
  403:  } //*** Wait until BUSY=1
  0031 a702     [2]             AIS   #2
  0033 8d       [7]             RTC   
  404:  
  405:  
  406:  /*********************************************************\
  407:  * Initiate IIC Stop Condition
  408:  \*********************************************************/
  409:  void IIC_Stop(void)
  410:  {
  0000 8b       [2]             PSHH  
  411:    volatile uint8_t error = 0x00;
  0001 95       [2]             TSX   
  0002 7f       [4]             CLR   ,X
  412:  	  
  413:    mIIC_C_c &= ~(mIICC_MST_c);
  0003 1b6c     [5]             BCLR  5,108
  414:  	 
  415:    timeout = 0;
  0005 5f       [1]             CLRX  
  0006 8c       [1]             CLRH  
  0007 960000   [5]             STHX  timeout
  416:    while ( (mIICS_BUSY_c == (mIIC_S_c & mIICS_BUSY_c)) && (timeout<1000))	  
  000a 2008     [3]             BRA   L14 ;abs = 0014
  000c          LC:     
  417:      timeout++;
  000c 450000   [3]             LDHX  @timeout
  000f 6c01     [5]             INC   1,X
  0011 2601     [3]             BNE   L14 ;abs = 0014
  0013 7c       [4]             INC   ,X
  0014          L14:    
  0014 0b6d08   [5]             BRCLR 5,109,L1F ;abs = 001f
  0017 320000   [5]             LDHX  timeout
  001a 6503e8   [3]             CPHX  #1000
  001d 25ed     [3]             BCS   LC ;abs = 000c
  001f          L1F:    
  418:    
  419:    if (timeout >= 1000)
  001f 320000   [5]             LDHX  timeout
  0022 6503e8   [3]             CPHX  #1000
  0025 2505     [3]             BCS   L2C ;abs = 002c
  420:      error |= 0x02;
  0027 95       [2]             TSX   
  0028 f6       [3]             LDA   ,X
  0029 aa02     [2]             ORA   #2
  002b f7       [2]             STA   ,X
  002c          L2C:    
  421:  
  422:  } //*** Wait until BUSY=0
  002c 8a       [3]             PULH  
  002d 8d       [7]             RTC   
  423:  
  424:  /*********************************************************\
  425:  * Initiate IIC Repeat Start Condition
  426:  \*********************************************************/
  427:  void IIC_RepeatStart(void)
  428:  {
  0000 a7fe     [2]             AIS   #-2
  429:    volatile uint8_t read_status;
  430:    volatile uint8_t error = 0x00;
  0002 95       [2]             TSX   
  0003 7f       [4]             CLR   ,X
  431:    
  432:    read_status = mIIC_S_c;
  0004 b66d     [3]             LDA   109
  0006 e701     [3]             STA   1,X
  433:    
  434:    mIIC_C_c |= mIICC_RSTA_c;
  0008 146c     [5]             BSET  2,108
  435:    
  436:    timeout = 0; 
  000a 5f       [1]             CLRX  
  000b 8c       [1]             CLRH  
  000c 960000   [5]             STHX  timeout
  437:    while ( (mIICS_BUSY_c != (mIIC_S_c & mIICS_BUSY_c)) && (timeout<1000))
  000f 2008     [3]             BRA   L19 ;abs = 0019
  0011          L11:    
  438:      timeout++;
  0011 450000   [3]             LDHX  @timeout
  0014 6c01     [5]             INC   1,X
  0016 2601     [3]             BNE   L19 ;abs = 0019
  0018 7c       [4]             INC   ,X
  0019          L19:    
  0019 0a6d08   [5]             BRSET 5,109,L24 ;abs = 0024
  001c 320000   [5]             LDHX  timeout
  001f 6503e8   [3]             CPHX  #1000
  0022 25ed     [3]             BCS   L11 ;abs = 0011
  0024          L24:    
  439:    
  440:    if (timeout >= 1000)
  0024 320000   [5]             LDHX  timeout
  0027 6503e8   [3]             CPHX  #1000
  002a 2505     [3]             BCS   L31 ;abs = 0031
  441:      error |= 0x04;
  002c 95       [2]             TSX   
  002d f6       [3]             LDA   ,X
  002e aa04     [2]             ORA   #4
  0030 f7       [2]             STA   ,X
  0031          L31:    
  442:    
  443:  } //*** Wait until BUSY=1
  0031 a702     [2]             AIS   #2
  0033 8d       [7]             RTC   
  444:  
  445:  /*********************************************************\
  446:  * Initiate IIC Stop Condition on Read
  447:  \*********************************************************/
  448:  uint8_t IIC_StopRead(void)
  449:  {
  0000 8b       [2]             PSHH  
  450:    volatile uint8_t error = 0x00;
  0001 95       [2]             TSX   
  0002 7f       [4]             CLR   ,X
  451:    
  452:    mIIC_C_c &= ~(mIICC_MST_c);
  0003 1b6c     [5]             BCLR  5,108
  453:    
  454:    timeout = 0;
  0005 5f       [1]             CLRX  
  0006 8c       [1]             CLRH  
  0007 960000   [5]             STHX  timeout
  455:    while ( (mIICS_BUSY_c == (mIIC_S_c & mIICS_BUSY_c) ) && (timeout<1000))	  
  000a 2008     [3]             BRA   L14 ;abs = 0014
  000c          LC:     
  456:      timeout++;
  000c 450000   [3]             LDHX  @timeout
  000f 6c01     [5]             INC   1,X
  0011 2601     [3]             BNE   L14 ;abs = 0014
  0013 7c       [4]             INC   ,X
  0014          L14:    
  0014 0b6d08   [5]             BRCLR 5,109,L1F ;abs = 001f
  0017 320000   [5]             LDHX  timeout
  001a 6503e8   [3]             CPHX  #1000
  001d 25ed     [3]             BCS   LC ;abs = 000c
  001f          L1F:    
  457:    
  458:    if (timeout >= 1000)
  001f 320000   [5]             LDHX  timeout
  0022 6503e8   [3]             CPHX  #1000
  0025 2505     [3]             BCS   L2C ;abs = 002c
  459:      error |= 0x02;
  0027 95       [2]             TSX   
  0028 f6       [3]             LDA   ,X
  0029 aa02     [2]             ORA   #2
  002b f7       [2]             STA   ,X
  002c          L2C:    
  460:    
  461:    return mIIC_D_c;
  002c b66e     [3]             LDA   110
  462:    
  463:  } //*** Wait until BUSY=0
  002e 8a       [3]             PULH  
  002f 8d       [7]             RTC   
  464:  
  465:  
  466:  
  467:  /*****************************************************************************
  468:  *   IIC_ModuleUninit 
  469:  *
  470:  *   Resets the I2C module.
  471:  ******************************************************************************/
  472:  void IIC_ModuleUninit(void)
  473:  {
  474:  #if gIIC_Enabled_d
  475:    mIIC_C_c = mIICC_Reset_c;
  0000 3f6c     [5]             CLR   108
  476:    
  477:    /* Destroy the IIC task */
  478:    if(gIIcTaskId != gTsInvalidTaskID_c)
  0002 c60000   [4]             LDA   gIIcTaskId
  0005 41ff04   [4]             CBEQA #-1,LC ;abs = 000c
  479:    {
  480:      TS_DestroyTask(gIIcTaskId);  
  0008 ac000000 [8]             CALL  TS_DestroyTask
  000c          LC:     
  481:    }
  482:  #endif
  483:  }
  000c 8d       [7]             RTC   
  484:  /*****************************************************************************
  485:  *   IIC_SetBaudRate 
  486:  *
  487:  *   Resets the I2C module.
  488:  ******************************************************************************/
  489:  bool_t IIC_SetBaudRate(uint8_t baudRate)
  490:  {
  491:  #if gIIC_Enabled_d
  492:     if(mIIC_S_c & mIICS_BUSY_c)
  0000 0b6d02   [5]             BRCLR 5,109,L5 ;abs = 0005
  493:      {
  494:       return FALSE; 
  0003 4f       [1]             CLRA  
  0004 8d       [7]             RTC   
  0005          L5:     
  495:      }
  496:     mIIC_F_c = baudRate;
  0005 b76b     [3]             STA   107
  497:     return TRUE;
  0007 a601     [2]             LDA   #1
  498:  #else
  499:    {
  500:     (void)baudRate;
  501:     return FALSE; 
  502:    }
  503:  #endif
  504:  }
  0009 8d       [7]             RTC   
  505:  
  506:  
  507:  /*****************************************************************************
  508:  *   IIC_SetSlaveAddress 
  509:  *
  510:  *   Sets the slave address of the I2C module.
  511:  ******************************************************************************/
  512:  bool_t IIC_SetSlaveAddress(uint8_t slaveAddress)
  513:  {
  514:  
  515:  #if 0	
  516:    /* Check if the I2C address is valid */
  517:    if((slaveAddress > 0x7f) || 
  518:       (((slaveAddress & 0x78) == 0) && ((slaveAddress & 0x07) != 0)) || 
  519:       ((slaveAddress & 0x78) == 0x78))
  520:    {
  521:      return FALSE;
  522:    }
  523:    
  524:  #endif
  525:    
  526:    {
  527:      mIIC_A_c = (slaveAddress << 1);
  0000 48       [1]             LSLA  
  0001 b76a     [3]             STA   106
  528:      return TRUE;
  0003 a601     [2]             LDA   #1
  529:    }
  530:  }
  0005 8d       [7]             RTC   
  531:  
  532:  
  533:  /*****************************************************************************
  534:  *   IIC_BusRecovery 
  535:  *
  536:  *   Resets the I2C module.
  537:  ******************************************************************************/
  538:  void IIC_BusRecovery(void)
  539:  {
  540:  #if gIIC_Enabled_d
  541:     uint8_t iicControlReg;
  542:     iicControlReg = mIIC_C_c;
  0000 b66c     [3]             LDA   108
  543:     mIIC_C_c = mIICC_Reset_c;
  0002 3f6c     [5]             CLR   108
  544:     mIIC_C_c = mIICC_MST_c;
  0004 6e206c   [4]             MOV   #32,108
  545:     mIIC_C_c |= mIICC_IICEN_c;
  0007 1e6c     [5]             BSET  7,108
  546:     mIIC_S_c = mIICS_Init_c;
  0009 6e126d   [4]             MOV   #18,109
  547:     mIIC_D_c;
  000c be6e     [3]             LDX   110
  000e          LE:     
  548:     while((mIIC_S_c & mIICS_IICIF_c) == 0);
  000e 036dfd   [5]             BRCLR 1,109,LE ;abs = 000e
  549:     mIIC_C_c &= ~mIICC_MST_c;
  0011 1b6c     [5]             BCLR  5,108
  550:     mIIC_S_c = mIICS_Init_c;
  0013 6e126d   [4]             MOV   #18,109
  551:     mIIC_C_c = iicControlReg;
  0016 b76c     [3]             STA   108
  552:     
  553:  #endif
  554:  }
  0018 8d       [7]             RTC   
  555:  
  556:  
  557:  /*****************************************************************************
  558:  *   IIC_SetRxCallBack 
  559:  *
  560:  *   Sets a pointer to the function to be called whenever a byte is received.
  561:  *   If the pointer is set to NULL clear the Rx buffer.
  562:  ******************************************************************************/
  563:  void IIC_SetSlaveRxCallBack(void (*pfCallBack)(void))
  564:  {
  565:  #if !gIIC_Enabled_d
  566:    (void) pfCallBack;
  567:  #else
  568:    pfIIcSlaveRxCallBack = pfCallBack;
  0000 9efe05   [5]             LDHX  5,SP
  0003 960001   [5]             STHX  pfIIcSlaveRxCallBack:1
  0006 95       [2]             TSX   
  0007 e603     [3]             LDA   3,X
  0009 c70000   [4]             STA   pfIIcSlaveRxCallBack
  569:  #endif
  570:  }
  000c 8d       [7]             RTC   
  571:  
  572:  
  573:  /*****************************************************************************
  574:  *   IIC_Transmit_Slave 
  575:  *
  576:  *   Begin transmitting size bytes of data from *pBuffer.
  577:  *   Returns FALSE if there are no more slots in the buffer reference table.
  578:  ******************************************************************************/
  579:  bool_t IIC_Transmit_Slave(uint8_t const *pBuf, index_t bufLen, void (*pfCallBack)(uint8_t const *pBuf)) 
  580:  {
  581:  #if !gIIC_Enabled_d
  582:    (void) pBuf;
  583:    (void) bufLen;
  584:    (void) pfCallBack;
  585:  #else
  586:    /* Handle empty buffers. */
  587:    if (!bufLen) 
  0000 95       [2]             TSX   
  0001 6d06     [4]             TST   6,X
  0003 261c     [3]             BNE   L21 ;abs = 0021
  588:     {
  589:      if(pfCallBack)
  0005 af03     [2]             AIX   #3
  0007 cd0000   [6]             JSR   _CMP24_RC
  000a 00               DC.B  0
  000b 0000             DC.W  0
  000d 2756     [3]             BEQ   L65 ;abs = 0065
  590:       {
  591:        (*pfCallBack)(pBuf);  
  000f 9efe08   [5]             LDHX  8,SP
  0012 89       [2]             PSHX  
  0013 8b       [2]             PSHH  
  0014 9efe07   [5]             LDHX  7,SP
  0017 9ee606   [4]             LDA   6,SP
  001a 87       [2]             PSHA  
  001b ac000000 [8]             CALL  _CALL_STAR08_FAR
  001f 2044     [3]             BRA   L65 ;abs = 0065
  0021          L21:    
  592:       }
  593:      return TRUE;
  594:     }
  595:  
  596:    /* Room for one more? */
  597:    if (maIIcTxBufLenTable[mIIcTxBufRefLeadingIndex]) 
  0021 ce0000   [4]             LDX   mIIcTxBufRefLeadingIndex
  0024 8c       [1]             CLRH  
  0025 d60000   [4]             LDA   @maIIcTxBufLenTable,X
  0028 2702     [3]             BEQ   L2C ;abs = 002c
  598:    {
  599:      return FALSE;
  002a 4f       [1]             CLRA  
  002b 8d       [7]             RTC   
  002c          L2C:    
  600:    }
  601:  
  602:    maIIcTxBufRefTable[mIIcTxBufRefLeadingIndex].pBuf = pBuf;
  002c a605     [2]             LDA   #5
  002e 89       [2]             PSHX  
  002f 42       [5]             MUL   
  0030 97       [1]             TAX   
  0031 9ee60a   [4]             LDA   10,SP
  0034 d70001   [4]             STA   @maIIcTxBufRefTable:1,X
  0037 9ee609   [4]             LDA   9,SP
  003a d70000   [4]             STA   @maIIcTxBufRefTable,X
  603:    maIIcTxBufRefTable[mIIcTxBufRefLeadingIndex].pfCallBack = pfCallBack;
  003d 9ee607   [4]             LDA   7,SP
  0040 d70004   [4]             STA   @maIIcTxBufRefTable:4,X
  0043 9ee606   [4]             LDA   6,SP
  0046 d70003   [4]             STA   @maIIcTxBufRefTable:3,X
  0049 9ee605   [4]             LDA   5,SP
  004c d70002   [4]             STA   @maIIcTxBufRefTable:2,X
  604:    /* This has to be last, in case the Tx ISR finishes with the previous */
  605:    /* buffer while this function is executing. */
  606:    maIIcTxBufLenTable[mIIcTxBufRefLeadingIndex] = bufLen;
  004f 9ee608   [4]             LDA   8,SP
  0052 88       [3]             PULX  
  0053 d70000   [4]             STA   @maIIcTxBufLenTable,X
  607:  
  608:    if (++mIIcTxBufRefLeadingIndex >= NumberOfElements(maIIcTxBufRefTable)) 
  0056 450000   [3]             LDHX  @mIIcTxBufRefLeadingIndex
  0059 7c       [4]             INC   ,X
  005a c60000   [4]             LDA   mIIcTxBufRefLeadingIndex
  005d a103     [2]             CMP   #3
  005f 2504     [3]             BCS   L65 ;abs = 0065
  609:    {
  610:      mIIcTxBufRefLeadingIndex = 0;
  0061 4f       [1]             CLRA  
  0062 c70000   [4]             STA   mIIcTxBufRefLeadingIndex
  0065          L65:    
  611:    }
  612:    
  613:  #if gIIC_Slave_TxDataAvailableSignal_Enable_c 
  614:    /* Signal to host that there are data to receive */
  615:    IIC_TxDataAvailable(TRUE);
  616:  #endif
  617:    
  618:  #endif  
  619:    
  620:    return TRUE;
  0065 a601     [2]             LDA   #1
  621:  } 
  0067 8d       [7]             RTC   
  622:  /*****************************************************************************
  623:  *   IIC_Transmit_Master 
  624:  *
  625:  *   Begin transmitting size bytes of data from *pBuffer.
  626:  *   Returns FALSE if there are no more slots in the buffer reference table.
  627:  ******************************************************************************/
  628:  bool_t IIC_Transmit_Master(uint8_t const *pBuf, index_t bufLen, uint8_t destAddress, void (*pfCallBack)(bool_t status)) 
  629:  {
  630:  #if !gIIC_Enabled_d
  631:    (void) pBuf;
  632:    (void) bufLen;
  633:    (void) destAddress;
  634:    (void) pfCallBack;
  635:  #else
  636:    /* Handle empty buffers. */
  637:    if (!bufLen) 
  0000 95       [2]             TSX   
  0001 6d07     [4]             TST   7,X
  0003 261b     [3]             BNE   L20 ;abs = 0020
  638:     {
  639:      if(pfCallBack)
  0005 af03     [2]             AIX   #3
  0007 cd0000   [6]             JSR   _CMP24_RC
  000a 00               DC.B  0
  000b 0000             DC.W  0
  000d 274f     [3]             BEQ   L5E ;abs = 005e
  640:       {
  641:        (*pfCallBack)(TRUE);  
  000f 9efe05   [5]             LDHX  5,SP
  0012 a601     [2]             LDA   #1
  0014 8b       [2]             PSHH  
  0015 8b       [2]             PSHH  
  0016 87       [2]             PSHA  
  0017 9ee607   [4]             LDA   7,SP
  001a ac000000 [8]             CALL  _CALL_STAR08_FAR
  001e 203e     [3]             BRA   L5E ;abs = 005e
  0020          L20:    
  642:       }
  643:      return TRUE;
  644:     }
  645:     destAddress <<= 1;
  0020 6806     [5]             LSL   6,X
  646:     if(destAddress == mIIC_A_c)
  0022 b66a     [3]             LDA   106
  0024 e106     [3]             CMP   6,X
  0026 270e     [3]             BEQ   L36 ;abs = 0036
  647:      {
  648:      return FALSE;
  649:      }
  650:     // pfIIcMasterTxCallBack is reset by IIC task after the callback is called
  651:     //if pfIIcMasterTxCallBack is != 0 it means that the previous callback didn't run yet  
  652:     if(pfIIcMasterTxCallBack) 
  0028 450000   [3]             LDHX  @pfIIcMasterTxCallBack
  002b cd0000   [6]             JSR   _CMP24_RC
  002e 00               DC.B  0
  002f 0000             DC.W  0
  0031 2603     [3]             BNE   L36 ;abs = 0036
  653:      {
  654:        return FALSE;
  655:      }
  656:     if(mIIC_S_c & mIICS_BUSY_c)
  0033 0b6d02   [5]             BRCLR 5,109,L38 ;abs = 0038
  0036          L36:    
  657:      {
  658:       return FALSE; 
  0036 4f       [1]             CLRA  
  0037 8d       [7]             RTC   
  0038          L38:    
  659:      }
  660:      mIICMasterOp.iicOpType = mIIC_OpType_Tx_c;
  0038 4f       [1]             CLRA  
  0039 c70000   [4]             STA   mIICMasterOp
  661:      mIICMasterOp.pBuf = (uint8_t*)pBuf;
  003c 9efe09   [5]             LDHX  9,SP
  003f 960001   [5]             STHX  mIICMasterOp:1
  662:      mIICMasterOp.bufLen = bufLen;
  0042 95       [2]             TSX   
  0043 e607     [3]             LDA   7,X
  0045 c70003   [4]             STA   mIICMasterOp:3
  663:      pfIIcMasterTxCallBack = pfCallBack;
  0048 9efe05   [5]             LDHX  5,SP
  004b 960001   [5]             STHX  pfIIcMasterTxCallBack:1
  004e 95       [2]             TSX   
  004f e603     [3]             LDA   3,X
  0051 c70000   [4]             STA   pfIIcMasterTxCallBack
  664:      
  665:      mIIC_C_c |= (mIICC_MST_c | mIICC_TX_c);// start condition
  0054 b66c     [3]             LDA   108
  0056 aa30     [2]             ORA   #48
  0058 b76c     [3]             STA   108
  666:      mIIC_D_c = destAddress; // address the slave for writting
  005a e606     [3]             LDA   6,X
  005c b76e     [3]             STA   110
  005e          L5E:    
  667:    
  668:    
  669:  #endif  
  670:    
  671:    return TRUE;
  005e a601     [2]             LDA   #1
  672:  } 
  0060 8d       [7]             RTC   
  673:  
  674:  /*****************************************************************************
  675:  *   IIC_Receive_Master 
  676:  *
  677:  *   Begin transmitting size bytes of data from *pBuffer.
  678:  *   Returns FALSE if there are no more slots in the buffer reference table.
  679:  ******************************************************************************/
  680:  bool_t IIC_Receive_Master(uint8_t *pBuf, index_t bufLen, uint8_t destAddress, void (*pfCallBack)(bool_t status)) 
  681:  {
  682:  #if !gIIC_Enabled_d
  683:    (void) pBuf;
  684:    (void) bufLen;
  685:    (void) destAddress;
  686:    (void) pfCallBack;
  687:  #else
  688:    /* Handle empty buffers. */
  689:    if (!bufLen) 
  0000 95       [2]             TSX   
  0001 6d07     [4]             TST   7,X
  0003 261c     [3]             BNE   L21 ;abs = 0021
  690:     {
  691:      if(pfCallBack)
  0005 af03     [2]             AIX   #3
  0007 cd0000   [6]             JSR   _CMP24_RC
  000a 00               DC.B  0
  000b 0000             DC.W  0
  000d 270f     [3]             BEQ   L1E ;abs = 001e
  692:       {
  693:        (*pfCallBack)(TRUE);  
  000f 9efe05   [5]             LDHX  5,SP
  0012 a601     [2]             LDA   #1
  0014 8b       [2]             PSHH  
  0015 8b       [2]             PSHH  
  0016 87       [2]             PSHA  
  0017 9ee607   [4]             LDA   7,SP
  001a ac000000 [8]             CALL  _CALL_STAR08_FAR
  001e          L1E:    
  694:       }
  695:      return TRUE;
  001e a601     [2]             LDA   #1
  0020 8d       [7]             RTC   
  0021          L21:    
  696:     }
  697:     destAddress <<= 1;
  0021 6806     [5]             LSL   6,X
  698:     if(destAddress == mIIC_A_c)
  0023 b66a     [3]             LDA   106
  0025 e106     [3]             CMP   6,X
  0027 270e     [3]             BEQ   L37 ;abs = 0037
  699:      {
  700:      return FALSE;
  701:      }
  702:     // pfIIcMasterTxCallBack is reset by IIC task after the callback is called
  703:     //if pfIIcMasterTxCallBack is != 0 it means that the previous callback didn't run yet  
  704:     if(pfIIcMasterRxCallBack) 
  0029 450000   [3]             LDHX  @pfIIcMasterRxCallBack
  002c cd0000   [6]             JSR   _CMP24_RC
  002f 00               DC.B  0
  0030 0000             DC.W  0
  0032 2603     [3]             BNE   L37 ;abs = 0037
  705:      {
  706:        return FALSE;
  707:      }
  708:     if(mIIC_S_c & mIICS_BUSY_c)
  0034 0b6d02   [5]             BRCLR 5,109,L39 ;abs = 0039
  0037          L37:    
  709:      {
  710:       return FALSE; 
  0037 4f       [1]             CLRA  
  0038 8d       [7]             RTC   
  0039          L39:    
  711:      }
  712:      mIICMasterOp.iicOpType = mIIC_OpType_Rx_c;
  0039 a601     [2]             LDA   #1
  003b c70000   [4]             STA   mIICMasterOp
  713:      mIICMasterOp.pBuf = pBuf;
  003e 9efe09   [5]             LDHX  9,SP
  0041 960001   [5]             STHX  mIICMasterOp:1
  714:      mIICMasterOp.bufLen = bufLen;
  0044 95       [2]             TSX   
  0045 ee07     [3]             LDX   7,X
  0047 cf0003   [4]             STX   mIICMasterOp:3
  715:      //Ori pfIIcMasterRxCallBack = pfCallBack;
  716:      
  717:      mIIC_C_c |= (mIICC_MST_c | mIICC_TX_c);// start condition
  004a b66c     [3]             LDA   108
  004c aa30     [2]             ORA   #48
  004e b76c     [3]             STA   108
  718:      mIIC_D_c = destAddress  | 0x1; // address the slave for reading
  0050 a601     [2]             LDA   #1
  0052 95       [2]             TSX   
  0053 ea06     [3]             ORA   6,X
  0055 b76e     [3]             STA   110
  719:  #endif  
  720:    
  721:    return TRUE;
  0057 a601     [2]             LDA   #1
  722:  } 
  0059 8d       [7]             RTC   
  723:  
  724:  /*****************************************************************************
  725:  *   IIC_IsSlaveTxActive 
  726:  *
  727:  *   Returns TRUE if there is still data to be transmitted to the master.
  728:  *   Returns FALSE if nothing left to transmit.
  729:  ******************************************************************************/
  730:  bool_t IIC_IsSlaveTxActive(void) 
  731:  {
  732:  #if !gIIC_Enabled_d
  733:    return FALSE;
  734:  #else  
  735:    return (maIIcTxBufLenTable[mIIcTxBufRefTrailingIndex] != 0) || ((mIIC_S_c & mIICS_BUSY_c));
  0000 ce0000   [4]             LDX   mIIcTxBufRefTrailingIndex
  0003 8c       [1]             CLRH  
  0004 d60000   [4]             LDA   @maIIcTxBufLenTable,X
  0007 2604     [3]             BNE   LD ;abs = 000d
  0009 4f       [1]             CLRA  
  000a 0b6d02   [5]             BRCLR 5,109,LF ;abs = 000f
  000d          LD:     
  000d a601     [2]             LDA   #1
  000f          LF:     
  736:  #endif  
  737:  }
  000f 8d       [7]             RTC   
  738:  
  739:  /*****************************************************************************
  740:  *   IIC_TxDataAvailable 
  741:  *
  742:  *   Depending on bool parameter master will be signaled that need to read data from slave
  743:  ******************************************************************************/
  744:  void IIC_TxDataAvailable(bool_t bIsAvailable)
  745:  {
  746:  #if gIIC_Slave_TxDataAvailableSignal_Enable_c
  747:    if(bIsAvailable) 
  748:      {
  749:       gIIC_TxDataAvailablePortDataReg_c &= ~(gIIC_TxDataAvailablePinMask_c); 
  750:      }
  751:    else
  752:      {
  753:       gIIC_TxDataAvailablePortDataReg_c |= gIIC_TxDataAvailablePinMask_c; 
  754:      }
  755:  #else
  756:  (void)bIsAvailable;
  757:  #endif    
  758:  }
  0000 8d       [7]             RTC   
  759:  
  760:  /*****************************************************************************
  761:  *   IIC_GetByteFromRxBuffer 
  762:  *
  763:  *   Retrieves a byte from the driver's Rx buffer and store it at *pDst.
  764:  *   Return TRUE if a byte was retrieved; FALSE if the Rx buffer is empty.
  765:  ******************************************************************************/
  766:  bool_t IIC_GetByteFromRxBuffer(unsigned char *pDst)
  767:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 8b       [2]             PSHH  
  768:  #if !gIIC_Enabled_d
  769:    (void) pDst;
  770:  #else
  771:    /* Temp storage for I2C control register */
  772:    uint8_t iicControlReg;
  773:    
  774:    if (!mIIcRxBufferByteCount) 
  0003 c60000   [4]             LDA   mIIcRxBufferByteCount
  0006 2730     [3]             BEQ   L38 ;abs = 0038
  775:      return FALSE;
  776:    IrqControlLib_PushIrqStatus();
  0008 85       [1]             TPA   
  0009 87       [2]             PSHA  
  777:    IrqControlLib_DisableAllIrqs();
  000a 9b       [1]             SEI   
  778:    iicControlReg = mIIC_C_c;
  000b b66c     [3]             LDA   108
  000d 95       [2]             TSX   
  000e e701     [3]             STA   1,X
  779:    mIIC_C_c &= ~mIICC_IICIE_c;
  0010 1d6c     [5]             BCLR  6,108
  780:    IrqControlLib_PullIrqStatus();
  0012 86       [3]             PULA  
  0013 84       [1]             TAP   
  781:    *pDst = maIIcRxBuf[mIIcRxBufTrailingIndex];
  0014 ce0000   [4]             LDX   mIIcRxBufTrailingIndex
  0017 8c       [1]             CLRH  
  0018 d60000   [4]             LDA   @maIIcRxBuf,X
  001b 9efe02   [5]             LDHX  2,SP
  001e f7       [2]             STA   ,X
  782:    if (++mIIcRxBufTrailingIndex >= sizeof(maIIcRxBuf)) {
  001f 450000   [3]             LDHX  @mIIcRxBufTrailingIndex
  0022 7c       [4]             INC   ,X
  0023 c60000   [4]             LDA   mIIcRxBufTrailingIndex
  0026 a120     [2]             CMP   #32
  0028 2504     [3]             BCS   L2E ;abs = 002e
  783:      mIIcRxBufTrailingIndex = 0;
  002a 4f       [1]             CLRA  
  002b c70000   [4]             STA   mIIcRxBufTrailingIndex
  002e          L2E:    
  784:    }
  785:    --mIIcRxBufferByteCount;
  002e 450000   [3]             LDHX  @mIIcRxBufferByteCount
  0031 7a       [4]             DEC   ,X
  786:    mIIC_C_c = iicControlReg;
  0032 95       [2]             TSX   
  0033 f6       [3]             LDA   ,X
  0034 b76c     [3]             STA   108
  787:   #endif  
  788:  
  789:    return TRUE;
  0036 a601     [2]             LDA   #1
  0038          L38:    
  790:  }
  0038 a703     [2]             AIS   #3
  003a 8d       [7]             RTC   
  791:  
  792:  
  793:  
  794:  
  795:  /*****************************************************************************
  796:  *   IIC_Task 
  797:  *
  798:  *   Main task of the I2C module 
  799:  ******************************************************************************/
  800:  void IIC_Task(event_t events)
  801:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  802:  #if !gIIC_Enabled_d
  803:    (void) events;
  804:  #else
  805:  
  806:    void (*pfCallBack)(uint8_t const *pBuf);
  807:  
  808:    if (events & gIIC_Event_SlaveRx_c)
  0002 9f       [1]             TXA   
  0003 a504     [2]             BIT   #4
  0005 270d     [3]             BEQ   L14 ;abs = 0014
  809:    {
  810:      pfIIcSlaveRxCallBack();
  0007 320001   [5]             LDHX  pfIIcSlaveRxCallBack:1
  000a c60000   [4]             LDA   pfIIcSlaveRxCallBack
  000d 8b       [2]             PSHH  
  000e 8b       [2]             PSHH  
  000f 8b       [2]             PSHH  
  0010 ac000000 [8]             CALL  _CALL_STAR08_FAR
  0014          L14:    
  811:    }
  812:  
  813:    if (events & gIIC_Event_SlaveTx_c)
  0014 95       [2]             TSX   
  0015 e601     [3]             LDA   1,X
  0017 a508     [2]             BIT   #8
  0019 2639     [3]             BNE   L54 ;abs = 0054
  001b 203f     [3]             BRA   L5C ;abs = 005c
  001d          L1D:    
  814:    {
  815:      /* Tx call back event received - run through the callback table and execute any
  816:           pending Callbacks */
  817:      while (maIIcTxCallbackLeadingIndex != maIIcTxCallbackTrailingIndex)
  818:      {
  819:         pfCallBack = maIIcTxCallbackTable[maIIcTxCallbackTrailingIndex].pfCallBack;
  001d c60000   [4]             LDA   maIIcTxCallbackTrailingIndex
  0020 ae05     [2]             LDX   #5
  0022 42       [5]             MUL   
  0023 8c       [1]             CLRH  
  0024 97       [1]             TAX   
  0025 9ebe0003 [6]             LDHX  @maIIcTxCallbackTable:3,X
  0029 8b       [2]             PSHH  
  002a 8c       [1]             CLRH  
  002b 89       [2]             PSHX  
  002c 97       [1]             TAX   
  002d d60002   [4]             LDA   @maIIcTxCallbackTable:2,X
  820:        /* Call calback with buffer info as parameter */
  821:        (*pfCallBack)(maIIcTxCallbackTable[maIIcTxCallbackTrailingIndex].pBuf);
  0030 9ebe0000 [6]             LDHX  @maIIcTxCallbackTable,X
  0034 89       [2]             PSHX  
  0035 8b       [2]             PSHH  
  0036 95       [2]             TSX   
  0037 ee03     [3]             LDX   3,X
  0039 89       [2]             PSHX  
  003a 95       [2]             TSX   
  003b ee03     [3]             LDX   3,X
  003d 8a       [3]             PULH  
  003e 87       [2]             PSHA  
  003f ac000000 [8]             CALL  _CALL_STAR08_FAR
  822:        /* Increment and wrap around trailing index */
  823:        if (++maIIcTxCallbackTrailingIndex >= NumberOfElements(maIIcTxCallbackTable))
  0043 450000   [3]             LDHX  @maIIcTxCallbackTrailingIndex
  0046 7c       [4]             INC   ,X
  0047 c60000   [4]             LDA   maIIcTxCallbackTrailingIndex
  004a a103     [2]             CMP   #3
  004c a702     [2]             AIS   #2
  004e 2504     [3]             BCS   L54 ;abs = 0054
  824:        {
  825:          maIIcTxCallbackTrailingIndex = 0;
  0050 4f       [1]             CLRA  
  0051 c70000   [4]             STA   maIIcTxCallbackTrailingIndex
  0054          L54:    
  0054 c60000   [4]             LDA   maIIcTxCallbackTrailingIndex
  0057 c10000   [4]             CMP   maIIcTxCallbackLeadingIndex
  005a 26c1     [3]             BNE   L1D ;abs = 001d
  005c          L5C:    
  826:        }
  827:      }
  828:    }
  829:   
  830:  #if 0
  831:    if (events & gIIC_Event_MasterRxFail_c)
  832:      {
  833:       (*pfIIcMasterRxCallBack)(FALSE); 
  834:       pfIIcMasterRxCallBack = NULL;
  835:      }
  836:    
  837:    
  838:    if (events & gIIC_Event_MasterRxSuccess_c)
  839:      {
  840:       (*pfIIcMasterRxCallBack)(TRUE); 
  841:       pfIIcMasterRxCallBack = NULL;
  842:      }    
  843:    
  844:    
  845:    if (events & gIIC_Event_MasterTxFail_c)  
  846:      {
  847:        (*pfIIcMasterTxCallBack)(FALSE);
  848:        pfIIcMasterTxCallBack = NULL;
  849:      }
  850:    if (events & gIIC_Event_MasterTxSuccess_c)  
  851:      {
  852:        (*pfIIcMasterTxCallBack)(TRUE);
  853:        pfIIcMasterTxCallBack = NULL;
  854:      }    
  855:    
  856:  #endif
  857:    
  858:  #endif  
  859:  } 
  005c a702     [2]             AIS   #2
  005e 8d       [7]             RTC   
  860:  
  861:  
  862:  /*****************************************************************************
  863:  *  IIC_Isr
  864:  *
  865:  *  I2C Interrupt Service Routine.
  866:  ******************************************************************************/
  867:  /* Place it in NON_BANKED memory */
  868:  #ifdef MEMORY_MODEL_BANKED
  869:  #pragma CODE_SEG __NEAR_SEG NON_BANKED
  870:  #else
  871:  #pragma CODE_SEG DEFAULT
  872:  #endif /* MEMORY_MODEL_BANKED */
  873:  
  874:  INTERRUPT_KEYWORD void IIC_Isr(void)
  875:  {
  0000 8b       [2]             PSHH  
  876:  
  877:  #if gIIC_Enabled_d
  878:  
  879:    /* Clear the interrupt request */
  880:    mIIC_S_c |= mIICS_IICIF_c;
  0001 126d     [5]             BSET  1,109
  881:    /* Check arbitration  and slave addressing*/
  882:    if (mIIC_S_c & (mIICS_ARBL_c | mIICS_IAAS_c ))
  0003 b66d     [3]             LDA   109
  0005 a550     [2]             BIT   #80
  0007 2736     [3]             BEQ   L3F ;abs = 003f
  883:    {
  884:      if (mIIC_S_c & mIICS_IAAS_c)
  0009 0d6d0f   [5]             BRCLR 6,109,L1B ;abs = 001b
  885:        {
  886:        /* Check if I2C module was addressed for read or for write */
  887:        if(mIIC_S_c & mIICS_SRW_c)
  000c 056d04   [5]             BRCLR 2,109,L13 ;abs = 0013
  888:          {
  889:           /* Configure I2C module for Tx operation.Writing to IICxC register also clears IAAS bit */
  890:           mIIC_C_c |= mIICC_TX_c;
  000f 186c     [5]             BSET  4,108
  891:           /* Send next byte from the current Tx buffer */
  892:           //IIC_SendNextByte();
  893:          }
  0011 2008     [3]             BRA   L1B ;abs = 001b
  0013          L13:    
  894:        else
  895:          {
  896:           /* Configure I2C module for Rx operation.Writing to IICxC register also clears IAAS bit */
  897:           mIIC_C_c &= ~(mIICC_TX_c | mIICC_TXAK_c);
  0013 b66c     [3]             LDA   108
  0015 a4e7     [2]             AND   #-25
  0017 b76c     [3]             STA   108
  898:           mIIC_D_c;
  0019 b66e     [3]             LDA   110
  001b          L1B:    
  899:          }
  900:  
  901:        }
  902:      if(mIIC_S_c & mIICS_ARBL_c)
  001b 096d1f   [5]             BRCLR 4,109,L3D ;abs = 003d
  903:        {
  904:        /* Arbitration lost */
  905:         mIIC_S_c |= mIICS_ARBL_c;    
  001e 186d     [5]             BSET  4,109
  906:         
  907:         if(mIICMasterOp.iicOpType == mIIC_OpType_Tx_c)
  0020 c60000   [4]             LDA   mIICMasterOp
  0023 260d     [3]             BNE   L32 ;abs = 0032
  908:          {
  909:           if(pfIIcMasterTxCallBack)
  0025 450000   [3]             LDHX  @pfIIcMasterTxCallBack
  0028 cd0000   [6]             JSR   _CMP24_RC
  002b 00               DC.B  0
  002c 0000             DC.W  0
  002e 2631     [3]             BNE   L61 ;abs = 0061
  0030          L30:    
  910:            {
  911:             TS_SendEvent(gIIcTaskId, gIIC_Event_MasterTxFail_c); 
  912:            }
  913:            
  914:          }
  915:         else
  916:          {
  917:          if(pfIIcMasterRxCallBack)
  918:            {
  919:            TS_SendEvent(gIIcTaskId, gIIC_Event_MasterRxFail_c);    
  920:            }
  921:          
  922:          }
  923:        }
  924:    }
  925:    else
  926:    {
  927:      /* Arbitration okay
  928:         Check addressing */
  929:    if(mIIC_C_c & mIICC_MST_c)/* Master mode */
  930:      {
  931:       if(mIIC_C_c & mIICC_TX_c)
  932:        {
  933:          if(mIIC_S_c & mIICS_RXAK_c)// No ack received
  934:            {
  935:              mIIC_C_c &= ~(mIICC_MST_c | mIICC_TX_c);
  936:              if(mIICMasterOp.iicOpType == mIIC_OpType_Tx_c)	// Tx
  937:                {
  938:                if(pfIIcMasterTxCallBack)
  939:                 {
  940:                  TS_SendEvent(gIIcTaskId, gIIC_Event_MasterTxFail_c); 
  941:                 }
  942:                }
  943:              else	// Rx
  944:                {
  945:                if(pfIIcMasterRxCallBack)
  946:                 {
  947:                  TS_SendEvent(gIIcTaskId, gIIC_Event_MasterRxFail_c);    
  948:                 }
  949:                }
  950:            }
  951:          else	// Ack received
  952:            {
  953:              if(mIICMasterOp.iicOpType == mIIC_OpType_Rx_c)	// Rx
  954:                {
  955:                mIIC_C_c &= ~(mIICC_TX_c | mIICC_TXAK_c);
  956:                if(mIICMasterOp.bufLen-- == 1)  
  957:                  {
  958:                   mIIC_C_c |= mIICC_TXAK_c;
  959:                  }
  960:                mIIC_D_c;  
  961:                }
  962:              else	// Tx
  963:                {
  964:                 if(mIICMasterOp.bufLen)
  965:                  {
  966:                   mIIC_D_c =  *mIICMasterOp.pBuf++ ;
  967:                   mIICMasterOp.bufLen--;
  968:                  }
  969:                 else
  970:                  {
  971:                   mIIC_C_c &= ~(mIICC_MST_c | mIICC_TX_c); 
  972:                   if(pfIIcMasterTxCallBack)
  973:                    {
  974:                     TS_SendEvent(gIIcTaskId, gIIC_Event_MasterTxSuccess_c); 
  975:                    }
  976:                   
  977:                  }
  978:                }
  979:            }
  980:        }
  981:       else// (mIIC_C_c & mIICC_TX_c) == 0       
  982:        {
  983:         if(mIICMasterOp.bufLen == 0)   
  984:          {
  985:          mIIC_C_c &= ~mIICC_MST_c;   
  986:          if(pfIIcMasterRxCallBack)
  987:            {
  988:             TS_SendEvent(gIIcTaskId, gIIC_Event_MasterRxSuccess_c); 
  989:            }
  990:          }
  991:         else if(mIICMasterOp.bufLen-- == 1)  
  992:          {
  993:           mIIC_C_c |= mIICC_TXAK_c;
  994:          }
  995:         *mIICMasterOp.pBuf++ = mIIC_D_c;
  996:          
  997:        }
  998:       
  999:      }
 1000:      
 1001:    else   /* slave mode*/
 1002:      {
 1003:      if (mIIC_C_c & mIICC_TX_c)
 1004:        {
 1005:          /* IIC has Tx a byte to master. Check if ack was received */
 1006:          if (mIIC_S_c & mIICS_RXAK_c)
 1007:          {
 1008:            /* No ack received. Switch back to receive mode */
 1009:            mIIC_C_c &= ~mIICC_TX_c;
 1010:            mIIC_D_c;
 1011:          }
 1012:          else
 1013:          {
 1014:            /* Ack received. Send next byte */
 1015:            //IIC_SendNextByte();
 1016:          }
 1017:        }
 1018:      else
 1019:        {
 1020:          /* Put the received byte in the buffer */
 1021:          if(pfIIcSlaveRxCallBack)
 1022:            {
 1023:            maIIcRxBuf[mIIcRxBufLeadingIndex] = mIIC_D_c;
 1024:  
 1025:            if (++mIIcRxBufLeadingIndex >= sizeof(maIIcRxBuf)) 
 1026:              {
 1027:              mIIcRxBufLeadingIndex = 0;
 1028:              }
 1029:  
 1030:            if (mIIcRxBufferByteCount < sizeof(maIIcRxBuf)) 
 1031:              {
 1032:              ++mIIcRxBufferByteCount;
 1033:              }
 1034:            else
 1035:              {
 1036:               if (++mIIcRxBufTrailingIndex >= sizeof(maIIcRxBuf)) 
 1037:                 {
 1038:                  mIIcRxBufTrailingIndex = 0;
 1039:                 }
 1040:              }
 1041:              
 1042:          /* Let the application know a byte has been received. */
 1043:            TS_SendEvent(gIIcTaskId, gIIC_Event_SlaveRx_c);
 1044:              
 1045:            }
 1046:          else
 1047:            {
 1048:             mIIC_D_c; 
 1049:            }
 1050:        }  
 1051:      }/* Data transfer.Check if it is a Tx or Rx operation */
 1052:        
 1053:      
 1054:    }
 1055:    
 1056:  #endif  
 1057:  }
  0030 8a       [3]             PULH  
  0031 80       [9]             RTI   
  0032          L32:    
  0032 450000   [3]             LDHX  @pfIIcMasterRxCallBack
  0035 cd0000   [6]             JSR   _CMP24_RC
  0038 00               DC.B  0
  0039 0000             DC.W  0
  003b 2636     [3]             BNE   L73 ;abs = 0073
  003d          L3D:    
  003d 8a       [3]             PULH  
  003e 80       [9]             RTI   
  003f          L3F:    
  003f 0a6c03   [5]             BRSET 5,108,L45 ;abs = 0045
  0042 cc00fe   [4]             JMP   LFE ;abs = 00fe
  0045          L45:    
  0045 096c7f   [5]             BRCLR 4,108,LC7 ;abs = 00c7
  0048 016d2f   [5]             BRCLR 0,109,L7A ;abs = 007a
  004b b66c     [3]             LDA   108
  004d a4cf     [2]             AND   #-49
  004f b76c     [3]             STA   108
  0051 c60000   [4]             LDA   mIICMasterOp
  0054 2612     [3]             BNE   L68 ;abs = 0068
  0056 450000   [3]             LDHX  @pfIIcMasterTxCallBack
  0059 cd0000   [6]             JSR   _CMP24_RC
  005c 00               DC.B  0
  005d 0000             DC.W  0
  005f 274b     [3]             BEQ   LAC ;abs = 00ac
  0061          L61:    
  0061 c60000   [4]             LDA   gIIcTaskId
  0064 ae40     [2]             LDX   #64
  0066 205c     [3]             BRA   LC4 ;abs = 00c4
  0068          L68:    
  0068 450000   [3]             LDHX  @pfIIcMasterRxCallBack
  006b cd0000   [6]             JSR   _CMP24_RC
  006e 00               DC.B  0
  006f 0000             DC.W  0
  0071 2739     [3]             BEQ   LAC ;abs = 00ac
  0073          L73:    
  0073 c60000   [4]             LDA   gIIcTaskId
  0076 ae10     [2]             LDX   #16
  0078 204a     [3]             BRA   LC4 ;abs = 00c4
  007a          L7A:    
  007a c60000   [4]             LDA   mIICMasterOp
  007d 4b16     [4]             DBNZA L95 ;abs = 0095
  007f b66c     [3]             LDA   108
  0081 a4e7     [2]             AND   #-25
  0083 b76c     [3]             STA   108
  0085 c60003   [4]             LDA   mIICMasterOp:3
  0088 97       [1]             TAX   
  0089 4a       [1]             DECA  
  008a c70003   [4]             STA   mIICMasterOp:3
  008d a301     [2]             CPX   #1
  008f 2675     [3]             BNE   L106 ;abs = 0106
  0091 166c     [5]             BSET  3,108
  0093          L93:    
  0093 2071     [3]             BRA   L106 ;abs = 0106
  0095          L95:    
  0095 c60003   [4]             LDA   mIICMasterOp:3
  0098 2714     [3]             BEQ   LAE ;abs = 00ae
  009a 320001   [5]             LDHX  mIICMasterOp:1
  009d f6       [3]             LDA   ,X
  009e b76e     [3]             STA   110
  00a0 450001   [3]             LDHX  @mIICMasterOp:1
  00a3 6c01     [5]             INC   1,X
  00a5 2601     [3]             BNE   LA8 ;abs = 00a8
  00a7 7c       [4]             INC   ,X
  00a8          LA8:    
  00a8 450003   [3]             LDHX  @mIICMasterOp:3
  00ab 7a       [4]             DEC   ,X
  00ac          LAC:    
  00ac 8a       [3]             PULH  
  00ad 80       [9]             RTI   
  00ae          LAE:    
  00ae b66c     [3]             LDA   108
  00b0 a4cf     [2]             AND   #-49
  00b2 b76c     [3]             STA   108
  00b4 450000   [3]             LDHX  @pfIIcMasterTxCallBack
  00b7 cd0000   [6]             JSR   _CMP24_RC
  00ba 00               DC.B  0
  00bb 0000             DC.W  0
  00bd 273d     [3]             BEQ   LFC ;abs = 00fc
  00bf c60000   [4]             LDA   gIIcTaskId
  00c2 ae80     [2]             LDX   #-128
  00c4          LC4:    
  00c4 cc014c   [4]             JMP   L14C ;abs = 014c
  00c7          LC7:    
  00c7 c60003   [4]             LDA   mIICMasterOp:3
  00ca 2619     [3]             BNE   LE5 ;abs = 00e5
  00cc 1b6c     [5]             BCLR  5,108
  00ce 450000   [3]             LDHX  @pfIIcMasterRxCallBack
  00d1 cd0000   [6]             JSR   _CMP24_RC
  00d4 00               DC.B  0
  00d5 0000             DC.W  0
  00d7 2715     [3]             BEQ   LEE ;abs = 00ee
  00d9 c60000   [4]             LDA   gIIcTaskId
  00dc ae20     [2]             LDX   #32
  00de 8c       [1]             CLRH  
  00df ac000000 [8]             CALL  TS_SendEvent
  00e3          LE3:    
  00e3 2009     [3]             BRA   LEE ;abs = 00ee
  00e5          LE5:    
  00e5 97       [1]             TAX   
  00e6 4a       [1]             DECA  
  00e7 c70003   [4]             STA   mIICMasterOp:3
  00ea 5b02     [4]             DBNZX LEE ;abs = 00ee
  00ec 166c     [5]             BSET  3,108
  00ee          LEE:    
  00ee b66e     [3]             LDA   110
  00f0 320001   [5]             LDHX  mIICMasterOp:1
  00f3 f7       [2]             STA   ,X
  00f4 450001   [3]             LDHX  @mIICMasterOp:1
  00f7 6c01     [5]             INC   1,X
  00f9 265a     [3]             BNE   L155 ;abs = 0155
  00fb 7c       [4]             INC   ,X
  00fc          LFC:    
  00fc 8a       [3]             PULH  
  00fd 80       [9]             RTI   
  00fe          LFE:    
  00fe 096c07   [5]             BRCLR 4,108,L108 ;abs = 0108
  0101 016d51   [5]             BRCLR 0,109,L155 ;abs = 0155
  0104 196c     [5]             BCLR  4,108
  0106          L106:   
  0106 204b     [3]             BRA   L153 ;abs = 0153
  0108          L108:   
  0108 450000   [3]             LDHX  @pfIIcSlaveRxCallBack
  010b cd0000   [6]             JSR   _CMP24_RC
  010e 00               DC.B  0
  010f 0000             DC.W  0
  0111 2740     [3]             BEQ   L153 ;abs = 0153
  0113 8c       [1]             CLRH  
  0114 ce0000   [4]             LDX   mIIcRxBufLeadingIndex
  0117 b66e     [3]             LDA   110
  0119 d70000   [4]             STA   @maIIcRxBuf,X
  011c 450000   [3]             LDHX  @mIIcRxBufLeadingIndex
  011f 7c       [4]             INC   ,X
  0120 c60000   [4]             LDA   mIIcRxBufLeadingIndex
  0123 a120     [2]             CMP   #32
  0125 2504     [3]             BCS   L12B ;abs = 012b
  0127 4f       [1]             CLRA  
  0128 c70000   [4]             STA   mIIcRxBufLeadingIndex
  012b          L12B:   
  012b c60000   [4]             LDA   mIIcRxBufferByteCount
  012e a120     [2]             CMP   #32
  0130 2406     [3]             BCC   L138 ;abs = 0138
  0132 450000   [3]             LDHX  @mIIcRxBufferByteCount
  0135 7c       [4]             INC   ,X
  0136 200f     [3]             BRA   L147 ;abs = 0147
  0138          L138:   
  0138 450000   [3]             LDHX  @mIIcRxBufTrailingIndex
  013b 7c       [4]             INC   ,X
  013c c60000   [4]             LDA   mIIcRxBufTrailingIndex
  013f a120     [2]             CMP   #32
  0141 2504     [3]             BCS   L147 ;abs = 0147
  0143 4f       [1]             CLRA  
  0144 c70000   [4]             STA   mIIcRxBufTrailingIndex
  0147          L147:   
  0147 c60000   [4]             LDA   gIIcTaskId
  014a ae04     [2]             LDX   #4
  014c          L14C:   
  014c 8c       [1]             CLRH  
  014d ac000000 [8]             CALL  TS_SendEvent
  0151 8a       [3]             PULH  
  0152 80       [9]             RTI   
  0153          L153:   
  0153 b66e     [3]             LDA   110
  0155          L155:   
  0155 8a       [3]             PULH  
  0156 80       [9]             RTI   
 1058:  #pragma CODE_SEG DEFAULT           
 1059:  
 1060:  
 1061:  /*****************************************************************************
 1062:  ******************************************************************************
 1063:  * Private functions
 1064:  ******************************************************************************
 1065:  *****************************************************************************/
 1066:  
 1067:  #if gIIC_Enabled_d
 1068:  
 1069:  /*****************************************************************************
 1070:  *   IIC_TaskInit 
 1071:  *
 1072:  *   Creates the I2C module task
 1073:  ******************************************************************************/
 1074:  static void IIC_TaskInit(void)
 1075:  {
 1076:    gIIcTaskId = TS_CreateTask(gTsI2CTaskPriority_c, IIC_Task);
  0000 a605     [2]             LDA   #5
  0002 87       [2]             PSHA  
  0003 450000   [3]             LDHX  @IIC_Task
  0006 89       [2]             PSHX  
  0007 8b       [2]             PSHH  
  0008 a600     [2]             LDA   @IIC_Task:PAGE
  000a 87       [2]             PSHA  
  000b ac000000 [8]             CALL  TS_CreateTask
  000f a704     [2]             AIS   #4
  0011 c70000   [4]             STA   gIIcTaskId
 1077:  }                                       
  0014 8d       [7]             RTC   
 1078:  
 1079:  /*****************************************************************************
 1080:  *   IIC_SendNextByte 
 1081:  *
 1082:  *   Send next byte of information from the Tx buffer
 1083:  ******************************************************************************/
 1084:  #if 0
 1085:  
 1086:  static void IIC_SendNextByte (void)
 1087:  {
 1088:    void (*pfCallBack)(unsigned char const *pBuf);
 1089:    
 1090:    /* The HCS08 does not save H on interrupt. */
 1091:    __asm 
 1092:    {
 1093:      PSHH
 1094:    }
 1095:  
 1096:    
 1097:  #if gIIC_Slave_TxDataAvailableSignal_Enable_c  
 1098:    if(IIC_IsTxDataAvailable())
 1099:  #else
 1100:    if(maIIcTxBufLenTable[mIIcTxBufRefTrailingIndex])  
 1101:  #endif  
 1102:    {
 1103:      /* Write a byte. */
 1104:      mIIC_D_c = maIIcTxBufRefTable[mIIcTxBufRefTrailingIndex].pBuf[mIIcTxCurIndex];
 1105:  
 1106:      /* Finished with this buffer? */
 1107:      if (++mIIcTxCurIndex >= maIIcTxBufLenTable[mIIcTxBufRefTrailingIndex]) 
 1108:      {
 1109:  
 1110:        /* Mark this one as done, and call the callback. */
 1111:        maIIcTxBufLenTable[mIIcTxBufRefTrailingIndex] = 0;
 1112:        pfCallBack = maIIcTxBufRefTable[mIIcTxBufRefTrailingIndex].pfCallBack;
 1113:        if (pfCallBack)
 1114:        {
 1115:          /* Signal the IIC task that we got a callback to be executed */
 1116:          TS_SendEvent(gIIcTaskId, gIIC_Event_SlaveTx_c);
 1117:          /* Add callback information to the callback table */
 1118:          maIIcTxCallbackTable[maIIcTxCallbackLeadingIndex].pfCallBack = pfCallBack;
 1119:          maIIcTxCallbackTable[maIIcTxCallbackLeadingIndex].pBuf = maIIcTxBufRefTable[mIIcTxBufRefTrailingIndex].pBuf;
 1120:          /* Increment and wrap around the leading index */
 1121:          if (++maIIcTxCallbackLeadingIndex >= NumberOfElements(maIIcTxCallbackTable)) {
 1122:            maIIcTxCallbackLeadingIndex = 0;
 1123:          }
 1124:        
 1125:        }
 1126:        /* Increment to the next buffer. */
 1127:        mIIcTxCurIndex = 0;
 1128:        if (++mIIcTxBufRefTrailingIndex >= NumberOfElements(maIIcTxBufRefTable)) 
 1129:        {
 1130:          mIIcTxBufRefTrailingIndex = 0;
 1131:        }
 1132:  
 1133:  #if gIIC_Slave_TxDataAvailableSignal_Enable_c        
 1134:        /* If there is no more data to send, turn off the transmit interrupt. */
 1135:        if (!maIIcTxBufLenTable[mIIcTxBufRefTrailingIndex]) 
 1136:        {
 1137:          /* Signal to host that there are no more data to receive */
 1138:          IIC_TxDataAvailable(FALSE);
 1139:        }
 1140:  #endif      
 1141:      }
 1142:    }
 1143:    else
 1144:    {
 1145:      /* Write a byte. */
 1146:      mIIC_D_c = 0;
 1147:    }
 1148:    __asm 
 1149:    {
 1150:      PULH
 1151:    }
 1152:  }
 1153:  
 1154:  #endif
 1155:  
 1156:  
 1157:  #endif
 1158:  
