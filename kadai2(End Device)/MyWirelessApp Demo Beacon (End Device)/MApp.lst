*** EVALUATION ***
ANSI-C/cC++ Compiler for HC08 V-5.0.41 Build 12319, Nov 15 2012

    1:  /*****************************************************************************
    2:  * MyWirelessApp Demo Beacon End Device application.
    3:  *
    4:  * (c) Copyright 2008, Freescale, Inc. All rights reserved.
    5:  *
    6:  *
    7:  * No part of this document must be reproduced in any form - including copied,
    8:  * transcribed, printed or by any electronic means - without specific written
    9:  * permission from Freescale Semiconductor.
   10:  *
   11:  *****************************************************************************/
   12:  
   13:  #include "MApp.h"
   14:  #include "Sound.h"
   15:  #include "NVM_Interface.h"
   16:  #include "IIC_Interface.h" // New
   17:  //#include "IoConfig.h"
   18:  
   19:  
   20:  /************************************************************************************
   21:  *************************************************************************************
   22:  * Private macros
   23:  *************************************************************************************
   24:  ************************************************************************************/
   25:  
   26:  /* If there are too many pending packets to be send over the air, */
   27:  /* receive mMaxKeysToReceive_c chars. */
   28:  /* The chars will be send over the air when there are no pending packets*/
   29:  #define mMaxKeysToReceive_c 32
   30:  
   31:  //----------Sensor switch--------
   32:  #define gMPL3115A2_enable 0
   33:  #define gMMA8652_enable   1
   34:  #define gMAG3110_enable   0
   35:  #define gFXAS21000_enable 0
   36:  #define gMMA9553_enable   0
   37:  //-------------------------------
   38:  
   39:  /************************************************************************************
   40:  *************************************************************************************
   41:  * Private prototypes
   42:  *************************************************************************************
   43:  ************************************************************************************/
   44:  
   45:  /* Forward declarations of helper functions */
   46:  static void    UartRxCallBack(void);
   47:  static uint8_t App_StartScan(uint8_t scanType);
   48:  static uint8_t App_HandleScanActiveConfirm(nwkMessage_t *pMsg);
   49:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType);
   50:  static uint8_t App_SendAssociateRequest(void);
   51:  static uint8_t App_HandleAssociateConfirm(nwkMessage_t *pMsg);
   52:  static void    App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn);
   53:  static void    App_TransmitSensorData(void);
   54:  #if (gMC1323xMatrixKBD_d == TRUE)
   55:  static void    App_HandleKeys(uint8_t events, uint8_t pressedKey);
   56:  #else
   57:  static void    App_HandleKeys(key_event_t events);
   58:  #endif //gMC1323xMatrixKBD_d
   59:  
   60:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg);
   61:  static uint8_t App_SendSyncRequest(void);
   62:  static void GenandTransData(uint8_t Length, uint8_t* pTxData, uint8_t* dest_addr);
   63:  
   64:  static void count_timer  (uint8_t timerId);
   65:  
   66:  volatile static uint8_t global_counter;
   67:  
   68:  static void count_timer(uint8_t timerId){
   69:  	uint8_t data[2];
   70:  	(void)timerId;  /* prevent compiler warning */
   71:  	global_counter++;
  0000 450000   [3]             LDHX  @global_counter
  0003 7c       [4]             INC   ,X
   72:  }
  0004 8d       [7]             RTC   
   73:  
   74:  /************************************************************************************
   75:  *************************************************************************************
   76:  * Private memory declarations
   77:  *************************************************************************************
   78:  ************************************************************************************/
   79:  
   80:  //Default Pan ID
   81:  static const uint8_t coordinaterPanId[2] = { (mDefaultValueOfPanId_c & 0xff), (mDefaultValueOfPanId_c >> 8)};
   82:  
   83:  
   84:  /************************************************************************************
   85:  *************************************************************************************
   86:  * Private memory declarations
   87:  *************************************************************************************
   88:  ************************************************************************************/
   89:  
   90:  /* Information about the PAN we are part of */
   91:  static panDescriptor_t mCoordInfo;
   92:  
   93:  /* This is either the short address assigned by the PAN coordinator
   94:     during association, or our own extended MAC address. */
   95:  static uint8_t maMyAddress[8];
   96:  
   97:  /* The devices address mode. If 2 (gAddrModeShort_c), then maMyAddress
   98:     contains the short address assigned by the PAN coordinator. If 3
   99:     (gAddrModeLong_c), then maMyAddress is equal to the extended address. */
  100:  static uint8_t mAddrMode;
  101:  
  102:  /* Data request packet for sending UART input to the coordinator */
  103:  static nwkToMcpsMessage_t *mpPacket;
  104:  
  105:  /* The MSDU handle is a unique data packet identifier */
  106:  static uint8_t mMsduHandle;
  107:  
  108:  /* Number of pending data packets */
  109:  static uint8_t mcPendingPackets;
  110:  
  111:  /* Application input queues */
  112:  static anchor_t mMlmeNwkInputQueue;
  113:  static anchor_t mMcpsNwkInputQueue;
  114:  
  115:  /************************************************************************************
  116:  *************************************************************************************
  117:  * Public memory declarations
  118:  *************************************************************************************
  119:  ************************************************************************************/
  120:  
  121:  /* The current state of the applications state machine */
  122:  uint8_t gState;
  123:  
  124:  uint8_t MPL3115A2_start_flag = 0;
  125:  uint8_t MMA8652_start_flag   = 0;
  126:  uint8_t MAG3110_start_flag   = 0;
  127:  uint8_t FXAS21000_start_flag = 0;
  128:  uint8_t MMA9553_start_flag   = 0;
  129:  
  130:  /* This data set contains application variables to be preserved across resets */
  131:  NvDataItemDescription_t const gaNvAppDataSet[] = {
  132:    {NULL, 0}       /* Required end-of-table marker. */
  133:  };
  134:  
  135:  STATIC tmrTimerID_t mTimerID = gTmrInvalidTimerID_c;
  136:  
  137:  /************************************************************************************
  138:  *************************************************************************************
  139:  * Public functions
  140:  *************************************************************************************
  141:  ************************************************************************************/
  142:  
  143:  void DeepSleepWakeupStackProc(void);
  144:  
  145:  /*****************************************************************************
  146:  * Initialization function for the App Task. This is called during
  147:  * initialization and should contain any application specific initialization
  148:  * (ie. hardware initialization/setup, table initialization, power up
  149:  * notificaiton.
  150:  *
  151:  * Interface assumptions: None
  152:  *
  153:  * Return value: None
  154:  *
  155:  *****************************************************************************/
  156:  void MApp_init(void)
  157:  { 
  158:    
  159:    /* The initial application state */
  160:    gState = stateInit;    
  0000 4f       [1]             CLRA  
  0001 c70000   [4]             STA   gState
  161:    /* Reset number of pending packets */
  162:    mcPendingPackets = 0;
  0004 c70000   [4]             STA   mcPendingPackets
  163:  
  164:    /* Initialize the MAC 802.15.4 extended address */
  165:    Init_MacExtendedAddress();
  0007 ac000000 [8]             CALL  Init_MacExtendedAddress
  166:    /* register keyboard callback function */
  167:    KBD_Init(App_HandleKeys);
  000b 450000   [3]             LDHX  @App_HandleKeys
  000e 89       [2]             PSHX  
  000f 8b       [2]             PSHH  
  0010 a600     [2]             LDA   @App_HandleKeys:PAGE
  0012 87       [2]             PSHA  
  0013 ac000000 [8]             CALL  KBD_Init
  0017 a703     [2]             AIS   #3
  168:    /* Initialize SPI Module */
  169:    SPI_Init();
  0019 ac000000 [8]             CALL  SPI1_Init
  170:    /* initialize LCD Module */
  171:    LCD_Init();
  172:    /* initialize LED Module */
  173:    LED_Init();
  001d ac000000 [8]             CALL  LED_Init
  174:    /* Initialize the LPM module */
  175:    PWRLib_Init();
  0021 ac000000 [8]             CALL  PWRLib_Init
  176:    /* Initialize the UART so that we can print out status messages */
  177:    UartX_SetBaud(gUartDefaultBaud_c);
  0025 ae34     [2]             LDX   #52
  0027 8c       [1]             CLRH  
  0028 ac000000 [8]             CALL  Uart1_SetBaud
  178:    UartX_SetRxCallBack(UartRxCallBack);
  002c 450000   [3]             LDHX  @UartRxCallBack
  002f 89       [2]             PSHX  
  0030 8b       [2]             PSHH  
  0031 a600     [2]             LDA   @UartRxCallBack:PAGE
  0033 87       [2]             PSHA  
  0034 ac000000 [8]             CALL  Uart1_SetRxCallBack
  0038 a703     [2]             AIS   #3
  179:    
  180:    /* Initialize the IIC module */
  181:    IIC_Bus_Reset();  // Reset IIC bus to prevent freezing sensor module using GPIO 
  003a ac000000 [8]             CALL  IIC_Bus_Reset
  182:    IIC_ModuleInit(); // New      
  003e ac000000 [8]             CALL  IIC_ModuleInit
  183:        
  184:  #if gMPL3115A2_enable
  185:    MPL3115A2_Init();
  186:  #endif
  187:    
  188:  #if gMMA8652_enable
  189:    MMA8652_Init();
  0042 ac000000 [8]             CALL  MMA8652_Init
  190:  #endif   
  191:  
  192:  #if gMAG3110_enable
  193:    MAG3110_Init();
  194:  #endif 
  195:    
  196:  #if gFXAS21000_enable
  197:    FXAS21000_Init();
  198:  #endif 
  199:   
  200:  #if gMMA9553_enable
  201:    MMA9553_Init();
  202:  #endif   
  203:    
  204:    /* initialize buzzer (NCB, SRB only) */  
  205:    BuzzerInit();  
  206:    /* Prepare input queues.*/
  207:    MSG_InitQueue(&mMlmeNwkInputQueue); 
  0046 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0049 ac000000 [8]             CALL  List_ClearAnchor
  208:    MSG_InitQueue(&mMcpsNwkInputQueue);  
  004d 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0050 ac000000 [8]             CALL  List_ClearAnchor
  209:    /* Enable MCU interrupts */
  210:    IrqControlLib_EnableAllIrqs();
  0054 9a       [1]             CLI   
  211:    /*signal app ready*/  
  212:    Led1Flashing();
  0055 a601     [2]             LDA   #1
  0057 ac000000 [8]             CALL  LED_StartFlash
  213:    Led2Flashing();
  005b a602     [2]             LDA   #2
  005d ac000000 [8]             CALL  LED_StartFlash
  214:    Led3Flashing();
  0061 a604     [2]             LDA   #4
  0063 ac000000 [8]             CALL  LED_StartFlash
  215:    Led4Flashing();
  0067 a608     [2]             LDA   #8
  0069 ac000000 [8]             CALL  LED_StartFlash
  216:      
  217:    UartUtil_Print("\n\rPress any switch on board to start running the application.\n\r", gAllowToBlock_d);  
  006d 450000   [3]             LDHX  @"\012\015Press any switch on board to start running the application.\012\015"
  0070 a601     [2]             LDA   #1
  0072 ac000000 [8]             CALL  UartUtil_Print
  218:    
  219:    LCD_WriteString(1,"Press any key");
  220:    LCD_WriteString(2,"to start.");
  221:    
  222:    mTimerID = TMR_AllocateTimer();
  0076 ac000000 [8]             CALL  TMR_AllocateTimer
  007a c70000   [4]             STA   mTimerID
  223:    TMR_StartIntervalTimer(mTimerID, 1000, count_timer);
  007d 87       [2]             PSHA  
  007e 4503e8   [3]             LDHX  #1000
  0081 89       [2]             PSHX  
  0082 8b       [2]             PSHH  
  0083 4f       [1]             CLRA  
  0084 87       [2]             PSHA  
  0085 87       [2]             PSHA  
  0086 450000   [3]             LDHX  @count_timer
  0089 89       [2]             PSHX  
  008a 8b       [2]             PSHH  
  008b a600     [2]             LDA   @count_timer:PAGE
  008d 87       [2]             PSHA  
  008e ac000000 [8]             CALL  TMR_StartIntervalTimer
  0092 a708     [2]             AIS   #8
  224:    
  225:  }
  0094 8d       [7]             RTC   
  226:  
  227:  /*****************************************************************************
  228:  *Mac Application Task event processor.  This function is called to
  229:  * process all events for the task. Events include timers, messages and any
  230:  * other user defined events
  231:  *
  232:  * Interface assumptions: None
  233:  *
  234:  * Return value: None
  235:  *****************************************************************************/
  236:  void AppTask(event_t events) 
  237:  { 
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fc     [2]             AIS   #-4
  238:  
  239:    /* Pointer for storing the messages from MLME, MCPS, and ASP. */
  240:    void *pMsgIn;
  241:    /* Stores the status code returned by some functions. */
  242:    uint8_t rc;
  243:    pMsgIn = NULL;
  0004 9e6f04   [6]             CLR   4,SP
  0007 9e6f03   [6]             CLR   3,SP
  244:    
  245:    /* Dequeue the MLME message */
  246:    if (events & gAppEvtMessageFromMLME_c)
  000a 9f       [1]             TXA   
  000b a504     [2]             BIT   #4
  000d 2726     [3]             BEQ   L35 ;abs = 0035
  247:    {
  248:      /* Get the message from MLME */
  249:      pMsgIn = MSG_DeQueue(&mMlmeNwkInputQueue);
  000f 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0012 ac000000 [8]             CALL  List_RemoveHead
  0016 9eff03   [5]             STHX  3,SP
  250:      
  251:      /* Any time a beacon might arrive. Always handle the beacon frame first */
  252:      if (pMsgIn)
  0019 271a     [3]             BEQ   L35 ;abs = 0035
  253:      {               
  254:        rc = App_WaitMsg(pMsgIn, gNwkBeaconNotifyInd_c);
  001b a604     [2]             LDA   #4
  001d ac000000 [8]             CALL  App_WaitMsg
  255:        if(rc == errorNoError)
  0021 4d       [1]             TSTA  
  0022 2611     [3]             BNE   L35 ;abs = 0035
  256:        {
  257:          /* ALWAYS free the beacon frame contained in the beacon notify indication.*/
  258:          /* ALSO the application can use the beacon payload.*/
  259:          MSG_Free(((nwkMessage_t *)pMsgIn)->msgData.beaconNotifyInd.pBufferRoot);
  0024 9efe03   [5]             LDHX  3,SP
  0027 9ece0a   [5]             LDHX  10,X
  002a ac000000 [8]             CALL  MM_Free
  260:          UartUtil_Print("Received an MLME-Beacon Notify Indication\n\r", gAllowToBlock_d);
  002e 450000   [3]             LDHX  @"Received an MLME-Beacon Notify Indication\012\015"
  0031 ac000215 [8]             CALL  AppTask:533
  0035          L35:    
  261:        }
  262:      }
  263:    }
  264:    /* The application state machine */
  265:    switch(gState)
  0035 c60000   [4]             LDA   gState
  0038 a105     [2]             CMP   #5
  003a 221f     [3]             BHI   L5B ;abs = 005b
  003c 4d       [1]             TSTA  
  003d 271f     [3]             BEQ   L5E ;abs = 005e
  003f 410122   [4]             CBEQA #1,L64 ;abs = 0064
  0042 a102     [2]             CMP   #2
  0044 2733     [3]             BEQ   L79 ;abs = 0079
  0046 a103     [2]             CMP   #3
  0048 2603     [3]             BNE   L4D ;abs = 004d
  004a cc0116   [4]             JMP   L116 ;abs = 0116
  004d          L4D:    
  004d a104     [2]             CMP   #4
  004f 2603     [3]             BNE   L54 ;abs = 0054
  0051 cc013a   [4]             JMP   L13A ;abs = 013a
  0054          L54:    
  0054 a105     [2]             CMP   #5
  0056 2603     [3]             BNE   L5B ;abs = 005b
  0058 cc01a1   [4]             JMP   L1A1 ;abs = 01a1
  005b          L5B:    
  005b cc0114   [4]             JMP   L114 ;abs = 0114
  005e          L5E:    
  266:    {
  267:    case stateInit:    
  268:      /* Print a welcome message to the UART */
  269:      UartUtil_Print("\n\rMyWirelessApp Demo Beacon End Device application is initialized and ready.\n\r\n\r", gAllowToBlock_d);            
  005e 450000   [3]             LDHX  @"\012\015MyWirelessApp Demo Beacon End Device application is initialized and ready.\012\015\012\015"
  270:      /* Goto Active Scan state. */
  271:      gState = stateScanActiveStart;
  272:      //gState = stateListen;
  273:      TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  274:      break;
  0061 cc018c   [4]             JMP   L18C ;abs = 018c
  0064          L64:    
  275:      
  276:    case stateScanActiveStart:
  277:      /* Start the Active scan, and goto wait for confirm state. */
  278:      UartUtil_Print("Start scanning for a PAN coordinator\n\r", gAllowToBlock_d);
  0064 450000   [3]             LDHX  @"Start scanning for a PAN coordinator\012\015"
  0067 ac000215 [8]             CALL  AppTask:533
  279:      /*print a message on the LCD also*/
  280:      LCD_ClearDisplay();
  281:      LCD_WriteString(1,"Start scanning");
  282:      LCD_WriteString(2,"for coordinator");
  283:      rc = App_StartScan(gScanModeActive_c);
  006b a601     [2]             LDA   #1
  006d ac000000 [8]             CALL  App_StartScan
  284:      if(rc == errorNoError)
  0071 4d       [1]             TSTA  
  0072 2621     [3]             BNE   L95 ;abs = 0095
  285:      {
  286:        gState = stateScanActiveWaitConfirm;
  0074 a602     [2]             LDA   #2
  0076 cc0135   [4]             JMP   L135 ;abs = 0135
  0079          L79:    
  287:      }
  288:      break;
  289:      
  290:    case stateScanActiveWaitConfirm:
  291:      /* Stay in this state until the Scan confirm message
  292:         arrives, and then goto the associate state. */
  293:      if (events & gAppEvtMessageFromMLME_c)
  0079 95       [2]             TSX   
  007a e605     [3]             LDA   5,X
  007c a504     [2]             BIT   #4
  007e 2603     [3]             BNE   L83 ;abs = 0083
  0080 cc0114   [4]             JMP   L114 ;abs = 0114
  0083          L83:    
  294:      {
  295:        if (pMsgIn)
  0083 9efe03   [5]             LDHX  3,SP
  0086 2603     [3]             BNE   L8B ;abs = 008b
  0088 cc0114   [4]             JMP   L114 ;abs = 0114
  008b          L8B:    
  296:        {                            
  297:          rc = App_WaitMsg(pMsgIn, gNwkScanCnf_c);
  008b 9eff01   [5]             STHX  1,SP
  008e a60b     [2]             LDA   #11
  0090 ac000000 [8]             CALL  App_WaitMsg
  298:          if(rc == errorNoError)
  0094 4d       [1]             TSTA  
  0095          L95:    
  0095 267d     [3]             BNE   L114 ;abs = 0114
  299:          {
  300:            rc = App_HandleScanActiveConfirm(pMsgIn);
  0097 9efe01   [5]             LDHX  1,SP
  009a ac000000 [8]             CALL  App_HandleScanActiveConfirm
  301:            if(rc == errorNoError)
  009e 4d       [1]             TSTA  
  009f 266c     [3]             BNE   L10D ;abs = 010d
  302:            {
  303:              UartUtil_Print("Found a coordinator with the following properties:\n\r", gAllowToBlock_d);
  00a1 450000   [3]             LDHX  @"Found a coordinator with the following properties:\012\015"
  00a4 ac000215 [8]             CALL  AppTask:533
  304:              UartUtil_Print("----------------------------------------------------", gAllowToBlock_d);
  00a8 450000   [3]             LDHX  @"----------------------------------------------------"
  00ab ac000215 [8]             CALL  AppTask:533
  305:              UartUtil_Print("\n\rAddress............0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.coordAddress, 
  00af 450000   [3]             LDHX  @"\012\015Address............0x"
  00b2 ac000215 [8]             CALL  AppTask:533
  00b6 450000   [3]             LDHX  @mCoordInfo
  00b9 89       [2]             PSHX  
  00ba 8b       [2]             PSHH  
  00bb ce000a   [4]             LDX   mCoordInfo:10
  00be 510202   [4]             CBEQX #2,LC3 ;abs = 00c3
  306:                                                                   mCoordInfo.coordAddrMode == gAddrModeShort_c ? 2 : 8, 0);
  00c1 ae08     [2]             LDX   #8
  00c3          LC3:    
  00c3 4f       [1]             CLRA  
  00c4 ac000000 [8]             CALL  UartUtil_PrintHex
  00c8 a702     [2]             AIS   #2
  307:              UartUtil_Print("\n\rPAN ID.............0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.coordPanId, 2, 0);
  00ca 450000   [3]             LDHX  @"\012\015PAN ID.............0x"
  00cd ac000215 [8]             CALL  AppTask:533
  00d1 450008   [3]             LDHX  @mCoordInfo:8
  00d4 ac00021c [8]             CALL  AppTask:540
  308:              UartUtil_Print("\n\rLogical Channel....0x", gAllowToBlock_d); UartUtil_PrintHex(&mCoordInfo.logicalChannel, 1, 0);
  00d8 450000   [3]             LDHX  @"\012\015Logical Channel....0x"
  00db ac000215 [8]             CALL  AppTask:533
  00df 45000b   [3]             LDHX  @mCoordInfo:11
  00e2 ac000228 [8]             CALL  AppTask:552
  309:              UartUtil_Print("\n\rBeacon Spec........0x", gAllowToBlock_d); UartUtil_PrintHex(mCoordInfo.superFrameSpec, 2, 0);
  00e6 450000   [3]             LDHX  @"\012\015Beacon Spec........0x"
  00e9 ac000215 [8]             CALL  AppTask:533
  00ed 45000f   [3]             LDHX  @mCoordInfo:15
  00f0 ac00021c [8]             CALL  AppTask:540
  310:              UartUtil_Print("\n\rLink Quality.......0x", gAllowToBlock_d); UartUtil_PrintHex(&mCoordInfo.linkQuality, 1, 0);
  00f4 450000   [3]             LDHX  @"\012\015Link Quality.......0x"
  00f7 ac000215 [8]             CALL  AppTask:533
  00fb 450012   [3]             LDHX  @mCoordInfo:18
  00fe ac000228 [8]             CALL  AppTask:552
  311:              UartUtil_Print("\n\r\n\r", gAllowToBlock_d);
  0102 450000   [3]             LDHX  @"\012\015\012\015"
  0105 ac000215 [8]             CALL  AppTask:533
  312:  
  313:              /* Go to the Associate state */
  314:              gState = stateAssociate;
  0109 a603     [2]             LDA   #3
  315:              TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  316:            }
  010b 207a     [3]             BRA   L187 ;abs = 0187
  010d          L10D:   
  317:            else
  318:            {
  319:              UartUtil_Print("Scan did not find a suitable coordinator\n\r", gAllowToBlock_d);
  010d 450000   [3]             LDHX  @"Scan did not find a suitable coordinator\012\015"
  0110 ac000215 [8]             CALL  AppTask:533
  0114          L114:   
  0114 2022     [3]             BRA   L138 ;abs = 0138
  0116          L116:   
  320:              /*print a message on the LCD also*/
  321:              LCD_ClearDisplay();
  322:              LCD_WriteString(1,"No coordinator");
  323:              LCD_WriteString(2,"found");
  324:            }            
  325:          }
  326:        }
  327:      }
  328:      break;
  329:  
  330:    case stateAssociate:
  331:      /* Associate to the PAN coordinator */
  332:      UartUtil_Print("Associating to PAN coordinator on channel 0x", gAllowToBlock_d);
  0116 450000   [3]             LDHX  @"Associating to PAN coordinator on channel 0x"
  0119 ac000215 [8]             CALL  AppTask:533
  333:      UartUtil_PrintHex(&(mCoordInfo.logicalChannel), 1, gPrtHexNewLine_c);
  011d 45000b   [3]             LDHX  @mCoordInfo:11
  0120 89       [2]             PSHX  
  0121 8b       [2]             PSHH  
  0122 ae01     [2]             LDX   #1
  0124 a602     [2]             LDA   #2
  0126 ac000000 [8]             CALL  UartUtil_PrintHex
  012a a702     [2]             AIS   #2
  334:      /*print a message on the LCD also*/
  335:      LCD_ClearDisplay();
  336:      LCD_WriteString(1,"Associating to ");
  337:      LCD_WriteString(2,"PAN coordinator");
  338:  
  339:      rc = App_SendAssociateRequest();
  012c ac000000 [8]             CALL  App_SendAssociateRequest
  340:      if(rc == errorNoError)
  0130 4d       [1]             TSTA  
  0131 266c     [3]             BNE   L19F ;abs = 019f
  341:        gState = stateAssociateWaitConfirm;
  0133 a604     [2]             LDA   #4
  0135          L135:   
  0135 c70000   [4]             STA   gState
  0138          L138:   
  0138 2065     [3]             BRA   L19F ;abs = 019f
  013a          L13A:   
  342:      break; 
  343:  
  344:    case stateAssociateWaitConfirm:
  345:      /* Stay in this state until the Associate confirm message
  346:         arrives, and then goto the Listen state. */
  347:      if (events & gAppEvtMessageFromMLME_c)
  013a 95       [2]             TSX   
  013b e605     [3]             LDA   5,X
  013d a504     [2]             BIT   #4
  013f 275e     [3]             BEQ   L19F ;abs = 019f
  348:      {
  349:        if (pMsgIn)
  0141 9efe03   [5]             LDHX  3,SP
  0144 2759     [3]             BEQ   L19F ;abs = 019f
  350:        {   
  351:          rc = App_WaitMsg(pMsgIn, gNwkAssociateCnf_c);    
  0146 9eff01   [5]             STHX  1,SP
  0149 a601     [2]             LDA   #1
  014b ac000000 [8]             CALL  App_WaitMsg
  352:          if(rc == errorNoError)
  014f 4d       [1]             TSTA  
  0150 2677     [3]             BNE   L1C9 ;abs = 01c9
  353:          {
  354:            rc = App_HandleAssociateConfirm(pMsgIn);
  0152 9efe01   [5]             LDHX  1,SP
  0155 ac000000 [8]             CALL  App_HandleAssociateConfirm
  355:            if (rc == errorNoError)
  0159 4d       [1]             TSTA  
  015a 262d     [3]             BNE   L189 ;abs = 0189
  356:            { 
  357:                UartUtil_Print("Successfully associated with the coordinator.\n\r", gAllowToBlock_d);
  015c 450000   [3]             LDHX  @"Successfully associated with the coordinator.\012\015"
  015f ac000215 [8]             CALL  AppTask:533
  358:                UartUtil_Print("We were assigned the short address 0x", gAllowToBlock_d);
  0163 450000   [3]             LDHX  @"We were assigned the short address 0x"
  0166 ac000215 [8]             CALL  AppTask:533
  359:                UartUtil_PrintHex(maMyAddress, mAddrMode == gAddrModeShort_c ? 2 : 8, 0);
  016a 450000   [3]             LDHX  @maMyAddress
  016d 89       [2]             PSHX  
  016e 8b       [2]             PSHH  
  016f ce0000   [4]             LDX   mAddrMode
  0172 510202   [4]             CBEQX #2,L177 ;abs = 0177
  0175 ae08     [2]             LDX   #8
  0177          L177:   
  0177 4f       [1]             CLRA  
  0178 ac000000 [8]             CALL  UartUtil_PrintHex
  017c a702     [2]             AIS   #2
  360:                UartUtil_Print("\n\r\n\rReady to send and receive data over the UART.\n\r\n\r", gAllowToBlock_d);
  017e 450000   [3]             LDHX  @"\012\015\012\015Ready to send and receive data over the UART.\012\015\012\015"
  0181 ac000215 [8]             CALL  AppTask:533
  361:                /*print a message on the LCD also*/
  362:                LCD_ClearDisplay();
  363:                LCD_WriteString(1,"Ready to send");
  364:                LCD_WriteString(2,"and receive data");      
  365:                
  366:                gState = stateListen;
  0185 a605     [2]             LDA   #5
  0187          L187:   
  367:                TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  368:            } 
  0187 2009     [3]             BRA   L192 ;abs = 0192
  0189          L189:   
  369:            else 
  370:            {
  371:            
  372:            UartUtil_Print("\n\rAssociate Confirm wasn't successful... \n\r\n\r", gAllowToBlock_d);
  0189 450000   [3]             LDHX  @"\012\015Associate Confirm wasn't successful... \012\015\012\015"
  018c          L18C:   
  018c ac000215 [8]             CALL  AppTask:533
  373:            gState = stateScanActiveStart;
  0190 a601     [2]             LDA   #1
  0192          L192:   
  0192 c70000   [4]             STA   gState
  374:            TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);
  0195 c60000   [4]             LDA   gAppTaskID_c
  0198 ae01     [2]             LDX   #1
  019a 8c       [1]             CLRH  
  019b ac000000 [8]             CALL  TS_SendEvent
  019f          L19F:   
  019f 2028     [3]             BRA   L1C9 ;abs = 01c9
  01a1          L1A1:   
  375:            }
  376:          }
  377:        }
  378:      }
  379:      break; 
  380:      
  381:    case stateListen:
  382:      /* Transmit to coordinator data received from UART. */
  383:      if (events & gAppEvtMessageFromMLME_c)
  01a1 95       [2]             TSX   
  01a2 e605     [3]             LDA   5,X
  01a4 a504     [2]             BIT   #4
  01a6 2709     [3]             BEQ   L1B1 ;abs = 01b1
  384:      {  
  385:        if (pMsgIn)
  01a8 9efe03   [5]             LDHX  3,SP
  01ab 2704     [3]             BEQ   L1B1 ;abs = 01b1
  386:        {  
  387:          /* Process it */
  388:          rc = App_HandleMlmeInput(pMsgIn);
  01ad ac000000 [8]             CALL  App_HandleMlmeInput
  01b1          L1B1:   
  389:        }
  390:      } 
  391:      
  392:  
  393:  #if gMPL3115A2_enable    
  394:      MPL3115A2_dump(events);
  395:  #endif
  396:    
  397:  #if gMMA8652_enable    
  398:  	// Start to receive periodical data 
  399:  	if(MMA8652_start_flag){
  01b1 c60000   [4]             LDA   MMA8652_start_flag
  01b4 2708     [3]             BEQ   L1BE ;abs = 01be
  400:  		MMA8652_start_flag = 0;
  01b6 4f       [1]             CLRA  
  01b7 c70000   [4]             STA   MMA8652_start_flag
  401:  		MMA8652_Start_Periodical_data();
  01ba ac000000 [8]             CALL  MMA8652_Start_Periodical_data
  01be          L1BE:   
  402:  	}
  403:  	
  404:  	if (events & gAppEvt_FromMMA8652_c){
  01be 95       [2]             TSX   
  01bf e604     [3]             LDA   4,X
  01c1 a502     [2]             BIT   #2
  01c3 2704     [3]             BEQ   L1C9 ;abs = 01c9
  405:  		/* get byte from UART */
  406:  		App_TransmitSensorData();
  01c5 ac000000 [8]             CALL  App_TransmitSensorData
  01c9          L1C9:   
  407:  	}
  408:      //MMA8652_dump(events);
  409:  #endif
  410:      
  411:  #if gMAG3110_enable    
  412:      MAG3110_dump(events);
  413:  #endif
  414:      
  415:  #if gFXAS21000_enable    
  416:      FXAS21000_dump(events);
  417:  #endif
  418:      
  419:  #if gMMA9553_enable    
  420:      MMA9553_dump(events);
  421:  #endif
  422:      
  423:      break;
  424:    }
  425:    
  426:    if (pMsgIn)
  01c9 9efe03   [5]             LDHX  3,SP
  01cc 2704     [3]             BEQ   L1D2 ;abs = 01d2
  427:    {
  428:      /* Messages must always be freed. */ 
  429:      MSG_Free(pMsgIn);
  01ce ac000000 [8]             CALL  MM_Free
  01d2          L1D2:   
  430:    }
  431:    
  432:     /* Handle MCPS confirms and transmit data from UART */
  433:    if (events & gAppEvtMessageFromMCPS_c)
  01d2 95       [2]             TSX   
  01d3 e605     [3]             LDA   5,X
  01d5 a508     [2]             BIT   #8
  01d7 271b     [3]             BEQ   L1F4 ;abs = 01f4
  434:    {      
  435:      /* Get the message from MCPS */
  436:      pMsgIn = MSG_DeQueue(&mMcpsNwkInputQueue);
  01d9 450000   [3]             LDHX  @mMcpsNwkInputQueue
  01dc ac000000 [8]             CALL  List_RemoveHead
  437:      if (pMsgIn)
  01e0 650000   [3]             CPHX  #0
  01e3 270f     [3]             BEQ   L1F4 ;abs = 01f4
  438:      {              
  439:        /* Process it */
  440:        App_HandleMcpsInput(pMsgIn);
  01e5 89       [2]             PSHX  
  01e6 8b       [2]             PSHH  
  01e7 ac000000 [8]             CALL  App_HandleMcpsInput
  441:        /* Messages from the MCPS must always be freed. */
  442:        MSG_Free(pMsgIn);
  01eb 9efe01   [5]             LDHX  1,SP
  01ee ac000000 [8]             CALL  MM_Free
  01f2 a702     [2]             AIS   #2
  01f4          L1F4:   
  443:      }
  444:    }
  445:    
  446:    /* Check for pending messages in the Queue */ 
  447:    if(MSG_Pending(&mMcpsNwkInputQueue))
  01f4 320000   [5]             LDHX  mMcpsNwkInputQueue
  01f7 270a     [3]             BEQ   L203 ;abs = 0203
  448:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  01f9 c60000   [4]             LDA   gAppTaskID_c
  01fc ae08     [2]             LDX   #8
  01fe 8c       [1]             CLRH  
  01ff ac000000 [8]             CALL  TS_SendEvent
  0203          L203:   
  449:    if(MSG_Pending(&mMlmeNwkInputQueue))
  0203 320000   [5]             LDHX  mMlmeNwkInputQueue
  0206 270a     [3]             BEQ   L212 ;abs = 0212
  450:      TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);  
  0208 c60000   [4]             LDA   gAppTaskID_c
  020b ae04     [2]             LDX   #4
  020d 8c       [1]             CLRH  
  020e ac000000 [8]             CALL  TS_SendEvent
  0212          L212:   
  451:  }
  0212 a706     [2]             AIS   #6
  0214 8d       [7]             RTC   
  0215          L215:   
  0215 a601     [2]             LDA   #1
  0217 ac000000 [8]             CALL  UartUtil_Print
  021b 8d       [7]             RTC   
  021c          L21C:   
  021c 89       [2]             PSHX  
  021d 8b       [2]             PSHH  
  021e ae02     [2]             LDX   #2
  0220 4f       [1]             CLRA  
  0221 ac000000 [8]             CALL  UartUtil_PrintHex
  0225 a702     [2]             AIS   #2
  0227 8d       [7]             RTC   
  0228          L228:   
  0228 89       [2]             PSHX  
  0229 8b       [2]             PSHH  
  022a ae01     [2]             LDX   #1
  022c 4f       [1]             CLRA  
  022d ac000000 [8]             CALL  UartUtil_PrintHex
  0231 a702     [2]             AIS   #2
  0233 8d       [7]             RTC   
  452:  
  453:  /************************************************************************************
  454:  *************************************************************************************
  455:  * Private functions
  456:  *************************************************************************************
  457:  ************************************************************************************/
  458:  
  459:  /*****************************************************************************
  460:  * UartRxCallBack
  461:  *
  462:  * This callback is triggered when a new byte is received over the UART
  463:  *
  464:  *****************************************************************************/
  465:  static void UartRxCallBack(void) 
  466:  {
  0000 8b       [2]             PSHH  
  467:    uint8_t pressedKey;
  468:  	if(stateListen == gState){
  0001 c60000   [4]             LDA   gState
  0004 a105     [2]             CMP   #5
  0006 260c     [3]             BNE   L14 ;abs = 0014
  469:      TS_SendEvent(gAppTaskID_c, gAppEvtRxFromUart_c);
  0008 c60000   [4]             LDA   gAppTaskID_c
  000b ae02     [2]             LDX   #2
  000d 8c       [1]             CLRH  
  000e ac000000 [8]             CALL  TS_SendEvent
  470:    }else{
  471:  	  (void)UartX_GetByteFromRxBuffer(&pressedKey);
  472:    }
  473:  }
  0012 8a       [3]             PULH  
  0013 8d       [7]             RTC   
  0014          L14:    
  0014 95       [2]             TSX   
  0015 ac000000 [8]             CALL  Uart1_GetByteFromRxBuffer
  0019 8a       [3]             PULH  
  001a 8d       [7]             RTC   
  474:  
  475:  /******************************************************************************
  476:  * The App_HandleMlmeInput(nwkMessage_t *pMsg) function will handle various
  477:  * messages from the MLME, e.g. Beacon notifications; 
  478:  *
  479:  * The function may return either of the following values:
  480:  *   errorNoError:   The message was processed.
  481:  *   errorNoMessage: The message pointer is NULL.
  482:  *
  483:  ******************************************************************************/
  484:  static uint8_t App_HandleMlmeInput(nwkMessage_t *pMsg)
  485:  {
  486:    if(pMsg == NULL)
  0000 650000   [3]             CPHX  #0
  0003 2603     [3]             BNE   L8 ;abs = 0008
  487:      return errorNoMessage;
  0005 a603     [2]             LDA   #3
  0007 8d       [7]             RTC   
  0008          L8:     
  488:    
  489:    /* Handle the incoming message. The type determines the sort of processing. */
  490:    switch(pMsg->msgType)
  0008 f6       [3]             LDA   ,X
  0009 a104     [2]             CMP   #4
  000b 2607     [3]             BNE   L14 ;abs = 0014
  491:    {
  492:      case gNwkBeaconNotifyInd_c:   
  493:        /* Always free pBufferRoot */    
  494:        MSG_Free(((nwkMessage_t *)pMsg)->msgData.beaconNotifyInd.pBufferRoot);
  000d 9ece0a   [5]             LDHX  10,X
  0010 ac000000 [8]             CALL  MM_Free
  0014          L14:    
  495:        break;  
  496:           
  497:    }
  498:    return errorNoError;
  0014 4f       [1]             CLRA  
  499:  }
  0015 8d       [7]             RTC   
  500:  /************************************************************************************
  501:  *************************************************************************************
  502:  * Private functions
  503:  *************************************************************************************
  504:  ************************************************************************************/
  505:  
  506:  
  507:  /******************************************************************************
  508:  * The App_StartScan(scanType) function will start the scan process of the
  509:  * specified type in the MAC. This is accomplished by allocating a MAC message,
  510:  * which is then assigned the desired scan parameters and sent to the MLME
  511:  * service access point.
  512:  * The function may return either of the following values:
  513:  *   errorNoError:          The Scan message was sent successfully.
  514:  *   errorInvalidParameter: The MLME service access point rejected the
  515:  *                          message due to an invalid parameter.
  516:  *   errorAllocFailed:      A message buffer could not be allocated.
  517:  *
  518:  ******************************************************************************/
  519:  static uint8_t App_StartScan(uint8_t scanType)
  520:  {
  0000 87       [2]             PSHA  
  0001 a7fe     [2]             AIS   #-2
  521:    mlmeMessage_t *pMsg;
  522:    mlmeScanReq_t *pScanReq;
  523:  
  524:    UartUtil_Print("Sending the MLME-Scan Request message to the MAC...", gAllowToBlock_d);
  0003 450000   [3]             LDHX  @"Sending the MLME-Scan Request message to the MAC..."
  0006 ac000056 [8]             CALL  App_StartScan:86
  525:  
  526:    /* Allocate a message for the MLME (We should check for NULL). */
  527:    pMsg = MSG_AllocType(mlmeMessage_t);
  000a a60f     [2]             LDA   #15
  000c ac000000 [8]             CALL  MM_Alloc
  0010 9eff01   [5]             STHX  1,SP
  528:    if(pMsg != NULL)
  0013 2735     [3]             BEQ   L4A ;abs = 004a
  529:    {
  530:      /* This is a MLME-SCAN.req command */
  531:      pMsg->msgType = gMlmeScanReq_c;
  0015 a608     [2]             LDA   #8
  0017 f7       [2]             STA   ,X
  532:      /* Create the Scan request message data. */
  533:      pScanReq = &pMsg->msgData.scanReq;
  534:      /* gScanModeED_c, gScanModeActive_c, gScanModePassive_c, or gScanModeOrphan_c */
  535:      pScanReq->scanType = scanType;
  0018 9ee603   [4]             LDA   3,SP
  001b e701     [3]             STA   1,X
  536:      /* ChannelsToScan & 0xFF - LSB, always 0x00 */
  537:      pScanReq->scanChannels[0] = (uint8_t)((mDefaultValueOfChannel_c)     & 0xFF);
  001d 6f02     [5]             CLR   2,X
  538:      /* ChannelsToScan>>8 & 0xFF  */
  539:      pScanReq->scanChannels[1] = (uint8_t)((mDefaultValueOfChannel_c>>8)  & 0xFF);
  001f a680     [2]             LDA   #-128
  0021 e703     [3]             STA   3,X
  540:      /* ChannelsToScan>>16 & 0xFF  */
  541:      pScanReq->scanChannels[2] = (uint8_t)((mDefaultValueOfChannel_c>>16) & 0xFF);
  0023 6f04     [5]             CLR   4,X
  542:      /* ChannelsToScan>>24 & 0xFF - MSB */
  543:      pScanReq->scanChannels[3] = (uint8_t)((mDefaultValueOfChannel_c>>24) & 0xFF);
  0025 6f05     [5]             CLR   5,X
  544:      /* Duration per channel 0-14 (dc). T[sec] = (16*960*((2^dc)+1))/1000000.
  545:         A scan duration of 2 on 16 channels approximately takes 1.2 secs. */
  546:      /* We know beforehand that we will talk to a coordinator with a Beacon
  547:         order of 1. Thus, choosing a Scan Duration of 2 per channel gives us
  548:         a very good chance (100% assuming no interference) of finding the
  549:         coordinator. 1 should be fine too though in an RF quiet environment. */
  550:      pScanReq->scanDuration = mDefaultValueOfScanDuration_c;
  0027 a607     [2]             LDA   #7
  0029 e706     [3]             STA   6,X
  551:  #ifdef gMAC2006_d
  552:  	pScanReq->securityLevel = 0;
  553:  #endif //gMAC2006_d	
  554:      
  555:      /* Send the Scan request to the MLME. */
  556:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  002b 9efe01   [5]             LDHX  1,SP
  002e ac000000 [8]             CALL  NWK_MLME_SapHandler
  0032 4d       [1]             TSTA  
  0033 260a     [3]             BNE   L3F ;abs = 003f
  557:      {
  558:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  0035 450000   [3]             LDHX  @"Done\012\015"
  0038 ac000056 [8]             CALL  App_StartScan:86
  559:        return errorNoError;
  003c 4f       [1]             CLRA  
  003d 2014     [3]             BRA   L53 ;abs = 0053
  003f          L3F:    
  560:      }
  561:      else
  562:      {
  563:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  003f 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  0042 ac000056 [8]             CALL  App_StartScan:86
  564:        return errorInvalidParameter;
  0046 a605     [2]             LDA   #5
  0048 2009     [3]             BRA   L53 ;abs = 0053
  004a          L4A:    
  565:      }
  566:    }
  567:    else
  568:    {
  569:      /* Allocation of a message buffer failed. */
  570:      UartUtil_Print("Message allocation failed!\n\r", gAllowToBlock_d);
  004a 450000   [3]             LDHX  @"Message allocation failed!\012\015"
  004d ac000056 [8]             CALL  App_StartScan:86
  571:      return errorAllocFailed;
  0051 a604     [2]             LDA   #4
  0053          L53:    
  572:    }
  573:  }
  0053 a703     [2]             AIS   #3
  0055 8d       [7]             RTC   
  0056          L56:    
  0056 a601     [2]             LDA   #1
  0058 ac000000 [8]             CALL  UartUtil_Print
  005c 8d       [7]             RTC   
  574:  
  575:  /******************************************************************************
  576:  * The App_HandleScanActiveConfirm(nwkMessage_t *pMsg) function will handle the
  577:  * Active Scan confirm message received from the MLME when the Active scan has
  578:  * completed. The message contains a list of PAN descriptors. Based on link
  579:  * quality information in the pan descriptors the nearest coordinator is chosen.
  580:  * The corresponding pan descriptor is stored in the global variable mCoordInfo. 
  581:  *
  582:  * If a suitable coordinator was found, we synchronize to it immediately.
  583:  *
  584:  * The function may return either of the following values:
  585:  *   errorNoError:       A suitable pan descriptor was found.
  586:  *   errorNoScanResults: No scan results were present in the confirm message.
  587:  *
  588:  ******************************************************************************/
  589:  static uint8_t App_HandleScanActiveConfirm(nwkMessage_t *pMsg)
  590:  {
  0000 a7f3     [2]             AIS   #-13
  591:    void    *pBlock;
  592:    uint8_t panDescListSize = pMsg->msgData.scanCnf.resultListSize;
  0002 e603     [3]             LDA   3,X
  0004 9ee70a   [4]             STA   10,SP
  593:    uint8_t rc = errorNoScanResults;
  0007 a606     [2]             LDA   #6
  0009 9ee707   [4]             STA   7,SP
  594:    uint8_t j;
  595:    uint8_t bestLinkQuality = 0;  
  000c 9e6f09   [6]             CLR   9,SP
  596:    panDescriptorBlock_t *pDescBlock = pMsg->msgData.scanCnf.resList.pPanDescriptorBlocks;  
  000f 9ece08   [5]             LDHX  8,X
  0012 9eff05   [5]             STHX  5,SP
  597:    panDescriptor_t *pPanDesc;      
  598:   
  599:    /* Check if the scan resulted in any coordinator responses. */  
  600:    
  601:    if (panDescListSize > 0)
  0015 95       [2]             TSX   
  0016 6d09     [4]             TST   9,X
  0018 266d     [3]             BNE   L87 ;abs = 0087
  001a 206e     [3]             BRA   L8A ;abs = 008a
  001c          L1C:    
  602:    {    
  603:      /* Check all PAN descriptors. */
  604:      while (NULL != pDescBlock)
  605:      {
  606:        for (j = 0; j < pDescBlock->descriptorCount; j++)
  001c 95       [2]             TSX   
  001d 6f07     [5]             CLR   7,X
  001f 204b     [3]             BRA   L6C ;abs = 006c
  0021          L21:    
  607:        {            
  608:          pPanDesc = &pDescBlock->descriptorList[j];
  0021 95       [2]             TSX   
  0022 e607     [3]             LDA   7,X
  0024 ae16     [2]             LDX   #22
  0026 42       [5]             MUL   
  0027 9efe05   [5]             LDHX  5,SP
  002a 9eeb06   [4]             ADD   6,SP
  002d 87       [2]             PSHA  
  002e 8b       [2]             PSHH  
  002f 86       [3]             PULA  
  0030 a900     [2]             ADC   #0
  0032 88       [3]             PULX  
  609:  
  610:          /* Only attempt to associate if the coordinator accepts associations. */
  611:          if( pPanDesc->superFrameSpec[1] & gSuperFrameSpecMsbAssocPermit_c) 
  0033 87       [2]             PSHA  
  0034 8a       [3]             PULH  
  0035 e610     [3]             LDA   16,X
  0037 2a30     [3]             BPL   L69 ;abs = 0069
  612:          {
  613:            if ((pPanDesc->coordPanId[1]==coordinaterPanId[1])&&
  0039 e609     [3]             LDA   9,X
  003b a190     [2]             CMP   #-112
  003d 262a     [3]             BNE   L69 ;abs = 0069
  614:                (pPanDesc->coordPanId[0]==coordinaterPanId[0]))
  003f e608     [3]             LDA   8,X
  0041 a109     [2]             CMP   #9
  0043 2624     [3]             BNE   L69 ;abs = 0069
  615:            {
  616:              /* Find the nearest coordinator using the link quality measure. */
  617:              if(pPanDesc->linkQuality > bestLinkQuality)
  0045 9ee609   [4]             LDA   9,SP
  0048 e112     [3]             CMP   18,X
  004a 241d     [3]             BCC   L69 ;abs = 0069
  618:              {
  619:                /* Save the information of the coordinator candidate. If we
  620:                   find a better candiate, the information will be replaced. */
  621:                FLib_MemCpy(&mCoordInfo, pPanDesc, sizeof(panDescriptor_t));
  004c 9eff01   [5]             STHX  1,SP
  004f 450000   [3]             LDHX  @mCoordInfo
  0052 89       [2]             PSHX  
  0053 8b       [2]             PSHH  
  0054 9efe03   [5]             LDHX  3,SP
  0057 a616     [2]             LDA   #22
  0059 ac000000 [8]             CALL  FLib_MemCpy
  005d a702     [2]             AIS   #2
  622:                bestLinkQuality = pPanDesc->linkQuality;
  005f 9efe01   [5]             LDHX  1,SP
  0062 e612     [3]             LDA   18,X
  0064 95       [2]             TSX   
  0065 e708     [3]             STA   8,X
  623:                rc = errorNoError;
  0067 6f06     [5]             CLR   6,X
  0069          L69:    
  0069 95       [2]             TSX   
  006a 6c07     [5]             INC   7,X
  006c          L6C:    
  006c 9efe05   [5]             LDHX  5,SP
  006f e66e     [3]             LDA   110,X
  0071 9ee108   [4]             CMP   8,SP
  0074 22ab     [3]             BHI   L21 ;abs = 0021
  624:              }
  625:            }
  626:          }      
  627:        }
  628:        
  629:        /* Free current block */
  630:        pBlock = pDescBlock;
  631:        pDescBlock = pDescBlock->pNext;              
  0076 89       [2]             PSHX  
  0077 8b       [2]             PSHH  
  0078 9ece6f   [5]             LDHX  111,X
  007b 9eff07   [5]             STHX  7,SP
  632:        MSG_Free(pBlock);
  007e 9efe01   [5]             LDHX  1,SP
  0081 ac000000 [8]             CALL  MM_Free
  0085 a702     [2]             AIS   #2
  0087          L87:    
  0087 9efe05   [5]             LDHX  5,SP
  008a          L8A:    
  008a 2690     [3]             BNE   L1C ;abs = 001c
  633:      }
  634:    }
  635:  
  636:    if(rc == errorNoError)
  008c 95       [2]             TSX   
  008d 6d06     [4]             TST   6,X
  008f 2703     [3]             BEQ   L94 ;abs = 0094
  0091 cc0150   [4]             JMP   L150 ;abs = 0150
  0094          L94:    
  637:    {
  638:      /* If we have found a beaconing coodinator we must setup the MAC to
  639:         synchronize to the beacon frames. This requires us to set the
  640:         PAN ID attribute of the MAC PIB to the PAN ID of the coordinator.
  641:         Furthermore, if we want to take advantage of the automatic
  642:         polling feature we must set the Auto Request MAC PIB attribute. */
  643:      if((mCoordInfo.superFrameSpec[0] & gSuperFrameSpecLsbBO_c) < 0xF) 
  0094 c6000f   [4]             LDA   mCoordInfo:15
  0097 a40f     [2]             AND   #15
  0099 a10f     [2]             CMP   #15
  009b 2503     [3]             BCS   LA0 ;abs = 00a0
  009d cc0150   [4]             JMP   L150 ;abs = 0150
  00a0          LA0:    
  644:      {
  645:        mlmeMessage_t *pMsgOut = MSG_AllocType(mlmeMessage_t);
  00a0 a60f     [2]             LDA   #15
  00a2 ac000000 [8]             CALL  MM_Alloc
  00a6 9eff03   [5]             STHX  3,SP
  646:        if(pMsgOut != NULL)
  00a9 2603     [3]             BNE   LAE ;abs = 00ae
  00ab cc0150   [4]             JMP   L150 ;abs = 0150
  00ae          LAE:    
  647:        {
  648:          uint8_t value = TRUE;
  00ae a601     [2]             LDA   #1
  00b0 95       [2]             TSX   
  00b1 e70a     [3]             STA   10,X
  649:          uint8_t mBeaconOrder;
  650:  		uint8_t mSuperFrameOrder;
  651:          /* Set MAC PIB auto request to TRUE. In this way the device will
  652:             automatically poll for data if the pending address list of the 
  653:             beacon frame contains our address. */
  654:          pMsgOut->msgType = gMlmeSetReq_c;
  00b3 9efe03   [5]             LDHX  3,SP
  00b6 a609     [2]             LDA   #9
  00b8 f7       [2]             STA   ,X
  655:          pMsgOut->msgData.setReq.pibAttribute = gMPibAutoRequest_c;
  00b9 a642     [2]             LDA   #66
  00bb e701     [3]             STA   1,X
  656:          pMsgOut->msgData.setReq.pibAttributeValue = &value;
  00bd 95       [2]             TSX   
  00be af0a     [2]             AIX   #10
  00c0 9f       [1]             TXA   
  00c1 8b       [2]             PSHH  
  00c2 9efe04   [5]             LDHX  4,SP
  00c5 e703     [3]             STA   3,X
  00c7 86       [3]             PULA  
  00c8 e702     [3]             STA   2,X
  657:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
  658:          (void)MSG_Send(NWK_MLME, pMsgOut);
  00ca ac000000 [8]             CALL  NWK_MLME_SapHandler
  659:          
  660:          /* Since we are going to receive data from the coordinator 
  661:             using automatic polling we must synchronize to the beacon
  662:             and keep tracking it. Before synchronizing it is required
  663:             that the MAC PIB PAN ID, and the MAC PIB coordinator
  664:             address is set. */
  665:          pMsgOut->msgData.setReq.pibAttribute = gMPibPanId_c;
  00ce 9efe03   [5]             LDHX  3,SP
  00d1 a650     [2]             LDA   #80
  00d3 e701     [3]             STA   1,X
  666:          pMsgOut->msgData.setReq.pibAttributeValue = mCoordInfo.coordPanId;
  00d5 a608     [2]             LDA   @mCoordInfo:8:MSB
  00d7 e702     [3]             STA   2,X
  00d9 a608     [2]             LDA   @mCoordInfo:8
  00db e703     [3]             STA   3,X
  667:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
  668:          (void)MSG_Send(NWK_MLME, pMsgOut);
  00dd ac000000 [8]             CALL  NWK_MLME_SapHandler
  669:  
  670:          /* Set coordinator address PIB attribute according the the 
  671:             address mode of the coordinator (short or long address). */
  672:          pMsgOut->msgData.setReq.pibAttribute = 
  673:            mCoordInfo.coordAddrMode == gAddrModeShort_c ? gMPibCoordShortAddress_c :
  00e1 c6000a   [4]             LDA   mCoordInfo:10
  00e4 410203   [4]             CBEQA #2,LEA ;abs = 00ea
  674:                                                          gMPibCoordExtendedAddress_c;
  00e7 a64a     [2]             LDA   #74
  00e9 65       [3]             SKIP2 LEC ;abs = 00ec
  00ea          LEA:    
  00ea a64b     [2]             LDA   #75
  00ec          LEC:    
  00ec 9efe03   [5]             LDHX  3,SP
  00ef e701     [3]             STA   1,X
  675:          pMsgOut->msgData.setReq.pibAttributeValue = mCoordInfo.coordAddress;
  00f1 a600     [2]             LDA   @mCoordInfo:MSB
  00f3 e702     [3]             STA   2,X
  00f5 a600     [2]             LDA   @mCoordInfo
  00f7 e703     [3]             STA   3,X
  676:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
  677:          (void)MSG_Send(NWK_MLME, pMsgOut);
  00f9 ac000000 [8]             CALL  NWK_MLME_SapHandler
  678:  
  679:  
  680:          /* Set macBeaconOrder PIB attribute according to the 
  681:             value found in beacon.*/
  682:          mBeaconOrder = (mCoordInfo.superFrameSpec[0] & 0x0F);   
  00fd c6000f   [4]             LDA   mCoordInfo:15
  0100 a40f     [2]             AND   #15
  0102 95       [2]             TSX   
  0103 e70b     [3]             STA   11,X
  683:          pMsgOut->msgData.setReq.pibAttribute = gMPibBeaconOrder_c;                                             
  0105 9efe03   [5]             LDHX  3,SP
  0108 a647     [2]             LDA   #71
  010a e701     [3]             STA   1,X
  684:          pMsgOut->msgData.setReq.pibAttributeValue = &mBeaconOrder;
  010c 95       [2]             TSX   
  010d af0b     [2]             AIX   #11
  010f 9f       [1]             TXA   
  0110 8b       [2]             PSHH  
  0111 9efe04   [5]             LDHX  4,SP
  0114 e703     [3]             STA   3,X
  0116 86       [3]             PULA  
  0117 e702     [3]             STA   2,X
  685:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
  686:          (void)MSG_Send(NWK_MLME, pMsgOut);
  0119 ac000000 [8]             CALL  NWK_MLME_SapHandler
  687:  
  688:          /* Set macSuperFrameOrder PIB attribute according to the 
  689:             value found in beacon.*/
  690:          mSuperFrameOrder = (mCoordInfo.superFrameSpec[0] & 0xF0);   
  011d c6000f   [4]             LDA   mCoordInfo:15
  0120 a4f0     [2]             AND   #-16
  0122 95       [2]             TSX   
  0123 e70c     [3]             STA   12,X
  691:          pMsgOut->msgData.setReq.pibAttribute = gMPibSuperFrameOrder_c;                                             
  0125 9efe03   [5]             LDHX  3,SP
  0128 a654     [2]             LDA   #84
  012a e701     [3]             STA   1,X
  692:          pMsgOut->msgData.setReq.pibAttributeValue = &mSuperFrameOrder;
  012c 95       [2]             TSX   
  012d af0c     [2]             AIX   #12
  012f 9f       [1]             TXA   
  0130 8b       [2]             PSHH  
  0131 9efe04   [5]             LDHX  4,SP
  0134 e703     [3]             STA   3,X
  0136 86       [3]             PULA  
  0137 e702     [3]             STA   2,X
  693:          /* Get/Set/Reset Request messages are NOT freed by the MLME. */
  694:          (void)MSG_Send(NWK_MLME, pMsgOut);  
  0139 ac000000 [8]             CALL  NWK_MLME_SapHandler
  695:          
  696:          /* Now send the MLME-Sync Request. We choose to let the MAC track
  697:             the beacons on the logical channel obtained by the active scan.*/
  698:          pMsgOut->msgType = gMlmeSyncReq_c;
  013d 9efe03   [5]             LDHX  3,SP
  0140 a60b     [2]             LDA   #11
  0142 f7       [2]             STA   ,X
  699:          pMsgOut->msgData.syncReq.trackBeacon = TRUE;
  0143 a601     [2]             LDA   #1
  0145 e702     [3]             STA   2,X
  700:          pMsgOut->msgData.syncReq.logicalChannel = mCoordInfo.logicalChannel;
  0147 c6000b   [4]             LDA   mCoordInfo:11
  014a e701     [3]             STA   1,X
  701:          (void)MSG_Send(NWK_MLME, pMsgOut);
  014c ac000000 [8]             CALL  NWK_MLME_SapHandler
  0150          L150:   
  702:        }
  703:      }
  704:    }
  705:    
  706:    return rc;
  0150 95       [2]             TSX   
  0151 e606     [3]             LDA   6,X
  707:  }
  0153 a70d     [2]             AIS   #13
  0155 8d       [7]             RTC   
  708:  
  709:  
  710:  /******************************************************************************
  711:  * The App_SendAssociateRequest(void) will create an Associate Request message
  712:  * and send it to the coordinator it wishes to associate to. The function uses
  713:  * information gained about the coordinator during the scan procedure.
  714:  *
  715:  * The function may return either of the following values:
  716:  *   errorNoError:          The Associate Request message was sent successfully.
  717:  *   errorInvalidParameter: The MLME service access point rejected the
  718:  *                          message due to an invalid parameter.
  719:  *   errorAllocFailed:      A message buffer could not be allocated.
  720:  *
  721:  ******************************************************************************/
  722:  static uint8_t App_SendAssociateRequest(void)
  723:  {
  0000 a7fc     [2]             AIS   #-4
  724:    mlmeMessage_t *pMsg;
  725:    mlmeAssociateReq_t *pAssocReq;
  726:  
  727:    UartUtil_Print("Sending the MLME-Associate Request message to the MAC...", gAllowToBlock_d);
  0002 450000   [3]             LDHX  @"Sending the MLME-Associate Request message to the MAC..."
  0005 ac000077 [8]             CALL  App_SendAssociateRequest:119
  728:    
  729:    /* Allocate a message for the MLME message. */
  730:    pMsg = MSG_AllocType(mlmeMessage_t);
  0009 a60f     [2]             LDA   #15
  000b ac000000 [8]             CALL  MM_Alloc
  000f 9eff03   [5]             STHX  3,SP
  731:    if(pMsg != NULL)
  0012 2757     [3]             BEQ   L6B ;abs = 006b
  732:    {
  733:      /* This is a MLME-ASSOCIATE.req command. */
  734:      pMsg->msgType = gMlmeAssociateReq_c;
  0014 7f       [4]             CLR   ,X
  735:      
  736:      /* Create the Associate request message data. */
  737:      pAssocReq = &pMsg->msgData.associateReq;
  0015 af01     [2]             AIX   #1
  738:   
  739:      /* Use the coordinator info we got from the Active Scan. */
  740:      FLib_MemCpy(pAssocReq->coordAddress, mCoordInfo.coordAddress, 8);
  0017 89       [2]             PSHX  
  0018 8b       [2]             PSHH  
  0019 9eff03   [5]             STHX  3,SP
  001c 450000   [3]             LDHX  @mCoordInfo
  001f a608     [2]             LDA   #8
  0021 ac000000 [8]             CALL  FLib_MemCpy
  0025 a702     [2]             AIS   #2
  741:      FLib_MemCpy(pAssocReq->coordPanId,   mCoordInfo.coordPanId, 2);
  0027 9efe01   [5]             LDHX  1,SP
  002a af08     [2]             AIX   #8
  002c 89       [2]             PSHX  
  002d 8b       [2]             PSHH  
  002e 450008   [3]             LDHX  @mCoordInfo:8
  0031 a602     [2]             LDA   #2
  0033 ac000000 [8]             CALL  FLib_MemCpy
  0037 a702     [2]             AIS   #2
  742:      pAssocReq->coordAddrMode      = mCoordInfo.coordAddrMode;
  0039 c6000a   [4]             LDA   mCoordInfo:10
  003c 9efe01   [5]             LDHX  1,SP
  003f e70a     [3]             STA   10,X
  743:      pAssocReq->logicalChannel     = mCoordInfo.logicalChannel;
  0041 c6000b   [4]             LDA   mCoordInfo:11
  0044 e70b     [3]             STA   11,X
  744:  #ifndef gMAC2006_d
  745:      pAssocReq->securityEnable     = FALSE;
  0046 6f0c     [5]             CLR   12,X
  746:  #else
  747:  	pAssocReq->securityLevel = 0;
  748:  #endif //gMAC2006_d	
  749:      /* We want the coordinator to assign a short address to us. */
  750:      pAssocReq->capabilityInfo     = gCapInfoAllocAddr_c;
  0048 a680     [2]             LDA   #-128
  004a e70d     [3]             STA   13,X
  751:        
  752:      /* Send the Associate Request to the MLME. */
  753:      if(MSG_Send(NWK_MLME, pMsg) == gSuccess_c)
  004c 9efe03   [5]             LDHX  3,SP
  004f ac000000 [8]             CALL  NWK_MLME_SapHandler
  0053 4d       [1]             TSTA  
  0054 260a     [3]             BNE   L60 ;abs = 0060
  754:      {
  755:        UartUtil_Print("Done\n\r", gAllowToBlock_d);
  0056 450000   [3]             LDHX  @"Done\012\015"
  0059 ac000077 [8]             CALL  App_SendAssociateRequest:119
  756:        return errorNoError;
  005d 4f       [1]             CLRA  
  005e 2014     [3]             BRA   L74 ;abs = 0074
  0060          L60:    
  757:      }
  758:      else
  759:      {
  760:        /* One or more parameters in the message were invalid. */
  761:        UartUtil_Print("Invalid parameter!\n\r", gAllowToBlock_d);
  0060 450000   [3]             LDHX  @"Invalid parameter!\012\015"
  0063 ac000077 [8]             CALL  App_SendAssociateRequest:119
  762:        return errorInvalidParameter;
  0067 a605     [2]             LDA   #5
  0069 2009     [3]             BRA   L74 ;abs = 0074
  006b          L6B:    
  763:      }
  764:    }
  765:    else
  766:    {
  767:      /* Allocation of a message buffer failed - 
  768:         the state machine will call us again. */
  769:      UartUtil_Print("Message allocation failed - retrying...\n\r", gAllowToBlock_d);
  006b 450000   [3]             LDHX  @"Message allocation failed - retrying...\012\015"
  006e ac000077 [8]             CALL  App_SendAssociateRequest:119
  770:      return errorAllocFailed;
  0072 a604     [2]             LDA   #4
  0074          L74:    
  771:    }
  772:  }
  0074 a704     [2]             AIS   #4
  0076 8d       [7]             RTC   
  0077          L77:    
  0077 a601     [2]             LDA   #1
  0079 ac000000 [8]             CALL  UartUtil_Print
  007d 8d       [7]             RTC   
  773:  
  774:  /******************************************************************************
  775:  * The App_HandleAssociateConfirm(nwkMessage_t *pMsg) function will handle the
  776:  * Associate confirm message received from the MLME when the Association
  777:  * procedure has completed. The message contains the short address that the
  778:  * coordinator has assigned to us. This address is 0xfffe if we did not specify
  779:  * the gCapInfoAllocAddr_c flag in the capability info field of the Associate
  780:  * request. The address and address mode are saved in global variables. They
  781:  * will be used in the next demo application when sending data.
  782:  *
  783:  ******************************************************************************/
  784:  static uint8_t App_HandleAssociateConfirm(nwkMessage_t *pMsg)
  785:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 8b       [2]             PSHH  
  786:  
  787:  	mlmeMessage_t *pMsg_;
  788:  	uint8_t ret;
  789:  	uint8_t boolFlag;
  790:  
  791:  	
  792:    /* This is our own extended address (MAC address). It cannot be modified. */
  793:    extern uint8_t aExtendedAddress[8];
  794:    
  795:    /* If the coordinator assigns a short address of 0xfffe then,
  796:       that means we must use our own extended address in all
  797:       communications with the coordinator. Otherwise, we use
  798:       the short address assigned to us. */
  799:    if ( pMsg->msgData.associateCnf.status == gSuccess_c) 
  0003 6d03     [4]             TST   3,X
  0005 2663     [3]             BNE   L6A ;abs = 006a
  800:    {
  801:  
  802:      if( (pMsg->msgData.associateCnf.assocShortAddress[0] >= 0xFE) && 
  0007 e601     [3]             LDA   1,X
  0009 a1fe     [2]             CMP   #-2
  000b 2516     [3]             BCS   L23 ;abs = 0023
  803:          (pMsg->msgData.associateCnf.assocShortAddress[1] == 0xFF) )
  000d e602     [3]             LDA   2,X
  000f 4c       [1]             INCA  
  0010 2611     [3]             BNE   L23 ;abs = 0023
  804:      {
  805:        mAddrMode = gAddrModeLong_c;
  0012 a603     [2]             LDA   #3
  0014 c70000   [4]             STA   mAddrMode
  806:        FLib_MemCpy(maMyAddress, (void *)aExtendedAddress, 8);
  0017 450000   [3]             LDHX  @maMyAddress
  001a 89       [2]             PSHX  
  001b 8b       [2]             PSHH  
  001c 450000   [3]             LDHX  @aExtendedAddress
  001f a608     [2]             LDA   #8
  807:      }
  0021 200f     [3]             BRA   L32 ;abs = 0032
  0023          L23:    
  808:      else
  809:      {
  810:        mAddrMode = gAddrModeShort_c;
  0023 a602     [2]             LDA   #2
  0025 c70000   [4]             STA   mAddrMode
  811:        FLib_MemCpy(maMyAddress, pMsg->msgData.associateCnf.assocShortAddress, 2);
  0028 450000   [3]             LDHX  @maMyAddress
  002b 89       [2]             PSHX  
  002c 8b       [2]             PSHH  
  002d 9efe04   [5]             LDHX  4,SP
  0030 af01     [2]             AIX   #1
  0032          L32:    
  0032 ac000000 [8]             CALL  FLib_MemCpy
  0036 a702     [2]             AIS   #2
  812:      }
  813:      
  814:      pMsg_=MSG_AllocType(mlmeMessage_t);
  0038 a60f     [2]             LDA   #15
  003a ac000000 [8]             CALL  MM_Alloc
  815:      if (pMsg_ !=NULL)
  003e 650000   [3]             CPHX  #0
  0041 2725     [3]             BEQ   L68 ;abs = 0068
  816:      {
  817:      	pMsg_->msgType=gMlmeSetReq_c;
  0043 a609     [2]             LDA   #9
  0045 f7       [2]             STA   ,X
  818:      	pMsg_->msgData.setReq.pibAttribute=gMPibRxOnWhenIdle_c;
  0046 a652     [2]             LDA   #82
  0048 e701     [3]             STA   1,X
  819:      	boolFlag=TRUE;
  004a a601     [2]             LDA   #1
  820:      	pMsg_->msgData.setReq.pibAttributeValue=&boolFlag;
  004c 89       [2]             PSHX  
  004d 8b       [2]             PSHH  
  004e 95       [2]             TSX   
  004f e702     [3]             STA   2,X
  0051 af02     [2]             AIX   #2
  0053 8b       [2]             PSHH  
  0054 9ee602   [4]             LDA   2,SP
  0057 87       [2]             PSHA  
  0058 8a       [3]             PULH  
  0059 9f       [1]             TXA   
  005a 9eee03   [4]             LDX   3,SP
  005d e703     [3]             STA   3,X
  005f 86       [3]             PULA  
  0060 e702     [3]             STA   2,X
  821:      	ret=MSG_Send(NWK_MLME,pMsg_);
  0062 ac000000 [8]             CALL  NWK_MLME_SapHandler
  0066 a702     [2]             AIS   #2
  0068          L68:    
  822:      }
  823:      
  824:      return gSuccess_c;
  0068 4f       [1]             CLRA  
  0069 65       [3]             SKIP2 L6C ;abs = 006c
  006a          L6A:    
  825:    } 
  826:    
  827:    else 
  828:    {
  829:    return pMsg->msgData.associateCnf.status; 
  006a e603     [3]             LDA   3,X
  006c          L6C:    
  830:    }
  831:    
  832:  }
  006c a703     [2]             AIS   #3
  006e 8d       [7]             RTC   
  833:  
  834:  
  835:  /******************************************************************************
  836:  * The App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn) function will handle 
  837:  * messages from the MCPS, e.g. Data Confirm, and Data Indication.
  838:  *
  839:  ******************************************************************************/
  840:  static void App_HandleMcpsInput(mcpsToNwkMessage_t *pMsgIn)
  841:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 a7fe     [2]             AIS   #-2
  842:    switch(pMsgIn->msgType)
  0004 f6       [3]             LDA   ,X
  0005 2704     [3]             BEQ   LB ;abs = 000b
  0007 4b1f     [4]             DBNZA L28 ;abs = 0028
  0009 200b     [3]             BRA   L16 ;abs = 0016
  000b          LB:     
  843:    {
  844:      /* The MCPS-Data confirm is sent by the MAC to the network 
  845:         or application layer when data has been sent. */
  846:    case gMcpsDataCnf_c:
  847:      if(mcPendingPackets)
  000b c60000   [4]             LDA   mcPendingPackets
  000e 2718     [3]             BEQ   L28 ;abs = 0028
  848:        mcPendingPackets--;
  0010 450000   [3]             LDHX  @mcPendingPackets
  0013 7a       [4]             DEC   ,X
  0014 2012     [3]             BRA   L28 ;abs = 0028
  0016          L16:    
  849:      break;
  850:  
  851:    case gMcpsDataInd_c:
  852:      /* Copy the received data to the UART. */
  853:      UartUtil_Tx(pMsgIn->msgData.dataInd.pMsdu, pMsgIn->msgData.dataInd.msduLength);
  0016 9ece1b   [5]             LDHX  27,X
  0019 9eff01   [5]             STHX  1,SP
  001c 9efe03   [5]             LDHX  3,SP
  001f e617     [3]             LDA   23,X
  0021 9efe01   [5]             LDHX  1,SP
  0024 ac000000 [8]             CALL  UartUtil_Tx
  0028          L28:    
  854:      break;
  855:    }
  856:  }
  0028 a704     [2]             AIS   #4
  002a 8d       [7]             RTC   
  857:  
  858:  /******************************************************************************
  859:  * The App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType) function does not, as
  860:  * the name implies, wait for a message, thus blocking the execution of the
  861:  * state machine. Instead the function analyzes the supplied message to 
  862:  * determine whether or not the message is of the expected type.
  863:  * The function may return either of the following values:
  864:  *   errorNoError: The message was of the expected type.
  865:  *   errorNoMessage: The message pointer is NULL.
  866:  *   errorWrongConfirm: The message is not of the expected type.
  867:  *
  868:  ******************************************************************************/
  869:  static uint8_t App_WaitMsg(nwkMessage_t *pMsg, uint8_t msgType)
  870:  {
  871:    /* Do we have a message? If not, the exit with error code */
  872:    if(pMsg == NULL)
  0000 650000   [3]             CPHX  #0
  0003 2603     [3]             BNE   L8 ;abs = 0008
  873:      return errorNoMessage;
  0005 a603     [2]             LDA   #3
  0007 8d       [7]             RTC   
  0008          L8:     
  874:  
  875:    /* Is it the expected message type? If not then exit with error code */
  876:    if(pMsg->msgType != msgType)
  0008 f1       [3]             CMP   ,X
  0009 2703     [3]             BEQ   LE ;abs = 000e
  877:      return errorWrongConfirm;
  000b a601     [2]             LDA   #1
  000d 8d       [7]             RTC   
  000e          LE:     
  878:  
  879:    /* Found the expected message. Return with success code */
  880:    return errorNoError;
  000e 4f       [1]             CLRA  
  881:  }
  000f 8d       [7]             RTC   
  882:  
  883:  
  884:  void App_TransmitSensorData(void){
  0000 a7f5     [2]             AIS   #-11
  885:  	
  886:  	uint8_t i;
  887:  
  888:  	static uint8_t sens_count=0;
  889:  	static int16_t x_avg=0;
  890:  	static int16_t y_avg=0;
  891:  	static int16_t z_avg=0;
  892:  
  893:  	uint8_t sens_data[7];
  894:  
  895:  	volatile int16_t val;
  896:  
  897:  	UartUtil_Print("\n\r-----------------------------------------------\n\r", gAllowToBlock_d); 
  0002 450000   [3]             LDHX  @"\012\015-----------------------------------------------\012\015"
  0005 ac0001b3 [8]             CALL  App_TransmitSensorData:435
  898:  	for(i=1; i<4; i++){
  0009 a601     [2]             LDA   #1
  000b 95       [2]             TSX   
  000c e701     [3]             STA   1,X
  000e          LE:     
  899:  		val = MMA8652_CatchSensorData(i);
  000e 95       [2]             TSX   
  000f e601     [3]             LDA   1,X
  0011 ac000000 [8]             CALL  MMA8652_CatchSensorData
  0015 9eff0a   [5]             STHX  10,SP
  900:  		switch(i){
  0018 95       [2]             TSX   
  0019 e601     [3]             LDA   1,X
  001b a103     [2]             CMP   #3
  001d 2251     [3]             BHI   L70 ;abs = 0070
  001f 410109   [4]             CBEQA #1,L2B ;abs = 002b
  0022 41021b   [4]             CBEQA #2,L40 ;abs = 0040
  0025 a103     [2]             CMP   #3
  0027 2647     [3]             BNE   L70 ;abs = 0070
  0029 202a     [3]             BRA   L55 ;abs = 0055
  002b          L2B:    
  901:  		case 1:
  902:  			x_avg = (x_avg * sens_count + val)/(sens_count + 1);
  002b 320000   [5]             LDHX  x_avg
  002e ac0001a4 [8]             CALL  App_TransmitSensorData:420
  0032 89       [2]             PSHX  
  0033 8b       [2]             PSHH  
  0034 ac000181 [8]             CALL  App_TransmitSensorData:385
  0038 960000   [5]             STHX  x_avg
  903:  			UartUtil_Print("MMA8652(2g: Int2,Float10) \n\rX axis : 0x", gAllowToBlock_d); 
  003b 450000   [3]             LDHX  @"MMA8652(2g: Int2,Float10) \012\015X axis : 0x"
  904:  			break;
  003e 2028     [3]             BRA   L68 ;abs = 0068
  0040          L40:    
  905:  		case 2:
  906:  			y_avg = (y_avg * sens_count + val)/(sens_count + 1);
  0040 320000   [5]             LDHX  y_avg
  0043 ac0001a4 [8]             CALL  App_TransmitSensorData:420
  0047 89       [2]             PSHX  
  0048 8b       [2]             PSHH  
  0049 ac000181 [8]             CALL  App_TransmitSensorData:385
  004d 960000   [5]             STHX  y_avg
  907:  			UartUtil_Print(" /1024 [g]\n\rY axis : 0x", gAllowToBlock_d);  				
  0050 450000   [3]             LDHX  @" /1024 [g]\012\015Y axis : 0x"
  908:  			break;
  0053 2013     [3]             BRA   L68 ;abs = 0068
  0055          L55:    
  909:  		case 3:
  910:  			z_avg = (z_avg * sens_count + val)/(sens_count + 1);
  0055 320000   [5]             LDHX  z_avg
  0058 ac0001a4 [8]             CALL  App_TransmitSensorData:420
  005c 89       [2]             PSHX  
  005d 8b       [2]             PSHH  
  005e ac000181 [8]             CALL  App_TransmitSensorData:385
  0062 960000   [5]             STHX  z_avg
  911:  			UartUtil_Print(" /1024 [g]\n\rZ axis : 0x", gAllowToBlock_d);  		
  0065 450000   [3]             LDHX  @" /1024 [g]\012\015Z axis : 0x"
  0068          L68:    
  0068 ac0001b3 [8]             CALL  App_TransmitSensorData:435
  912:  			break;
  006c a702     [2]             AIS   #2
  006e 2007     [3]             BRA   L77 ;abs = 0077
  0070          L70:    
  913:  		default:
  914:  			UartUtil_Print("???????????????", gAllowToBlock_d);  		
  0070 450000   [3]             LDHX  @"???????????????"
  0073 ac0001b3 [8]             CALL  App_TransmitSensorData:435
  0077          L77:    
  915:  			break;
  916:  		}
  917:  		UartUtil_PrintHex((uint8_t *)&val, 2, 1);
  0077 95       [2]             TSX   
  0078 af09     [2]             AIX   #9
  007a 89       [2]             PSHX  
  007b 8b       [2]             PSHH  
  007c ae02     [2]             LDX   #2
  007e a601     [2]             LDA   #1
  0080 ac000000 [8]             CALL  UartUtil_PrintHex
  0084 a702     [2]             AIS   #2
  918:  		if(i==3){
  0086 95       [2]             TSX   
  0087 e601     [3]             LDA   1,X
  0089 a103     [2]             CMP   #3
  008b 2607     [3]             BNE   L94 ;abs = 0094
  919:  			UartUtil_Print(" /1024 [g]", gAllowToBlock_d);  					
  008d 450000   [3]             LDHX  @" /1024 [g]"
  0090 ac0001b3 [8]             CALL  App_TransmitSensorData:435
  0094          L94:    
  0094 95       [2]             TSX   
  0095 6c01     [5]             INC   1,X
  0097 e601     [3]             LDA   1,X
  0099 a104     [2]             CMP   #4
  009b 2403     [3]             BCC   LA0 ;abs = 00a0
  009d cc000e   [4]             JMP   LE ;abs = 000e
  00a0          LA0:    
  920:  		}
  921:  	}
  922:  
  923:  	UartUtil_Print("\n\r-----------------------------------------------\n\r", gAllowToBlock_d); 
  00a0 450000   [3]             LDHX  @"\012\015-----------------------------------------------\012\015"
  00a3 ac0001b3 [8]             CALL  App_TransmitSensorData:435
  924:  
  925:  	sens_count++;
  00a7 450000   [3]             LDHX  @sens_count
  00aa 7c       [4]             INC   ,X
  926:  
  927:  	if (global_counter>=5){
  00ab c60000   [4]             LDA   global_counter
  00ae a105     [2]             CMP   #5
  00b0 2403     [3]             BCC   LB5 ;abs = 00b5
  00b2 cc017e   [4]             JMP   L17E ;abs = 017e
  00b5          LB5:    
  928:  		global_counter=0;
  00b5 4f       [1]             CLRA  
  00b6 c70000   [4]             STA   global_counter
  929:  
  930:  		sens_data[0]=0x81;
  00b9 a681     [2]             LDA   #-127
  00bb 95       [2]             TSX   
  00bc e702     [3]             STA   2,X
  931:  		sens_data[1]=(x_avg >> 8) & 0xFF;
  00be c60000   [4]             LDA   x_avg
  00c1 e703     [3]             STA   3,X
  932:  		sens_data[2]=x_avg & 0xFF;
  00c3 c60001   [4]             LDA   x_avg:1
  00c6 e704     [3]             STA   4,X
  933:  		sens_data[3]=(y_avg >> 8) & 0xFF;
  00c8 c60000   [4]             LDA   y_avg
  00cb e705     [3]             STA   5,X
  934:  		sens_data[4]=y_avg & 0xFF;
  00cd c60001   [4]             LDA   y_avg:1
  00d0 e706     [3]             STA   6,X
  935:  		sens_data[5]=(z_avg >> 8) & 0xFF;
  00d2 c60000   [4]             LDA   z_avg
  00d5 e707     [3]             STA   7,X
  936:  		sens_data[6]=z_avg & 0xFF;
  00d7 c60001   [4]             LDA   z_avg:1
  00da e708     [3]             STA   8,X
  937:  
  938:  		UartUtil_Print("\n\r***************Average*************\n\r", gAllowToBlock_d); 
  00dc 450000   [3]             LDHX  @"\012\015***************Average*************\012\015"
  00df ac0001b3 [8]             CALL  App_TransmitSensorData:435
  939:  
  940:  		for(i=1; i<4; i++){
  00e3 a601     [2]             LDA   #1
  00e5 95       [2]             TSX   
  00e6 e701     [3]             STA   1,X
  00e8          LE8:    
  941:  			switch(i){			
  00e8 95       [2]             TSX   
  00e9 e601     [3]             LDA   1,X
  00eb a103     [2]             CMP   #3
  00ed 221b     [3]             BHI   L10A ;abs = 010a
  00ef 410109   [4]             CBEQA #1,LFB ;abs = 00fb
  00f2 41020b   [4]             CBEQA #2,L100 ;abs = 0100
  00f5 a103     [2]             CMP   #3
  00f7 2611     [3]             BNE   L10A ;abs = 010a
  00f9 200a     [3]             BRA   L105 ;abs = 0105
  00fb          LFB:    
  942:  			case 1:
  943:  				UartUtil_Print("MMA8652(2g: Int2,Float10) \n\rX axis : 0x", gAllowToBlock_d); 
  00fb 450000   [3]             LDHX  @"MMA8652(2g: Int2,Float10) \012\015X axis : 0x"
  944:  				break;
  00fe 200d     [3]             BRA   L10D ;abs = 010d
  0100          L100:   
  945:  			case 2:
  946:  				UartUtil_Print(" /1024 [g]\n\rY axis : 0x", gAllowToBlock_d);  
  0100 450000   [3]             LDHX  @" /1024 [g]\012\015Y axis : 0x"
  947:  				break;
  0103 2008     [3]             BRA   L10D ;abs = 010d
  0105          L105:   
  948:  			case 3:
  949:  				UartUtil_Print(" /1024 [g]\n\rZ axis : 0x", gAllowToBlock_d);  		
  0105 450000   [3]             LDHX  @" /1024 [g]\012\015Z axis : 0x"
  950:  				break;
  0108 2003     [3]             BRA   L10D ;abs = 010d
  010a          L10A:   
  951:  			default:
  952:  				UartUtil_Print("???????????????", gAllowToBlock_d);  		
  010a 450000   [3]             LDHX  @"???????????????"
  010d          L10D:   
  010d ac0001b3 [8]             CALL  App_TransmitSensorData:435
  953:  				break;
  954:  			}//switch(i){	 	
  955:  
  956:  			UartUtil_PrintHex((uint8_t *)&sens_data[2*i-1], 2, 1); 	
  0111 95       [2]             TSX   
  0112 e601     [3]             LDA   1,X
  0114 48       [1]             LSLA  
  0115 af02     [2]             AIX   #2
  0117 4a       [1]             DECA  
  0118 9ee701   [4]             STA   1,SP
  011b 9f       [1]             TXA   
  011c 9eeb01   [4]             ADD   1,SP
  011f 87       [2]             PSHA  
  0120 8b       [2]             PSHH  
  0121 86       [3]             PULA  
  0122 a900     [2]             ADC   #0
  0124 87       [2]             PSHA  
  0125 ae02     [2]             LDX   #2
  0127 a601     [2]             LDA   #1
  0129 ac000000 [8]             CALL  UartUtil_PrintHex
  012d a702     [2]             AIS   #2
  957:  
  958:  			if(i==3){
  012f 95       [2]             TSX   
  0130 e601     [3]             LDA   1,X
  0132 a103     [2]             CMP   #3
  0134 2607     [3]             BNE   L13D ;abs = 013d
  959:  				UartUtil_Print(" /1024 [g]", gAllowToBlock_d);  					
  0136 450000   [3]             LDHX  @" /1024 [g]"
  0139 ac0001b3 [8]             CALL  App_TransmitSensorData:435
  013d          L13D:   
  013d 95       [2]             TSX   
  013e 6c01     [5]             INC   1,X
  0140 e601     [3]             LDA   1,X
  0142 a104     [2]             CMP   #4
  0144 25a2     [3]             BCS   LE8 ;abs = 00e8
  960:  			}
  961:  
  962:  		} //for(i=1; i<4; i++){
  963:  
  964:  
  965:  		UartUtil_Print("\n\r*********************************\n\r", gAllowToBlock_d); 		
  0146 450000   [3]             LDHX  @"\012\015*********************************\012\015"
  0149 ac0001b3 [8]             CALL  App_TransmitSensorData:435
  966:  
  967:  
  968:  		GenandTransData(7, sens_data, (void*)mCoordInfo.coordAddress);
  014d a607     [2]             LDA   #7
  014f 87       [2]             PSHA  
  0150 95       [2]             TSX   
  0151 af03     [2]             AIX   #3
  0153 89       [2]             PSHX  
  0154 8b       [2]             PSHH  
  0155 450000   [3]             LDHX  @mCoordInfo
  0158 ac000000 [8]             CALL  GenandTransData
  015c a703     [2]             AIS   #3
  969:  		sens_count=0;
  015e 4f       [1]             CLRA  
  015f c70000   [4]             STA   sens_count
  970:  		for(i=0;i<7;i++){
  0162 95       [2]             TSX   
  0163 6f01     [5]             CLR   1,X
  0165          L165:   
  971:  			sens_data[i]=0;
  0165 95       [2]             TSX   
  0166 af02     [2]             AIX   #2
  0168 9f       [1]             TXA   
  0169 9eeb02   [4]             ADD   2,SP
  016c 87       [2]             PSHA  
  016d 8b       [2]             PSHH  
  016e 86       [3]             PULA  
  016f a900     [2]             ADC   #0
  0171 87       [2]             PSHA  
  0172 8a       [3]             PULH  
  0173 88       [3]             PULX  
  0174 7f       [4]             CLR   ,X
  0175 95       [2]             TSX   
  0176 6c01     [5]             INC   1,X
  0178 e601     [3]             LDA   1,X
  017a a107     [2]             CMP   #7
  017c 25e7     [3]             BCS   L165 ;abs = 0165
  017e          L17E:   
  972:  		}
  973:  	}
  974:  	
  975:  }
  017e a70b     [2]             AIS   #11
  0180 8d       [7]             RTC   
  0181          L181:   
  0181 9efe0f   [5]             LDHX  15,SP
  0184 9f       [1]             TXA   
  0185 8b       [2]             PSHH  
  0186 95       [2]             TSX   
  0187 eb05     [3]             ADD   5,X
  0189 e705     [3]             STA   5,X
  018b 86       [3]             PULA  
  018c e904     [3]             ADC   4,X
  018e ee06     [3]             LDX   6,X
  0190 8c       [1]             CLRH  
  0191 af01     [2]             AIX   #1
  0193 9ee706   [4]             STA   6,SP
  0196 9ee605   [4]             LDA   5,SP
  0199 87       [2]             PSHA  
  019a 9ee607   [4]             LDA   7,SP
  019d 87       [2]             PSHA  
  019e cd0000   [6]             JSR   _IDIVS_STAR08
  01a1 a702     [2]             AIS   #2
  01a3 8d       [7]             RTC   
  01a4          L1A4:   
  01a4 89       [2]             PSHX  
  01a5 8b       [2]             PSHH  
  01a6 ce0000   [4]             LDX   sens_count
  01a9 8c       [1]             CLRH  
  01aa 9eef06   [4]             STX   6,SP
  01ad cd0000   [6]             JSR   _IMUL_STAR08
  01b0 a702     [2]             AIS   #2
  01b2 8d       [7]             RTC   
  01b3          L1B3:   
  01b3 a601     [2]             LDA   #1
  01b5 ac000000 [8]             CALL  UartUtil_Print
  01b9 8d       [7]             RTC   
  976:  
  977:  static void GenandTransData(uint8_t Length, uint8_t* pTxData, uint8_t* dest_addr){
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  978:   
  979:  	/* Use multi buffering for increased TX performance. It does not really
  980:       have any effect at a UART baud rate of 19200bps but serves as an
  981:       example of how the throughput may be improved in a real-world 
  982:       application where the data rate is of concern. */
  983:    if( (mcPendingPackets < mDefaultValueOfMaxPendingDataPackets_c) && (mpPacket == NULL) ) 
  0002 c60000   [4]             LDA   mcPendingPackets
  0005 a102     [2]             CMP   #2
  0007 240e     [3]             BCC   L17 ;abs = 0017
  0009 320000   [5]             LDHX  mpPacket
  000c 2609     [3]             BNE   L17 ;abs = 0017
  984:    {
  985:      /* If the maximum number of pending data buffes is below maximum limit 
  986:         and we do not have a data buffer already then allocate one. */
  987:      mpPacket = MSG_Alloc(gMaxRxTxDataLength_c);
  000e a68d     [2]             LDA   #-115
  0010 ac000000 [8]             CALL  MM_Alloc
  0014 960000   [5]             STHX  mpPacket
  0017          L17:    
  988:    }
  989:    
  990:    if(mpPacket != NULL)
  0017 320000   [5]             LDHX  mpPacket
  001a 277e     [3]             BEQ   L9A ;abs = 009a
  991:    {
  992:      /* get data from UART */        
  993:        mpPacket->msgData.dataReq.pMsdu = (uint8_t*)(&(mpPacket->msgData.dataReq.pMsdu)) + sizeof(uint8_t*);
  001c af1c     [2]             AIX   #28
  001e 9f       [1]             TXA   
  001f 8b       [2]             PSHH  
  0020 320000   [5]             LDHX  mpPacket
  0023 e71b     [3]             STA   27,X
  0025 86       [3]             PULA  
  0026 e71a     [3]             STA   26,X
  994:        FLib_MemCpy(mpPacket->msgData.dataReq.pMsdu, (uint8_t*) pTxData, Length);
  0028 9ece1a   [5]             LDHX  26,X
  002b 89       [2]             PSHX  
  002c 8b       [2]             PSHH  
  002d 9efe08   [5]             LDHX  8,SP
  0030 9ee60a   [4]             LDA   10,SP
  0033 ac000000 [8]             CALL  FLib_MemCpy
  0037 a702     [2]             AIS   #2
  995:        /* Data was available in the UART receive buffer. Now create an
  996:           MCPS-Data Request message containing the UART data. */
  997:        mpPacket->msgType = gMcpsDataReq_c;
  0039 320000   [5]             LDHX  mpPacket
  003c 7f       [4]             CLR   ,X
  998:        /* Create the header using coordinator information gained during 
  999:           the scan procedure. Also use the short address we were assigned
 1000:           by the coordinator during association. */
 1001:        FLib_MemCpy(mpPacket->msgData.dataReq.dstAddr,dest_addr, 8);
  003d af01     [2]             AIX   #1
  003f 89       [2]             PSHX  
  0040 8b       [2]             PSHH  
  0041 9efe03   [5]             LDHX  3,SP
  0044 a608     [2]             LDA   #8
  0046 ac000000 [8]             CALL  FLib_MemCpy
  004a a702     [2]             AIS   #2
 1002:        FLib_MemCpy(mpPacket->msgData.dataReq.srcAddr, maMyAddress, 8);
  004c 320000   [5]             LDHX  mpPacket
  004f af0c     [2]             AIX   #12
  0051 89       [2]             PSHX  
  0052 8b       [2]             PSHH  
  0053 450000   [3]             LDHX  @maMyAddress
  0056 a608     [2]             LDA   #8
  0058 ac000000 [8]             CALL  FLib_MemCpy
  005c a702     [2]             AIS   #2
 1003:        FLib_MemCpy(mpPacket->msgData.dataReq.dstPanId, mCoordInfo.coordPanId, 2);
  005e 320000   [5]             LDHX  mpPacket
  0061 af09     [2]             AIX   #9
  0063 ac00009d [8]             CALL  GenandTransData:157
 1004:        FLib_MemCpy(mpPacket->msgData.dataReq.srcPanId, mCoordInfo.coordPanId, 2);
  0067 320000   [5]             LDHX  mpPacket
  006a af14     [2]             AIX   #20
  006c ac00009d [8]             CALL  GenandTransData:157
 1005:        mpPacket->msgData.dataReq.dstAddrMode = mCoordInfo.coordAddrMode;
  0070 c6000a   [4]             LDA   mCoordInfo:10
  0073 320000   [5]             LDHX  mpPacket
  0076 e70b     [3]             STA   11,X
 1006:        mpPacket->msgData.dataReq.srcAddrMode = mAddrMode;
  0078 c60000   [4]             LDA   mAddrMode
  007b e716     [3]             STA   22,X
 1007:        mpPacket->msgData.dataReq.msduLength = Length;
  007d 9ee608   [4]             LDA   8,SP
  0080 e717     [3]             STA   23,X
 1008:        /* Request MAC level acknowledgement of the data packet */
 1009:        mpPacket->msgData.dataReq.txOptions = 0;
  0082 6f19     [5]             CLR   25,X
 1010:        /* Give the data packet a handle. The handle is
 1011:           returned in the MCPS-Data Confirm message. */
 1012:        mpPacket->msgData.dataReq.msduHandle = mMsduHandle++;
  0084 c60000   [4]             LDA   mMsduHandle
  0087 e718     [3]             STA   24,X
  0089 4c       [1]             INCA  
  008a c70000   [4]             STA   mMsduHandle
 1013:  #ifdef gMAC2006_d
 1014:  	  mpPacket->msgData.dataReq.securityLevel = 0;
 1015:  #endif //gMAC2006_d	  
 1016:        
 1017:        /* Send the Data Request to the MCPS */
 1018:        (void)MSG_Send(NWK_MCPS, mpPacket);
  008d ac000000 [8]             CALL  NWK_MCPS_SapHandler
 1019:        /* Prepare for another data buffer */
 1020:        mpPacket = NULL;
  0091 5f       [1]             CLRX  
  0092 8c       [1]             CLRH  
  0093 960000   [5]             STHX  mpPacket
 1021:        mcPendingPackets++;
  0096 450000   [3]             LDHX  @mcPendingPackets
  0099 7c       [4]             INC   ,X
  009a          L9A:    
 1022:    }
 1023:     
 1024:  
 1025:  }
  009a a702     [2]             AIS   #2
  009c 8d       [7]             RTC   
  009d          L9D:    
  009d 89       [2]             PSHX  
  009e 8b       [2]             PSHH  
  009f 450008   [3]             LDHX  @mCoordInfo:8
  00a2 a602     [2]             LDA   #2
  00a4 ac000000 [8]             CALL  FLib_MemCpy
  00a8 a702     [2]             AIS   #2
  00aa 8d       [7]             RTC   
 1026:  
 1027:  /*****************************************************************************
 1028:  * Function to handle a generic key press. Called for all keys.
 1029:  *****************************************************************************/
 1030:  static void App_HandleGenericKey(void)
 1031:  {
 1032:    if(gState == stateInit)
  0000 c60000   [4]             LDA   gState
  0003 262a     [3]             BNE   L2F ;abs = 002f
 1033:    {
 1034:     StopLed1Flashing();
  0005 a601     [2]             LDA   #1
  0007 ac000000 [8]             CALL  LED_StopFlash
 1035:     StopLed2Flashing();
  000b a602     [2]             LDA   #2
  000d ac000000 [8]             CALL  LED_StopFlash
 1036:     StopLed3Flashing();
  0011 a604     [2]             LDA   #4
  0013 ac000000 [8]             CALL  LED_StopFlash
 1037:     StopLed4Flashing();
  0017 a608     [2]             LDA   #8
  0019 ac000000 [8]             CALL  LED_StopFlash
 1038:     Led1Off();
  001d 1000     [5]             BSET  0,0
 1039:     Led2Off();
  001f 1800     [5]             BSET  4,0
 1040:     Led3Off();
  0021 1006     [5]             BSET  0,6
 1041:     Led4Off();
  0023 1206     [5]             BSET  1,6
 1042:     LCD_ClearDisplay();
 1043:     LCD_WriteString(1,"Application");
 1044:     LCD_WriteString(2,"    started");     
 1045:     TS_SendEvent(gAppTaskID_c, gAppEvtDummyEvent_c);       
  0025 c60000   [4]             LDA   gAppTaskID_c
  0028 ae01     [2]             LDX   #1
  002a 8c       [1]             CLRH  
  002b ac000000 [8]             CALL  TS_SendEvent
  002f          L2F:    
 1046:    }
 1047:  }
  002f 8d       [7]             RTC   
 1048:  
 1049:  /*****************************************************************************
 1050:  * Handles all key events for this device.
 1051:  * Interface assumptions: None
 1052:  * Return value: None
 1053:  *****************************************************************************/
 1054:  #if (gMC1323xMatrixKBD_d == TRUE)
 1055:  static void App_HandleKeys(uint8_t events, uint8_t pressedKey)   
 1056:  {
 1057:   (void)events;
 1058:   (void)pressedKey;
 1059:   App_HandleGenericKey();
  0000 ac000000 [8]             CALL  App_HandleGenericKey
 1060:  }
  0004 8d       [7]             RTC   
 1061:  #else
 1062:  static void App_HandleKeys(key_event_t events)
 1063:  {
 1064:    switch ( events ) 
 1065:      { 
 1066:        case gKBD_EventSW1_c:
 1067:        case gKBD_EventSW2_c:
 1068:        case gKBD_EventSW3_c:
 1069:        case gKBD_EventSW4_c:
 1070:        case gKBD_EventLongSW1_c:
 1071:        case gKBD_EventLongSW2_c:
 1072:        case gKBD_EventLongSW3_c:
 1073:        case gKBD_EventLongSW4_c:
 1074:         App_HandleGenericKey();
 1075:  	  break; 
 1076:      }    
 1077:  }
 1078:  #endif //gMC1323xMatrixKBD_d
 1079:  
 1080:  /*****************************************************************************
 1081:  * The DeepSleepWakeupStackProc(void) function is called each time the 
 1082:  * application exits the DeepSleep mode .
 1083:  * 
 1084:  * Return value:
 1085:  *     None
 1086:  *****************************************************************************/
 1087:  void DeepSleepWakeupStackProc(void){
 1088:    return;
 1089:  }
  0000 8d       [7]             RTC   
 1090:  
 1091:  /******************************************************************************
 1092:  * The following functions are called by the MAC to put messages into the
 1093:  * Application's queue. They need to be defined even if they are not used
 1094:  * in order to avoid linker errors.
 1095:  ******************************************************************************/
 1096:  
 1097:  uint8_t MLME_NWK_SapHandler(nwkMessage_t * pMsg)
 1098:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1099:    /* Put the incoming MLME message in the applications input queue. */
 1100:    MSG_Queue(&mMlmeNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMlmeNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
 1101:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMLME_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae04     [2]             LDX   #4
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
 1102:    return gSuccess_c;
  001a 4f       [1]             CLRA  
 1103:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
 1104:  
 1105:  uint8_t MCPS_NWK_SapHandler(mcpsToNwkMessage_t *pMsg)
 1106:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1107:    /* Put the incoming MCPS message in the applications input queue. */
 1108:    MSG_Queue(&mMcpsNwkInputQueue, pMsg);
  0002 450000   [3]             LDHX  @mMcpsNwkInputQueue
  0005 89       [2]             PSHX  
  0006 8b       [2]             PSHH  
  0007 9efe03   [5]             LDHX  3,SP
  000a ac000000 [8]             CALL  List_AddTail
  000e a702     [2]             AIS   #2
 1109:    TS_SendEvent(gAppTaskID_c, gAppEvtMessageFromMCPS_c);
  0010 c60000   [4]             LDA   gAppTaskID_c
  0013 ae08     [2]             LDX   #8
  0015 8c       [1]             CLRH  
  0016 ac000000 [8]             CALL  TS_SendEvent
 1110:    return gSuccess_c;
  001a 4f       [1]             CLRA  
 1111:  }
  001b a702     [2]             AIS   #2
  001d 8d       [7]             RTC   
 1112:  
 1113:  uint8_t ASP_APP_SapHandler(aspToAppMsg_t *pMsg)
 1114:  {
 1115:    /* If the message is not handled anywhere it must be freed. */
 1116:    MSG_Free(pMsg);
  0000 ac000000 [8]             CALL  MM_Free
 1117:    return gSuccess_c;
  0004 4f       [1]             CLRA  
 1118:  }
  0005 8d       [7]             RTC   
 1119:  
 1120:  /******************************************************************************/
 1121:  
